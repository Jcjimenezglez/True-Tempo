// Helper function to hash email for Google Ads Enhanced Conversions
// Uses Web Crypto API (SHA-256) - only works in secure contexts (HTTPS)
async function hashEmail(email) {
    if (!email) return null;
    
    // Check if crypto.subtle is available (requires HTTPS)
    if (!window.crypto || !window.crypto.subtle) {
        console.warn('‚ö†Ô∏è crypto.subtle not available (requires HTTPS)');
        return null;
    }
    
    try {
        // Normalize email: lowercase and trim
        const normalizedEmail = email.toLowerCase().trim();
        
        // Convert string to Uint8Array
        const encoder = new TextEncoder();
        const data = encoder.encode(normalizedEmail);
        
        // Hash with SHA-256
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        
        // Convert to hex string
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        
        return hashHex;
    } catch (error) {
        console.error('Error hashing email:', error);
        return null;
    }
}

// Make hashEmail available globally for Enhanced Conversions
window.hashEmail = hashEmail;

class PomodoroTimer {
    constructor() {
        // Initialize Mixpanel tracking removed - Page Loaded event no longer needed
        
        
        // Pomodoro Technique structure - Load from localStorage if authenticated
        const savedPomodoroTime = localStorage.getItem('pomodoroTime');
        const savedShortBreakTime = localStorage.getItem('shortBreakTime');
        const savedLongBreakTime = localStorage.getItem('longBreakTime');
        
        this.workTime = savedPomodoroTime ? parseInt(savedPomodoroTime) : 25 * 60; // 25 minutes default
        this.shortBreakTime = savedShortBreakTime ? parseInt(savedShortBreakTime) : 5 * 60; // 5 minutes default
        this.longBreakTime = savedLongBreakTime ? parseInt(savedLongBreakTime) : 15 * 60; // 15 minutes default
        this.sessionsPerCycle = 4; // 4 work sessions before long break
        
        // Current state
        this.timeLeft = this.workTime;
        this.isRunning = false;
        this.currentSection = 1; // 1-8 for complete cycle
        this.isWorkSession = true;
        this.isLongBreak = false;
        this.currentTaskName = null; // Current task being worked on
        this.sessionTasks = []; // Array to store tasks for each focus session
        this.interval = null;
        
        // Anti-cheat tracking within the current cycle
        this.completedFocusSessionsInCycle = 0; // counts naturally finished focus sessions
        this.cheatedDuringFocusInCycle = false; // true if user used next/back while in a focus session
        this.actualFocusTimeCompleted = 0; // tracks actual seconds of focus completed in current cycle
        this.requiredFocusTimeForCycle = 0; // total focus time required for a complete cycle

        // Day streak tracking
        this.streakData = this.loadStreakData();
        this.hasCompletedFocusToday = false; // tracks if user completed focus session today
        // Track focused seconds today for 1-minute streak rule
        // Note: Will be properly loaded after auth with user-specific key
            this.focusSecondsToday = 0;

        // Leaderboard cache to avoid unnecessary API calls (multi-page support)
        this.LEADERBOARD_CACHE_VERSION = 'premium-v2';
        this.LEADERBOARD_CACHE_TTL_MS = 10 * 60 * 1000;
        this.LEADERBOARD_AUTO_REFRESH_MS = 30 * 1000;
        this.leaderboardAutoRefreshId = null;
        this.leaderboardCurrentPage = 1;
        this.leaderboardModalCurrentPage = 1;

        // Load from localStorage if exists
        try {
            const savedVersion = localStorage.getItem('leaderboardCacheVersion');
            if (savedVersion !== this.LEADERBOARD_CACHE_VERSION) {
                localStorage.removeItem('leaderboardCache');
                localStorage.removeItem('leaderboardCachedAtHours');
                localStorage.setItem('leaderboardCacheVersion', this.LEADERBOARD_CACHE_VERSION);
            }

            const savedCache = localStorage.getItem('leaderboardCache');
            const savedHours = localStorage.getItem('leaderboardCachedAtHours');
            this.leaderboardCache = savedCache ? JSON.parse(savedCache) : {};
            this.leaderboardCachedAtHours = savedHours ? parseFloat(savedHours) : 0;
            if (Object.keys(this.leaderboardCache).length > 0) {
                console.log(`üì¶ Loaded leaderboard cache from localStorage (${Object.keys(this.leaderboardCache).length} pages cached at ${this.leaderboardCachedAtHours.toFixed(2)}h)`);
            }
        } catch (err) {
            console.error('Failed to load leaderboard cache:', err);
            this.leaderboardCache = {};
            this.leaderboardCachedAtHours = 0;
        }

        // Daily focus cap for non‚ÄëPro users (in seconds) and cooldown
        this.DAILY_FOCUS_LIMIT_SECONDS = 60 * 60; // 1 hour
        this.FOCUS_LIMIT_COOLDOWN_MS = 23 * 60 * 60 * 1000; // 23 hours
        
        // Load cooldown timestamp (if any) and prune if expired
        try {
            const rawUntil = localStorage.getItem('focusLimitCooldownUntil');
            this.focusLimitCooldownUntil = rawUntil ? parseInt(rawUntil, 10) : 0;
            if (isNaN(this.focusLimitCooldownUntil)) this.focusLimitCooldownUntil = 0;
            if (this.focusLimitCooldownUntil && Date.now() >= this.focusLimitCooldownUntil) {
                console.log('‚è∞ Daily focus cooldown has expired, resetting');
                this.focusLimitCooldownUntil = 0;
                localStorage.removeItem('focusLimitCooldownUntil');
            } else if (this.focusLimitCooldownUntil) {
                const remainingHours = (this.focusLimitCooldownUntil - Date.now()) / (60 * 60 * 1000);
                console.log('‚è≥ Daily focus cooldown active:', {
                    expiresAt: new Date(this.focusLimitCooldownUntil).toLocaleString(),
                    remainingHours: remainingHours.toFixed(2)
                });
            }
        } catch (_) {
            this.focusLimitCooldownUntil = 0;
        }

        // Task execution queue (built from selected tasks and their session counts)
        this.taskQueue = [];
        this.currentTaskIndex = 0;
        this.currentTask = null;
        
        // Current task for local tasks only
        this.currentTask = null; // { id, content }
        
		// Lofi music system with shuffle
		this.lofiPlaying = false;
		const savedLofiEnabled = localStorage.getItem('lofiEnabled');
		this.lofiEnabled = savedLofiEnabled === null ? true : savedLofiEnabled === 'true';
		
		// Lofi playlist - will be dynamically loaded from /audio/Lofi/
		this.lofiPlaylist = [];
		this.lofiShuffledPlaylist = [];
		this.currentLofiTrackIndex = 0;
		
		// Load saved volume if exists, otherwise default to 25%
		const savedVolume = localStorage.getItem('lofiVolume');
		this.lofiVolume = savedVolume !== null ? Math.max(0, Math.min(1, parseFloat(savedVolume))) : 0.25;
		// Fade/ducking state
		this.isDucked = false;
		this.duckRestoreTimer = null;
		this.fadeTimer = null;
        
		// Immersive Theme System
		// Only load saved immersive theme if user is authenticated
		if (this.isAuthenticated) {
			this.currentImmersiveTheme = localStorage.getItem('selectedImmersiveTheme') || 'none';
		} else {
			this.currentImmersiveTheme = 'none'; // Always default for guests
		}
		// Tron Spotify Widget Configuration
		this.tronSpotifyWidget = null;
		this.tronSpotifyPlaylistId = '47pjW3XDPW99NShtkeewxl'; // TRON: Ares Soundtrack by Nine Inch Nails
		this.tronSpotifyEmbedUrl = `https://open.spotify.com/embed/album/${this.tronSpotifyPlaylistId}?utm_source=generator`;
		this.tronSpotifyWidgetReady = false;
		this.spotifyLoadingElement = null;
		this.tronSpotifyWidgetActivated = false; // Track if widget has been activated
		
		// Custom Spotify widget URL tracking
		this.currentSpotifyUrl = null; // Track current Spotify URL to avoid unnecessary recreations
		
		
		// Note: We don't save Spotify connecting state - always show loading
		
        // Load last selected theme (for both authenticated and guest users)
        this.loadLastSelectedTheme();
        
        // Complete cycle: 25/5/25/5/25/5/25/15
        this.cycleSections = [
            { type: 'work', duration: this.workTime, name: 'Focus 1' },
            { type: 'break', duration: this.shortBreakTime, name: 'Break 1' },
            { type: 'work', duration: this.workTime, name: 'Focus 2' },
            { type: 'break', duration: this.shortBreakTime, name: 'Break 2' },
            { type: 'work', duration: this.workTime, name: 'Focus 3' },
            { type: 'break', duration: this.shortBreakTime, name: 'Break 3' },
            { type: 'work', duration: this.workTime, name: 'Focus 4' },
            { type: 'long-break', duration: this.longBreakTime, name: 'Long Break' }
        ];
        
        // Calculate required focus time for complete cycle
        this.calculateRequiredFocusTime();
        
        // DOM elements
        this.timeElement = document.getElementById('time');
        this.sessionInfoElement = document.getElementById('sessionInfo');
        this.currentTaskElement = document.getElementById('currentTask');
        this.taskNameDisplay = document.getElementById('taskNameDisplay');
        this.sessionLabelElement = document.getElementById('sessionLabel');
        this.startPauseBtn = document.getElementById('startPause');
        this.prevSectionBtn = document.getElementById('prevSectionBtn');
        this.nextSectionBtn = document.getElementById('nextSectionBtn');
        // Daily limit modal elements
        this.dailyLimitModalOverlay = document.getElementById('dailyLimitModalOverlay');
        this.dailyLimitSubscribeBtn = document.getElementById('dailyLimitSubscribeBtn');
        this.dailyLimitLaterBtn = document.getElementById('dailyLimitLaterBtn');
        this.closeDailyLimitModalX = document.getElementById('closeDailyLimitModalX');
        this.dailyLimitCountdownEl = document.getElementById('dailyLimitCountdown');
        this.dailyLimitCountdownTimer = null;
        this.musicToggleBtn = document.getElementById('musicToggleBtn');
        this.taskToggleBtn = document.getElementById('taskToggleBtn');
        this.progressSegments = document.querySelectorAll('.progress-segment');
        this.progressIndicator = document.querySelector('.progress-indicator');
        this.progressOverlays = document.querySelectorAll('.progress-overlay');
        this.techniqueTitle = document.getElementById('techniqueTitle');
        this.techniqueDropdown = document.getElementById('techniqueDropdown');
        this.dropdownMenu = document.getElementById('dropdownMenu');
        this.dropdownItems = document.querySelectorAll('.dropdown-item');
        this.timerTechniqueBtn = document.getElementById('timerTechniqueBtn');
        this.timerTechniqueName = document.getElementById('timerTechniqueName');
        this.sessionDots = document.getElementById('sessionDots');
        
        // Custom timer modal elements
        this.customTimerModal = document.getElementById('customTimerModal');
        this.closeCustomTimer = document.getElementById('closeCustomTimer');
        this.cancelCustomTimer = document.getElementById('cancelCustomTimer');
        this.saveCustomTimer = document.getElementById('saveCustomTimer');
        this.customPreview = document.getElementById('customPreview');
        this.backgroundAudio = document.getElementById('backgroundAudio');
        if (this.backgroundAudio) {
            this.backgroundAudio.addEventListener('ended', () => {
                // Advance to next Lofi track
                if (this.lofiPlaying || this.lofiEnabled) {
                    this.nextLofiTrack();
                }
            });
            // Defensive: when play() resolves, mark the correct flag
            this.backgroundAudio.addEventListener('play', () => {
                const src = this.backgroundAudio.currentSrc || this.backgroundAudio.src || '';
                const isLofi = /\/audio\/Lofi\//.test(src);
                this.lofiPlaying = isLofi;
            });
        }

		// Load Lofi playlist from /audio/Lofi/ directory
		this.loadLofiPlaylist();
        
        // Auth elements
        this.authContainer = document.getElementById('authContainer');
        this.loginButton = document.getElementById('loginButton');
        this.signupButton = document.getElementById('signupButton');
        
        // Settings dropdown elements
        this.headerSettingsBtn = document.getElementById('headerSettingsBtn');
        this.headerSettingsIcon = document.getElementById('headerSettingsIcon');
        this.headerSettingsAvatar = document.getElementById('headerSettingsAvatar');
        this.settingsDropdown = document.getElementById('settingsDropdown');
        this.settingsUserInfo = document.getElementById('settingsUserInfo');
        this.settingsUserEmail = document.getElementById('settingsUserEmail');
        this.settingsProBadge = document.getElementById('settingsProBadge');
        this.settingsAuthSection = document.getElementById('settingsAuthSection');
        this.settingsAccountSection = document.getElementById('settingsAccountSection');
        this.settingsReportSection = document.getElementById('settingsReportSection');
        this.settingsSettingsSection = document.getElementById('settingsSettingsSection');
        this.settingsLoginBtn = document.getElementById('settingsLoginBtn');
        this.settingsSignupBtn = document.getElementById('settingsSignupBtn');
        this.settingsUpgradeToProBtn = document.getElementById('settingsUpgradeToProBtn');
        this.settingsManageSubscriptionBtn = document.getElementById('settingsManageSubscriptionBtn');
        this.settingsAccountBtn = document.getElementById('settingsAccountBtn');
        this.productivityResourcesBtn = document.getElementById('productivityResourcesBtn');
        this.productivityResourcesModalOverlay = document.getElementById('productivityResourcesModalOverlay');
        this.leaderboardModalOverlay = document.getElementById('leaderboardModalOverlay');
        this.leaderboardRefreshBtn = document.getElementById('leaderboardRefreshBtn');
        this.settingsIntegrationsBtn = document.getElementById('settingsIntegrationsBtn');
        this.settingsFeedbackBtn = document.getElementById('settingsFeedbackBtn');
        this.settingsStatsDivider = document.getElementById('settingsStatsDivider');
        this.settingsUserDivider = document.getElementById('settingsUserDivider');
        this.shortcutsItem = document.getElementById('shortcutsItem');
        this.helpToggle = document.getElementById('helpToggle');
        this.helpPanel = document.getElementById('helpPanel');
        this.settingsLogoutBtn = document.getElementById('settingsLogoutBtn');
        this.settingsLogoutDivider = document.getElementById('settingsLogoutDivider');

        // Bottom sheet account (mobile/tablet)
        this.bottomSheetAccountItem = document.querySelector('.bottom-sheet-account-item');
        this.bottomSheetAccountIcon = document.getElementById('bottomSheetAccountIcon');
        this.bottomSheetAccountAvatar = document.getElementById('bottomSheetAccountAvatar');
        this.bottomSheetAccountName = document.getElementById('bottomSheetAccountName');
        this.bottomSheetAccountBadge = document.getElementById('bottomSheetAccountBadge');
        this.accountMenuLogin = document.getElementById('accountMenuLogin');
        this.accountMenuSignup = document.getElementById('accountMenuSignup');
        this.accountMenuUnlock = document.getElementById('accountMenuUnlock');
        this.accountMenuManageSubscription = document.getElementById('accountMenuManageSubscription');
        this.accountMenuSettings = document.getElementById('accountMenuSettings');
        this.accountMenuLogout = document.getElementById('accountMenuLogout');
        
        // Logo and achievement elements
        this.logoIcon = document.getElementById('logoIcon');
        this.achievementIcon = document.getElementById('achievementIcon');
        this.achievementCounter = document.getElementById('achievementCounter');
        this.streakInfo = document.getElementById('streakInfo');
        this.streakDays = document.getElementById('streakDays');
        // User profile elements (shown when authenticated)
        this.userProfileContainer = document.getElementById('userProfileContainer');
        this.userProfileButton = document.getElementById('userProfileButton');
        this.userProfileDropdown = document.getElementById('userProfileDropdown');
        this.userDropdownMenu = document.getElementById('userDropdownMenu');
        this.userAvatar = document.getElementById('userAvatar');
        this.logoutButton = document.getElementById('logoutButton');
        this.resetStatsButton = document.getElementById('resetStatsButton');
        
        // Logout modal elements
        this.logoutModalOverlay = document.getElementById('logoutModalOverlay');
        this.logoutModalMessage = document.getElementById('logoutModalMessage');
        
        // Feedback modal elements
        this.feedbackModalOverlay = document.getElementById('feedbackModalOverlay');
        this.feedbackText = document.getElementById('feedbackText');
        this.confirmLogoutBtn = document.getElementById('confirmLogoutBtn');
        this.cancelLogoutBtn = document.getElementById('cancelLogoutBtn');
        
        // Integration Modal elements
        this.integrationModalOverlay = document.getElementById('integrationModalOverlay');
        this.integrationModalMessage = document.getElementById('integrationModalMessage');
        this.closeIntegrationModalX = document.getElementById('closeIntegrationModalX');
        this.integrationModalPrimaryBtn = document.getElementById('integrationModalPrimaryBtn');
        this.integrationModalSecondaryBtn = document.getElementById('integrationModalSecondaryBtn');
        
        // Guest task limit modal elements
        this.guestTaskLimitModalOverlay = document.getElementById('guestTaskLimitModalOverlay');
        this.guestTaskLimitSignupBtn = document.getElementById('guestTaskLimitSignupBtn');
        this.guestTaskLimitCancelBtn = document.getElementById('guestTaskLimitCancelBtn');
        
        
        
        // Auth state
        this.isAuthenticated = false;
        this.user = null;
        this.isPro = false;
        // Signals when Clerk auth has fully hydrated for this session
        this.authReady = false;
        this.confirmedCheckoutSessionId = null;
        
        // Loading screen management
        this.loadingScreen = document.getElementById('loadingScreen');
        this.isLoading = false;
        this.loadingStartTime = null;
        
        // Track if public vibes are currently loading to prevent duplicate calls
        this.isLoadingPublicCassettes = false;
        
        // Track last applied active cassette to prevent redundant state applications
        this._lastAppliedActiveCassette = null;
        this.minLoadingTime = 0; // No enforced minimum - never delay normal users
        
        // Task form state
        this.editingTaskId = null;
        
        // Audio state
        this.currentAudio = null;
        this.cassetteSounds = null;
        
        // Selection restore flags
        this.hasAppliedSavedTechnique = false;
        this.pendingSelectedTechnique = null;

        this.init();
        
        // Mark window as active to detect if it was closed vs refreshed
        sessionStorage.setItem('windowActive', 'true');
        
        // Listen for window close events
        window.addEventListener('beforeunload', () => {
            sessionStorage.removeItem('windowActive');
        });
        
        // Also listen for visibility change (tab switching)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Tab is hidden, but window is still open
                // Keep windowActive flag
            } else {
                // Tab is visible again, ensure windowActive flag exists
                sessionStorage.setItem('windowActive', 'true');
            }
        });
    }
    
    // Mixpanel Analytics Functions
    trackEvent(eventName, properties = {}) {
        console.log('üîç Attempting to track event:', eventName);
        console.log('üîç Mixpanel available:', typeof window.mixpanel);
        console.log('üîç Mixpanel track function:', typeof window.mixpanel?.track);
        let enrichedProperties = properties;
        
        if (typeof window.mixpanel !== 'undefined' && window.mixpanel.track) {
            try {
                const eventProperties = {
                    ...properties,
                    timestamp: new Date().toISOString(),
                    user_authenticated: this.isAuthenticated,
                    user_pro: this.isPro,
                    user_id: this.user?.id || 'guest'
                };
                
                window.mixpanel.track(eventName, eventProperties);
                console.log('‚úÖ Event tracked successfully:', eventName, eventProperties);
                enrichedProperties = eventProperties;
            } catch (error) {
                console.error('‚ùå Error tracking event:', error);
            }
        } else {
            console.warn('‚ö†Ô∏è Mixpanel not available or track function missing');
        }

        // Track Subscribe Clicked to Google Ads for ALL CTA buttons (Unlock Unlimited, etc.)
        // This captures the initial intent signal when user clicks any upgrade button
        if (eventName === 'Subscribe Clicked' || eventName === 'Daily Limit Subscribe Clicked') {
            this.trackSubscribeClickedToGoogleAds(enrichedProperties);
        }
    }
    
    identifyUser() {
        if (this.isAuthenticated && this.user && typeof window.mixpanel !== 'undefined') {
            try {
                window.mixpanel.identify(this.user.id);
                window.mixpanel.people.set({
                    '$email': this.user.emailAddresses[0]?.emailAddress,
                    '$name': this.user.fullName,
                    'pro_user': this.isPro,
                    'signup_date': this.user.createdAt
                });
                console.log('‚úÖ User identified:', this.user.id);
            } catch (error) {
                console.error('‚ùå Error identifying user:', error);
            }
        }
    }
    
    // Track Subscribe Clicked to Google Ads (intent signal, not final conversion)
    // Uses generic label zsizCNqYgbgbENjym89B with $1.0 value
    // Called automatically from trackEvent() for all Subscribe Clicked events
    async trackSubscribeClickedToGoogleAds(properties = {}) {
        if (typeof window.gtag === 'function') {
            try {
                const source = properties.source || 'unknown';
                const userType = properties.user_type || (this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest');
                
                // Get user email for Enhanced Conversions
                let hashedEmail = null;
                if (window.Clerk && window.Clerk.user && typeof window.hashEmail === 'function') {
                    const userEmail = window.Clerk.user.primaryEmailAddress?.emailAddress;
                    if (userEmail) {
                        hashedEmail = await window.hashEmail(userEmail);
                    }
                }
                
                // Track as engagement event (intent signal)
                window.gtag('event', 'subscribe_clicked', {
                    'event_category': 'engagement',
                    'event_label': source,
                    'source': source,
                    'user_type': userType,
                    'value': 1.0,
                    'currency': 'USD',
                    'non_interaction': false
                });
                
                // Set Enhanced Conversions user data BEFORE the conversion event
                if (hashedEmail) {
                    window.gtag('set', 'user_data', {
                        'sha256_email_address': hashedEmail
                    });
                    console.log('‚úÖ Enhanced Conversions: User data set');
                }
                
                // Track Google Ads Subscribe Clicked conversion
                window.gtag('event', 'conversion', {
                    'send_to': 'AW-17614436696/zsizCNqYgbgbENjym89B',
                    'value': 1.0,
                    'currency': 'USD'
                });
                
                console.log('‚úÖ Subscribe Clicked tracked to Google Ads:', source);
            } catch (error) {
                console.error('‚ùå Error tracking to Google Ads:', error);
            }
        } else {
            console.warn('‚ö†Ô∏è gtag not available for Google Ads tracking');
        }
    }
    
    getCurrentTaskCount() {
        try {
            const tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
            return tasks.length;
        } catch (error) {
            return 0;
        }
    }

    captureAdsClickIds() {
        try {
            const params = new URLSearchParams(window.location.search);
            const gclid = params.get('gclid');
            const gbraid = params.get('gbraid');
            const wbraid = params.get('wbraid');

            if (gclid || gbraid || wbraid) {
                const payload = { gclid, gbraid, wbraid, ts: Date.now() };
                localStorage.setItem('ads_click_ids', JSON.stringify(payload));
            }
        } catch (error) {
            // Best-effort capture only; no user impact on failure.
        }
    }
    
    init() {
        this.captureAdsClickIds();
        this.layoutSegments();
        this.updateDisplay();
        this.updateProgress();
        this.updateSections();
        this.updateSessionInfo();
        this.updateStreakDisplay();
        this.bindEvents();
        this.updateTechniqueTitle();
        this.loadAudio();
        this.loadCassetteSounds();
        this.loadTronAssets();
        this.updateNavigationButtons();
        this.initClerk();
        
        // Apply saved background and overlay on init
        // Initialize new theme system (default to lofi)
        // Load last selected theme from localStorage (works for both authenticated and guest users)
        const lastSelectedTheme = localStorage.getItem('lastSelectedTheme');
        // Track if we must defer Tron application until auth hydrates
        this.pendingThemeApply = null;
        if (lastSelectedTheme) {
            this.currentTheme = lastSelectedTheme;
            if (lastSelectedTheme === 'tron') {
                // Don't decide yet based on auth = false (not hydrated). Defer applying.
                this.pendingThemeApply = 'tron';
            }
        } else {
            this.currentTheme = 'lofi'; // Only default when nothing saved
        }
        
            // Clear any saved immersive theme for guests
        if (!this.isAuthenticated) {
            this.currentImmersiveTheme = 'none';
        }
        this.overlayOpacity = parseFloat(localStorage.getItem('themeOverlayOpacity')) || 0.20;
        
        // Apply theme now only if not deferring Tron until auth hydration
        if (this.pendingThemeApply !== 'tron') {
            this.applyTheme(this.currentTheme);
        }
        
        this.applyOverlay(this.overlayOpacity);
        
        // Initialize tasks for each focus session
        this.initializeSessionTasks();
        
        // Add click handler to open task modal
        if (this.currentTaskElement) {
            this.currentTaskElement.style.cursor = 'pointer';
            this.currentTaskElement.addEventListener('click', () => {
                this.toggleTaskList();
            });
        }
        
        // Add click handler to task name display to toggle task panel
        if (this.taskNameDisplay) {
            this.taskNameDisplay.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                try {
                    // Check if we're on mobile/tablet (< 1200px)
                    if (window.innerWidth < 1200) {
                        // Use bottom sheet on mobile
                        if (window.sidebarManager && typeof window.sidebarManager.openPanel === 'function') {
                            window.sidebarManager.openPanel('tasks');
                        }
                    } else {
                        // Use sidebar panel on desktop
                        const taskPanel = document.getElementById('taskSidePanel');
                        
                        if (taskPanel && taskPanel.classList.contains('open')) {
                            // Panel is open, close it
                            if (window.sidebarManager && typeof window.sidebarManager.closeTaskPanel === 'function') {
                                // Track task panel close in Mixpanel
                                if (window.mixpanelTracker) {
                                    window.mixpanelTracker.track('Task Panel Closed', {
                                        trigger: 'task_name_display_button',
                                        timestamp: new Date().toISOString()
                                    });
                                }
                                window.sidebarManager.closeTaskPanel();
                            }
                        } else {
                            // Panel is closed, open it
                            if (window.sidebarManager && typeof window.sidebarManager.openTaskPanel === 'function') {
                                // Track task panel open in Mixpanel
                                if (window.mixpanelTracker) {
                                    window.mixpanelTracker.track('Task Panel Opened', {
                                        trigger: 'task_name_display_button',
                                        timestamp: new Date().toISOString()
                                    });
                                }
                                window.sidebarManager.openTaskPanel();
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error toggling task panel:', error);
                }
            });
        }
        
        // Load custom timer labels if it exists (do not auto-select here)
        this.loadSavedCustomTimer();


        // Try to apply saved technique (will re-run after auth hydrates)
        this.applySavedTechniqueOnce();
        
        // For guest users, ensure Pomodoro is selected by default in UI
        if (!this.isAuthenticated) {
            this.setDefaultTechniqueForGuest();
        }
        
        // Enable Custom section for all users (functionality varies by user type)
        this.enableCustomSection();
        
        // Welcome modal removed
        
        // Pomodoro intro modal removed
        
        // Additional check when page is fully loaded
        if (document.readyState === 'complete') {
            setTimeout(() => this.checkAuthState(), 2000);
        } else {
            window.addEventListener('load', () => {
                setTimeout(() => this.checkAuthState(), 2000);
            });
        }
        
        // Ensure logout button is properly bound after DOM is fully loaded
        window.addEventListener('load', () => {
            this.ensureLogoutButtonBinding();
        });

        // Build task queue at startup
        this.rebuildTaskQueue();

        // Update task button state on startup
        this.updateTaskButtonState();

        // Ensure badge shows current total focus time immediately
        this.updateFocusHoursDisplay();

        // Try to load saved timer state (must be last to ensure all UI is ready)
        // Uses sessionStorage so state persists on reload/navigation but not when closing tab
        setTimeout(() => {
            this.loadTimerState();
        }, 500);
    }

    // Clerk Authentication Methods
    getClerkPublishableKey() {
        // Detect if we're in a preview/staging environment
        const hostname = window.location.hostname;
        const isProduction = hostname === 'www.superfocus.live' || hostname === 'superfocus.live';
        const isPreview = hostname.includes('vercel.app') && !isProduction;
        const isLocalhost = hostname === 'localhost' || hostname === '127.0.0.1';
        
        // Production key
        const productionKey = 'pk_live_Y2xlcmsuc3VwZXJmb2N1cy5saXZlJA';
        
        // Test/Development key from Clerk Dashboard
        const testKey = 'pk_test_c2V0LW1pbmstNi5jbGVyay5hY2NvdW50cy5kZXYk';
        
        if (isProduction) {
            console.log('üîê Using Clerk PRODUCTION key');
            return productionKey;
        } else if (isPreview || isLocalhost) {
            console.log('üîê Using Clerk TEST key (preview/staging environment detected)');
            return testKey;
        } else {
            // Default to production for unknown environments
            console.log('üîê Using Clerk PRODUCTION key (default)');
            return productionKey;
        }
    }

    async initClerk() {
        try {
            console.log('Initializing Clerk...');
            await this.waitForClerk();
            console.log('Clerk SDK available, checking session...');
            
            // Wait for global Clerk initialization to complete
            let attempts = 0;
            while (window.__clerkInitializing && attempts < 50) {
                console.log('‚è≥ Waiting for global Clerk initialization...');
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            // Check if Clerk is already initialized globally
            if (window.__clerkInitialized) {
                console.log('‚úÖ Clerk already initialized globally, using existing session');
                // Just use the existing session
                this.isAuthenticated = !!window.Clerk.user;
                this.user = window.Clerk.user;
                console.log('Using existing auth state:', { isAuthenticated: this.isAuthenticated, user: this.user });
            } else if (window.Clerk.loaded) {
                console.log('‚úÖ Clerk already loaded with session, skipping re-initialization');
                // Just use the existing session
                this.isAuthenticated = !!window.Clerk.user;
                this.user = window.Clerk.user;
                console.log('Using existing auth state:', { isAuthenticated: this.isAuthenticated, user: this.user });
                window.__clerkInitialized = true;
            } else {
                // Only load if not already loaded
                const clerkKey = this.getClerkPublishableKey();
                
                console.log('Loading Clerk for the first time...');
                window.__clerkInitializing = true;
                
                // Load Clerk with configuration to hide development banner
                await window.Clerk.load({
                    appearance: {
                        elements: {
                            '::before': { content: 'none' }
                        }
                    },
                    publishableKey: clerkKey,
                    isSatellite: false, // Ensure sessions persist across page navigations
                    sessionTokenRefresh: true // Keep sessions active for longer periods
                });
                
                window.__clerkInitialized = true;
                window.__clerkInitializing = false;
                
                // Hydrate initial auth state
                this.isAuthenticated = !!window.Clerk.user;
                this.user = window.Clerk.user;
                console.log('Initial auth state:', { isAuthenticated: this.isAuthenticated, user: this.user });
            }
            
            // Local tasks only - no integration cleanup needed

            // If coming from a Clerk redirect, remove Clerk params from URL
            this.stripClerkParamsFromUrl();

            // Poll briefly to ensure user is hydrated after redirect
            await this.waitForUserHydration(3000);
            
            // Listen for auth state changes where supported
            try {
                window.Clerk.addListener('user', (user) => {
                    console.log('Auth state changed:', user);
                    this.isAuthenticated = !!user;
                    this.user = user;
                    this.updateAuthState();
                });
            } catch (_) {}
            
            // Also listen for session changes
            try {
                window.Clerk.addListener('session', (session) => {
                    console.log('Session changed:', session);
                    this.isAuthenticated = !!session;
                    this.user = window.Clerk.user;
                    this.updateAuthState();
                });
            } catch (_) {}
            
            // Listen for auth state changes after redirect
            try {
                window.Clerk.addListener('auth', (auth) => {
                    console.log('Auth state changed:', auth);
                    this.isAuthenticated = !!auth.user;
                    this.user = auth.user;
                    this.updateAuthState();
                });
            } catch (_) {}
            
            // Wait a bit more for Clerk to fully hydrate before updating UI
            setTimeout(() => {
                this.checkAuthState(); // Check first
                this.updateAuthState(); // Then update UI
                // Auth may have hydrated; attempt to apply saved technique now
                this.applySavedTechniqueOnce();
            }, 500);
            
            // Force check auth state after a short delay to catch post-redirect state
            // This is especially important after signup/login redirects
            setTimeout(() => {
                this.checkAuthState();
                this.updateAuthState();
            }, 1000);
            
            // Additional check after longer delay to ensure UI updates
            // This catches cases where Clerk takes longer to hydrate
            setTimeout(() => {
                this.checkAuthState();
                this.updateAuthState();
            }, 3000);

            // Mark auth system as ready and re-run UI gates that depend on it
            this.authReady = true;
            // Ensure techniques reflect correct state (guest vs free vs pro)
            try { this.updateDropdownItemsState(); } catch (_) {}
            // Removed extra welcome modal trigger to avoid duplicate rendering
            
            // Session keepalive with safe method
            this.startSessionKeepalive();
            
            // Add visibility change handler to refresh session when user returns
            this.setupVisibilityHandler();
        } catch (error) {
            console.error('Clerk initialization failed:', error);
        }
    }
    
    // Safe session keepalive that checks auth state periodically
    startSessionKeepalive() {
        // Check session every 5 minutes
        setInterval(async () => {
            try {
                if (window.Clerk && window.Clerk.user) {
                    // User is still logged in according to Clerk
                    console.log('üîÑ Session keepalive check: user is authenticated');
                    
                    // Try to get fresh token to keep session alive
                    if (window.Clerk.session) {
                        try {
                            await window.Clerk.session.getToken();
                            console.log('‚úÖ Session token refreshed');
                        } catch (tokenError) {
                            console.warn('‚ö†Ô∏è Could not refresh token, session may have expired');
                            this.handlePossibleLogout();
                        }
                    }
                } else if (this.isAuthenticated) {
                    // We think user is authenticated but Clerk disagrees
                    console.warn('‚ö†Ô∏è Session may have expired, updating UI...');
                    this.handlePossibleLogout();
                }
            } catch (error) {
                console.error('‚ùå Error in session keepalive:', error);
            }
        }, 5 * 60 * 1000); // 5 minutes
    }
    
    // Handle when user returns to the tab
    setupVisibilityHandler() {
        document.addEventListener('visibilitychange', async () => {
            if (!document.hidden) {
                console.log('üîÑ Page visible again, checking session...');
                
                try {
                    // Give Clerk a moment to hydrate
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    if (window.Clerk && window.Clerk.user) {
                        // User is still logged in
                        console.log('‚úÖ Session still active');
                        
                        // Refresh token if possible
                        if (window.Clerk.session) {
                            try {
                                await window.Clerk.session.getToken();
                            } catch (_) {}
                        }
                        
                        // Update UI if needed
                        if (!this.isAuthenticated) {
                            this.isAuthenticated = true;
                            this.user = window.Clerk.user;
                            this.updateAuthState();
                        }
                    } else if (this.isAuthenticated) {
                        // We thought user was logged in but they're not
                        console.warn('‚ö†Ô∏è User session expired while away');
                        this.handlePossibleLogout();
                    }
                } catch (error) {
                    console.error('‚ùå Error checking session on visibility change:', error);
                }
            }
        });
    }
    
    // Handle when session might have expired
    handlePossibleLogout() {
        console.log('üîÑ Handling possible logout...');
        
        // Show expired indicator (red dot) before updating state
        const authIndicator = document.getElementById('authStatusIndicator');
        if (authIndicator) {
            authIndicator.classList.add('expired');
            authIndicator.title = 'Session expired - click to log in';
        }
        
        // Show a notification to the user
        this.showSessionExpiredNotification();
        
        // Update internal state
        this.isAuthenticated = false;
        this.user = null;
        this.isPro = false;
        
        // Update UI
        this.updateAuthState();
    }
    
    // Show notification when session expires
    showSessionExpiredNotification() {
        // Create a notification element if it doesn't exist
        let notification = document.getElementById('sessionExpiredNotification');
        
        if (!notification) {
            notification = document.createElement('div');
            notification.id = 'sessionExpiredNotification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #ff6b6b 0%, #ee5a5a 100%);
                color: white;
                padding: 12px 24px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                display: flex;
                align-items: center;
                gap: 12px;
                animation: slideDown 0.3s ease;
            `;
            notification.innerHTML = `
                <span>‚ö†Ô∏è Your session has expired. Please log in again.</span>
                <button id="sessionExpiredLoginBtn" style="
                    background: white;
                    color: #ee5a5a;
                    border: none;
                    padding: 6px 12px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-weight: 600;
                    font-size: 12px;
                ">Log In</button>
                <button id="sessionExpiredCloseBtn" style="
                    background: transparent;
                    color: white;
                    border: none;
                    cursor: pointer;
                    font-size: 18px;
                    padding: 0 4px;
                ">√ó</button>
            `;
            
            document.body.appendChild(notification);
            
            // Add click handlers
            document.getElementById('sessionExpiredLoginBtn')?.addEventListener('click', () => {
                notification.remove();
                if (window.Clerk && window.Clerk.openSignIn) {
                    window.Clerk.openSignIn();
                }
            });
            
            document.getElementById('sessionExpiredCloseBtn')?.addEventListener('click', () => {
                notification.remove();
            });
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.remove();
                }
            }, 10000);
        }
    }

    // Remove any Clerk-specific query params from URL to avoid sticky auth state
    stripClerkParamsFromUrl() {
        try {
            const url = new URL(window.location.href);
            const params = url.searchParams;
            let changed = false;
            // Remove any param that starts with __clerk_
            [...params.keys()].forEach((key) => {
                if (key.startsWith('__clerk_')) {
                    params.delete(key);
                    changed = true;
                }
            });
            if (changed) {
                window.history.replaceState({}, '', `${url.pathname}${params.toString() ? `?${params.toString()}` : ''}${url.hash}`);
            }
        } catch (_) { /* ignore */ }
    }

    removeUrlParams(keys = []) {
        try {
            if (!Array.isArray(keys) || keys.length === 0) return;
            const url = new URL(window.location.href);
            let changed = false;
            keys.forEach((key) => {
                if (url.searchParams.has(key)) {
                    url.searchParams.delete(key);
                    changed = true;
                }
            });
            if (changed) {
                const newSearch = url.searchParams.toString();
                const newUrl = `${url.pathname}${newSearch ? `?${newSearch}` : ''}${url.hash}`;
                window.history.replaceState({}, '', newUrl);
            }
        } catch (error) {
            console.warn('Failed to remove URL params:', error);
        }
    }
    
    checkAuthState() {
        try {
            if (window.Clerk) {
                const currentUser = window.Clerk.user;
                const currentSession = window.Clerk.session;
                
                // Check if user exists in Clerk
                if (currentUser || currentSession) {
                    const wasAuthenticated = this.isAuthenticated;
                    this.isAuthenticated = true;
                    this.user = currentUser || (currentSession ? window.Clerk.user : null);
                    
                    // Always update UI if state changed or if we just signed up
                    if (!wasAuthenticated || !this.user) {
                        console.log('Auth state verified - user authenticated:', { user: currentUser, session: currentSession });
                        this.updateAuthState();
                    }
                } else {
                    // Only update to unauthenticated if we're sure there's no user
                    // This prevents showing login modal when user is actually authenticated
                    if (this.isAuthenticated) {
                        // Double-check: wait a bit and check again before marking as unauthenticated
                        // This handles cases where Clerk hasn't hydrated yet after redirect
                        setTimeout(() => {
                            if (window.Clerk && !window.Clerk.user && !window.Clerk.session) {
                                this.isAuthenticated = false;
                                this.user = null;
                                this.updateAuthState();
                                console.log('No authenticated user found after double-check');
                            }
                        }, 500);
                    }
                }
            }
        } catch (error) {
            console.log('Auth state check failed:', error);
        }
    }

    async waitForUserHydration(timeoutMs) {
        const start = Date.now();
        while (Date.now() - start < timeoutMs) {
            if (window.Clerk && window.Clerk.user) {
                this.user = window.Clerk.user;
                this.isAuthenticated = true;
                return;
            }
            await new Promise(r => setTimeout(r, 200));
        }
    }
    
    async waitForClerk() {
        return new Promise((resolve) => {
            if (window.Clerk) {
                resolve();
                return;
            }
            
            const checkClerk = () => {
                if (window.Clerk) {
                    resolve();
                } else {
                    setTimeout(checkClerk, 100);
                }
            };
            
            checkClerk();
        });
    }
    
    debugAuthState() {
        try {
            console.log('üîç Auth Debug Info:');
            console.log('- isAuthenticated:', this.isAuthenticated);
            console.log('- user:', this.user);
            console.log('- Clerk exists:', !!window.Clerk);
            console.log('- Clerk.user:', window.Clerk?.user);
            console.log('- Clerk.session:', window.Clerk?.session);
            console.log('- localStorage hasAccount:', localStorage.getItem('hasAccount'));
            console.log('- sessionStorage just_logged_out:', sessionStorage.getItem('just_logged_out'));
            
            // Check for multiple account issues
            if (window.Clerk?.user && !this.isAuthenticated) {
                console.warn('‚ö†Ô∏è Potential multiple account issue: Clerk has user but app shows not authenticated');
                console.log('Attempting to sync auth state...');
                this.isAuthenticated = true;
                this.user = window.Clerk.user;
            }
            
            // Check for session conflicts
            if (this.isAuthenticated && !window.Clerk?.user) {
                console.warn('‚ö†Ô∏è Session conflict: App shows authenticated but Clerk has no user');
                console.log('Clearing auth state...');
                this.isAuthenticated = false;
                this.user = null;
            }
            
            // Check for button/panel functionality issues
            this.debugPanelFunctionality();
            
        } catch (error) {
            console.error('Debug auth state error:', error);
        }
    }
    
    debugPanelFunctionality() {
        try {
            console.log('üîß Panel Functionality Debug:');
            
            // Check if panels are properly initialized
            const taskPanel = document.getElementById('taskSidePanel');
            const timerPanel = document.getElementById('settingsSidePanel');
            const musicPanel = document.getElementById('musicSidePanel');
            
            console.log('- Task Panel exists:', !!taskPanel);
            console.log('- Timer Panel exists:', !!timerPanel);
            console.log('- Music Panel exists:', !!musicPanel);
            
            // Check if event listeners are working
            if (taskPanel) {
                const taskButtons = taskPanel.querySelectorAll('button');
                console.log('- Task Panel buttons:', taskButtons.length);
            }
            
            if (timerPanel) {
                const timerButtons = timerPanel.querySelectorAll('button');
                console.log('- Timer Panel buttons:', timerButtons.length);
            }
            
            if (musicPanel) {
                const musicButtons = musicPanel.querySelectorAll('button');
                console.log('- Music Panel buttons:', musicButtons.length);
            }
            
            // Check for disabled states
            const disabledButtons = document.querySelectorAll('button[disabled]');
            console.log('- Disabled buttons:', disabledButtons.length);
            
            // Check for opacity issues
            const lowOpacityElements = document.querySelectorAll('[style*="opacity: 0.5"]');
            console.log('- Low opacity elements:', lowOpacityElements.length);
            
            // Check for pointer-events issues
            const noPointerElements = document.querySelectorAll('[style*="pointer-events: none"]');
            console.log('- No pointer events elements:', noPointerElements.length);
            
        } catch (error) {
            console.error('Debug panel functionality error:', error);
        }
    }
    
    // Force clear all auth state to resolve multiple account issues
    forceClearAuthState() {
        try {
            console.log('üßπ Force clearing all auth state...');
            
            // Clear app state
            this.isAuthenticated = false;
            this.user = null;
            this.isPro = false;
            
            // Clear localStorage
            localStorage.removeItem('hasAccount');
            localStorage.removeItem('selectedImmersiveTheme');
            localStorage.removeItem('lastSelectedTheme');
            
            // Clear sessionStorage
            sessionStorage.removeItem('just_logged_out');
            
            // Clear Clerk state if possible
            if (window.Clerk && window.Clerk.signOut) {
                try {
                    window.Clerk.signOut();
                } catch (e) {
                    console.log('Could not sign out from Clerk:', e);
                }
            }
            
            // Local tasks only - no integration cleanup needed
            
            // Update UI
            this.updateAuthState();
            
            console.log('‚úÖ Auth state cleared successfully');
            
            // Make function available globally for debugging
            window.debugAuth = () => this.debugAuthState();
            window.clearAuth = () => this.forceClearAuthState();
            window.fixPanels = () => this.forceReinitializePanels();
            console.log('üîß Debug functions available: window.debugAuth(), window.clearAuth(), window.fixPanels()');
            
        } catch (error) {
            console.error('Error clearing auth state:', error);
        }
    }
    
    // Force reinitialize panels to fix button/action issues
    forceReinitializePanels() {
        try {
            console.log('üîß Force reinitializing panels...');
            
            // Re-setup Timer panel
            const timerPanel = document.getElementById('settingsSidePanel');
            if (timerPanel) {
                console.log('Re-setting up Timer panel...');
                this.setupTimerSidebar();
            }
            
            // Re-setup Task panel
            const taskPanel = document.getElementById('taskSidePanel');
            if (taskPanel) {
                console.log('Re-setting up Task panel...');
                this.setupTaskSidebar();
            }
            
            // Re-setup Music panel
            const musicPanel = document.getElementById('musicSidePanel');
            if (musicPanel) {
                console.log('Re-setting up Music panel...');
                this.setupMusicSidebar();
            }
            
            // Force update auth state
            this.updateAuthState();
            
            console.log('‚úÖ Panels reinitialized successfully');
            
        } catch (error) {
            console.error('Error reinitializing panels:', error);
        }
    }
    
    // Auto-fix common panel issues for authenticated users
    autoFixPanelIssues() {
        try {
            console.log('üîß Auto-fixing panel issues...');
            
            // Fix disabled buttons in panels
            const panels = ['taskSidePanel', 'settingsSidePanel', 'musicSidePanel'];
            panels.forEach(panelId => {
                const panel = document.getElementById(panelId);
                if (panel) {
                    const buttons = panel.querySelectorAll('button');
                    buttons.forEach(button => {
                        if (button.disabled && this.isAuthenticated) {
                            console.log(`Enabling disabled button in ${panelId}:`, button.textContent);
                            button.disabled = false;
                            button.style.opacity = '1';
                            button.style.cursor = 'pointer';
                        }
                    });
                }
            });
            
            // Fix low opacity elements
            const lowOpacityElements = document.querySelectorAll('[style*="opacity: 0.5"]');
            lowOpacityElements.forEach(element => {
                if (this.isAuthenticated) {
                    console.log('Fixing low opacity element:', element);
                    element.style.opacity = '1';
                    element.style.pointerEvents = 'auto';
                    element.style.cursor = 'auto';
                }
            });
            
            // Fix pointer-events: none elements
            const noPointerElements = document.querySelectorAll('[style*="pointer-events: none"]');
            noPointerElements.forEach(element => {
                if (this.isAuthenticated) {
                    console.log('Fixing no pointer events element:', element);
                    element.style.pointerEvents = 'auto';
                }
            });
            
            console.log('‚úÖ Panel issues auto-fixed');
            
        } catch (error) {
            console.error('Error auto-fixing panel issues:', error);
        }
    }
    
    // Enable Timer panel features for authenticated users
    enableTimerPanelFeatures() {
        try {
            console.log('üîì Enabling Timer panel features for authenticated user');
            
            // Enable sessions card
            const sessionsSlider = document.querySelector('#sidebarSessionsSlider');
            const sessionsValue = document.querySelector('#sidebarSessionsValue');
            const sessionsCard = sessionsSlider?.closest('.duration-item');
            
            if (sessionsSlider && sessionsValue && sessionsCard) {
                sessionsCard.style.opacity = '1';
                sessionsCard.style.pointerEvents = 'auto';
                sessionsCard.style.cursor = 'auto';
                sessionsValue.value = this.sessionsPerCycle;
            }
            
            // Enable Long Break card
            const longBreakSlider = document.querySelector('#sidebarLongBreakSlider');
            const longBreakCard = longBreakSlider?.closest('.duration-item');
            
            if (longBreakSlider && longBreakCard) {
                longBreakCard.style.opacity = '1';
                longBreakCard.style.pointerEvents = 'auto';
                longBreakCard.style.cursor = 'auto';
            }
            
            // Enable advanced techniques
            const techniquePresets = document.querySelectorAll('.technique-preset');
            techniquePresets.forEach(preset => {
                const technique = preset.dataset.technique;
                if (technique !== 'pomodoro') {
                    preset.style.opacity = '1';
                    preset.style.cursor = 'pointer';
                    preset.style.pointerEvents = 'auto';
                    
                    // Hide "(Sign up required)" text
                    const signupText = preset.querySelector('.signup-required-text');
                    if (signupText) {
                        signupText.classList.add('hidden');
                    }
                }
            });
            
            // Hide "(Sign up required)" text from sessions and long break labels
            const sessionsSignupText = document.querySelector('#sidebarSessionsSlider')?.closest('.duration-item')?.querySelector('.signup-required-text');
            if (sessionsSignupText) {
                sessionsSignupText.classList.add('hidden');
            }
            
            const longBreakSignupText = document.querySelector('#sidebarLongBreakSlider')?.closest('.duration-item')?.querySelector('.signup-required-text');
            if (longBreakSignupText) {
                longBreakSignupText.classList.add('hidden');
            }
            
            // Initialize save button as disabled (will be enabled when changes are made)
            const saveBtn = document.querySelector('#sidebarSaveSettings');
            if (saveBtn) {
                saveBtn.disabled = true;
            }
            
            // Enable Custom section for Pro users
            this.enableCustomSection();
            
            console.log('‚úÖ Timer panel features enabled');
            
        } catch (error) {
            console.error('Error enabling Timer panel features:', error);
        }
    }

    enableSaveButton() {
        const saveBtn = document.querySelector('#sidebarSaveSettings');
        if (saveBtn) {
            saveBtn.disabled = false;
        }
    }

    resetSaveButton() {
        const saveBtn = document.querySelector('#sidebarSaveSettings');
        if (saveBtn) {
            saveBtn.disabled = true;
        }
    }
    
    // Enable Custom section for Pro users
    enableCustomSection() {
        try {
            console.log('üîì Enabling Custom section for all users');
            
            const customSection = document.getElementById('customSection');
            if (customSection) {
                customSection.style.display = 'block';
                console.log('‚úÖ Custom section displayed');
                
                // Set up basic listeners for all users
                this.setupBasicCustomListeners();
                console.log('‚úÖ Basic custom listeners set up');
                
                // Initialize full functionality for all authenticated users (Free and Pro)
                // Free users can create 1 timer, Pro users can create unlimited
                if (this.isAuthenticated && this.user) {
                    console.log('‚úÖ User is authenticated, initializing full custom functionality');
                    this.initializeCustomSection();
                } else {
                    console.log('‚ÑπÔ∏è User is not authenticated, basic custom functionality only');
                }
            } else {
                console.log('‚ùå Custom section not found');
            }
            
        } catch (error) {
            console.error('Error enabling Custom section:', error);
        }
    }
    
    // Initialize Custom section functionality
    initializeCustomSection() {
        try {
            // Prevent multiple initializations
            if (this.customSectionInitialized) {
                console.log('‚ö†Ô∏è Custom section already initialized, skipping...');
                return;
            }
            
            // Load existing custom techniques from localStorage
            this.loadCustomTechniques();
            
            // Set up event listeners
            this.setupCustomSectionListeners();
            
            // Mark as initialized
            this.customSectionInitialized = true;
            
            console.log('‚úÖ Custom section initialized');
            
        } catch (error) {
            console.error('Error initializing Custom section:', error);
        }
    }
    
    // Set up basic event listeners for all users (Create Custom button)
    setupBasicCustomListeners() {
        console.log('üîß Setting up basic custom listeners');
        // Create Custom button - works for all users
        const createBtn = document.getElementById('createCustomBtn');
        console.log('üîß Create button found:', !!createBtn);
        console.log('üîß Button already has listener:', createBtn?.hasAttribute('data-listener-added'));
        
        if (createBtn && !createBtn.hasAttribute('data-listener-added')) {
            console.log('‚úÖ Adding click listener to create button');
            createBtn.addEventListener('click', () => {
                console.log('üñ±Ô∏è Create Custom button clicked!');
                // Track Create Custom button click
                this.trackEvent('Create Custom Button Clicked', {
                    button_type: 'create_custom',
                    source: 'timer_panel',
                    user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                    feature_access: this.isPremiumUser() ? 'allowed' : 'restricted'
                });
                
                this.showCustomForm();
            });
            createBtn.setAttribute('data-listener-added', 'true');
            console.log('‚úÖ Click listener added and marked');
        } else {
            console.log('‚ö†Ô∏è Could not add listener - button not found or already has listener');
        }
    }
    
    // Set up event listeners for Custom section
    setupCustomSectionListeners() {
        // Create Custom button
        const createBtn = document.getElementById('createCustomBtn');
        if (createBtn && !createBtn.hasAttribute('data-listener-added')) {
            createBtn.addEventListener('click', () => this.showCustomForm());
            createBtn.setAttribute('data-listener-added', 'true');
        }
        
        // Cancel button
        const cancelBtn = document.getElementById('cancelCustomBtn');
        if (cancelBtn && !cancelBtn.hasAttribute('data-listener-added')) {
            cancelBtn.addEventListener('click', () => this.hideCustomForm());
            cancelBtn.setAttribute('data-listener-added', 'true');
        }
        
        // Save button
        const saveBtn = document.getElementById('saveCustomBtn');
        if (saveBtn && !saveBtn.hasAttribute('data-listener-added')) {
            saveBtn.addEventListener('click', () => this.saveCustomTechnique());
            saveBtn.setAttribute('data-listener-added', 'true');
        }
        
        // Emoji picker
        const emojiOptions = document.querySelectorAll('.emoji-option');
        emojiOptions.forEach(option => {
            option.addEventListener('click', () => {
                // Remove active class from all options
                emojiOptions.forEach(opt => opt.classList.remove('active'));
                // Add active class to clicked option
                option.classList.add('active');
            });
        });
        
        // Custom work slider
        const workSlider = document.getElementById('customWorkSlider');
        const workValue = document.getElementById('customWorkValue');
        if (workSlider && workValue) {
            workSlider.addEventListener('input', (e) => {
                const minutes = parseInt(e.target.value);
                workValue.value = minutes;
            });
        }
        
        // Custom short break slider
        const shortBreakSlider = document.getElementById('customShortBreakSlider');
        const shortBreakValue = document.getElementById('customShortBreakValue');
        if (shortBreakSlider && shortBreakValue) {
            shortBreakSlider.addEventListener('input', (e) => {
                const minutes = parseInt(e.target.value);
                shortBreakValue.value = minutes;
            });
        }
        
        // Custom long break slider
        const longBreakSlider = document.getElementById('customLongBreakSlider');
        const longBreakValue = document.getElementById('customLongBreakValue');
        if (longBreakSlider && longBreakValue) {
            longBreakSlider.addEventListener('input', (e) => {
                const minutes = parseInt(e.target.value);
                longBreakValue.value = minutes;
            });
        }
        
        // Custom sessions slider
        const sessionsSlider = document.getElementById('customSessionsSlider');
        const sessionsValue = document.getElementById('customSessionsValue');
        if (sessionsSlider && sessionsValue) {
            sessionsSlider.addEventListener('input', (e) => {
                const sessions = parseInt(e.target.value);
                sessionsValue.value = sessions;
            });
        }
        
        // Custom name input validation with word count
        const nameInput = document.getElementById('customName');
        const wordCount = document.getElementById('wordCount');
        if (nameInput && wordCount) {
            nameInput.addEventListener('input', () => {
                this.validateCustomForm();
                this.updateWordCount();
            });
        }
    }
    
    // Helper function to count custom timers
    getCustomTimersCount() {
        try {
            const techniques = JSON.parse(localStorage.getItem('customTechniques') || '[]');
            return techniques.length;
        } catch (error) {
            console.error('Error counting custom timers:', error);
            return 0;
        }
    }
    
    // Get lifetime count of timers created (persists even after deletion)
    getLifetimeTimersCreated() {
        try {
            return parseInt(localStorage.getItem('lifetimeTimersCreated') || '0', 10);
        } catch (error) {
            console.error('Error getting lifetime timers count:', error);
            return 0;
        }
    }
    
    // Increment lifetime timer creation count
    incrementLifetimeTimersCreated() {
        try {
            const current = this.getLifetimeTimersCreated();
            localStorage.setItem('lifetimeTimersCreated', String(current + 1));
            console.log('üìä Lifetime timers created:', current + 1);
        } catch (error) {
            console.error('Error incrementing lifetime timers count:', error);
        }
    }
    
    // Get lifetime count of cassettes created (persists even after deletion)
    getLifetimeCassettesCreated() {
        try {
            return parseInt(localStorage.getItem('lifetimeCassettesCreated') || '0', 10);
        } catch (error) {
            console.error('Error getting lifetime cassettes count:', error);
            return 0;
        }
    }
    
    // Increment lifetime cassette creation count
    incrementLifetimeCassettesCreated() {
        try {
            const current = this.getLifetimeCassettesCreated();
            localStorage.setItem('lifetimeCassettesCreated', String(current + 1));
            console.log('üìä Lifetime cassettes created:', current + 1);
        } catch (error) {
            console.error('Error incrementing lifetime cassettes count:', error);
        }
    }

    // Show custom form
    showCustomForm() {
        // Check if user is Pro
        if (this.isPremiumUser()) {
            // Pro users can create unlimited custom timers
            const form = document.getElementById('customForm');
            const createBtn = document.getElementById('createCustomBtn');
            
            if (form && createBtn) {
                form.style.display = 'block';
                createBtn.style.display = 'none';
                
                // Setup editable duration inputs
                this.setupEditableDurationInputs(form);
                
                // Focus on name input
                const nameInput = document.getElementById('customName');
                if (nameInput) {
                    setTimeout(() => nameInput.focus(), 100);
                }
                
                // Reset form and validate to ensure proper state
                this.resetCustomForm();
            }
        } else if (this.isAuthenticated && this.user) {
            // Free users - check lifetime count of custom timers (permanent limit)
            const lifetimeTimersCreated = this.getLifetimeTimersCreated();
            
            if (lifetimeTimersCreated >= 1) {
                // Free user has already created 1 custom timer in their lifetime
                this.trackEvent('Pro Feature Modal Shown', {
                    feature: 'custom_techniques',
                    source: 'create_custom_button',
                    user_type: 'free',
                    modal_type: 'upgrade_prompt',
                    lifetime_timers_created: lifetimeTimersCreated,
                    limit_reached: true,
                    reason: 'permanent_timer_limit_reached'
                });
                
                this.showCustomTechniqueProModal('Free users can only create 1 custom timer permanently. Once deleted, you cannot create another. Upgrade to Premium for unlimited timers.', lifetimeTimersCreated);
            } else {
                // Free user can create their first timer
                const form = document.getElementById('customForm');
                const createBtn = document.getElementById('createCustomBtn');
                
                if (form && createBtn) {
                    form.style.display = 'block';
                    createBtn.style.display = 'none';
                    
                    // Setup editable duration inputs
                    this.setupEditableDurationInputs(form);
                    
                    // Focus on name input
                    const nameInput = document.getElementById('customName');
                    if (nameInput) {
                        setTimeout(() => nameInput.focus(), 100);
                    }
                    
                    // Reset form and validate to ensure proper state
                    this.resetCustomForm();
                }
            }
        } else {
            // Guest users - show Pro Feature modal
            this.trackEvent('Pro Feature Modal Shown', {
                feature: 'custom_techniques',
                source: 'create_custom_button',
                user_type: 'guest',
                modal_type: 'upgrade_prompt'
            });
            
            // Show Pro Feature modal for Guest users
            this.showCustomTechniqueProModal();
        }
    }
    
    // Show Pro Feature modal for Custom Techniques
    showCustomTechniqueProModal(customMessage = null, customTimersCount = 0) {
        if (!this.isAuthenticated) {
            // Guest user - show modal with Sign up CTA
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'logout-modal-overlay';
            modalOverlay.style.display = 'flex';
            
            const modal = document.createElement('div');
            modal.className = 'logout-modal';
            
            const guestMessage = 'Create personalized focus timers tailored to your workflow! Set custom work periods, break times, and session cycles that match your productivity style.';
            
            modal.innerHTML = `
                <button class="close-logout-modal-x" id="closeCustomModal">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18"/><path d="m6 6 12 12"/>
                    </svg>
                </button>
                <div class="upgrade-content">
                    <div class="upgrade-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"/>
                            <polyline points="12,6 12,12 16,14"/>
                        </svg>
                    </div>
                    <h3>Build your perfect timer</h3>
                    <p>${guestMessage}</p>
                    <div class="logout-modal-buttons">
                        <button class="logout-modal-btn logout-modal-btn-primary" id="customSignupBtn">Sign up for free</button>
                        <button class="logout-modal-btn logout-modal-btn-secondary" id="customLearnMoreBtn">Cancel</button>
                    </div>
                </div>
            `;
            
            modalOverlay.appendChild(modal);
            document.body.appendChild(modalOverlay);
            
            const closeModal = () => {
                try { document.body.removeChild(modalOverlay); } catch (_) {}
            };
            
            const closeBtn = modal.querySelector('#closeCustomModal');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeModal);
            }
            
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    closeModal();
                }
            });
            
            const cancelBtn = modal.querySelector('#customLearnMoreBtn');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', closeModal);
            }
            
            const signupBtn = modal.querySelector('#customSignupBtn');
            if (signupBtn) {
                signupBtn.addEventListener('click', () => {
                    this.trackEvent('Sign Up Clicked', {
                        modal_type: 'create_timer',
                        button_text: 'Sign up for free',
                        user_type: 'guest',
                        source: 'create_timer_modal'
                    });
                    closeModal();
                    window.location.href = 'https://accounts.superfocus.live/sign-up?redirect_url=https%3A%2F%2Fwww.superfocus.live%2F%3Fsignup%3Dsuccess';
                });
            }
        } else {
            // Free/authenticated user - open pricing modal
            this.showPricingPlansModal();
        }
    }

    // Show Pro Feature modal for Cassettes
    showCassetteLoginModal() {
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'logout-modal-overlay';
        modalOverlay.style.display = 'flex';
        
        const modal = document.createElement('div');
        modal.className = 'logout-modal';
        
        modal.innerHTML = `
            <button class="close-logout-modal-x" id="closeCassetteLoginModal">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/><path d="m6 6 12 12"/>
                </svg>
            </button>
            <div class="upgrade-content">
                <div class="upgrade-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cassette-tape-icon lucide-cassette-tape">
                        <rect width="20" height="16" x="2" y="4" rx="2"/>
                        <circle cx="8" cy="10" r="2"/>
                        <path d="M8 12h8"/>
                        <circle cx="16" cy="10" r="2"/>
                        <path d="m6 20 .7-2.9A1.4 1.4 0 0 1 8.1 16h7.8a1.4 1.4 0 0 1 1.4 1l.7 3"/>
                    </svg>
                </div>
                <h3>Create your focus cassette</h3>
                <p>Create a free account to start building your own custom focus environments. Upload your own images, set the perfect atmosphere, and personalize your workspace.</p>
                <div class="upgrade-required-buttons">
                    <button class="upgrade-btn" id="cassetteLoginSignupBtn">Sign up for free</button>
                    <button class="cancel-btn" id="cassetteLoginCancelBtn">Cancel</button>
                </div>
            </div>
        `;
        
        modalOverlay.appendChild(modal);
        document.body.appendChild(modalOverlay);
        
        // Prevent background scroll while modal open
        const previousOverflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        
        // Close modal function
        const closeModal = () => {
            document.body.style.overflow = previousOverflow;
            try { document.body.removeChild(modalOverlay); } catch (_) {}
        };
        
        // Close button
        const closeBtn = modal.querySelector('#closeCassetteLoginModal');
        if (closeBtn) {
            closeBtn.addEventListener('click', closeModal);
        }
        
        // Close on overlay click
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                closeModal();
            }
        });
        
        // Sign up button
        const signupBtn = modal.querySelector('#cassetteLoginSignupBtn');
        if (signupBtn) {
            signupBtn.addEventListener('click', () => {
                closeModal();
                this.handleSignup();
            });
        }
        
        // Cancel button
        const cancelBtn = modal.querySelector('#cassetteLoginCancelBtn');
        if (cancelBtn) {
            cancelBtn.addEventListener('click', closeModal);
        }
    }

    showCassetteProModal(customMessage = null) {
        if (!this.isAuthenticated) {
            // Guest user - show modal with Sign up CTA
            const modalOverlay = document.createElement('div');
            modalOverlay.className = 'logout-modal-overlay';
            modalOverlay.style.display = 'flex';
            
            const modal = document.createElement('div');
            modal.className = 'logout-modal';
            
            modal.innerHTML = `
                <button class="close-logout-modal-x" id="closeCassetteModal">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18"/><path d="m6 6 12 12"/>
                    </svg>
                </button>
                <div class="upgrade-content">
                    <div class="upgrade-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-cassette-tape-icon lucide-cassette-tape">
                            <rect width="20" height="16" x="2" y="4" rx="2"/>
                            <circle cx="8" cy="10" r="2"/>
                            <path d="M8 12h8"/>
                            <circle cx="16" cy="10" r="2"/>
                            <path d="m6 20 .7-2.9A1.4 1.4 0 0 1 8.1 16h7.8a1.4 1.4 0 0 1 1.4 1l.7 3"/>
                        </svg>
                    </div>
                    <h3>Create your focus cassette</h3>
                    <p>Not everyone focuses the same way. Some need rain, others need silence, and you might need that specific playlist. Build your own sound environment‚Äîthe one that actually helps you get into flow.</p>
                    <div class="logout-modal-buttons">
                        <button class="logout-modal-btn logout-modal-btn-primary" id="cassetteSignupBtn">Sign up for free</button>
                        <button class="logout-modal-btn logout-modal-btn-secondary" id="cassetteLearnMoreBtn">Cancel</button>
                    </div>
                </div>
            `;
            
            modalOverlay.appendChild(modal);
            document.body.appendChild(modalOverlay);
            
            const closeModal = () => {
                try { document.body.removeChild(modalOverlay); } catch (_) {}
            };
            
            const closeBtn = modal.querySelector('#closeCassetteModal');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeModal);
            }
            
            modalOverlay.addEventListener('click', (e) => {
                if (e.target === modalOverlay) {
                    closeModal();
                }
            });
            
            const cancelBtn = modal.querySelector('#cassetteLearnMoreBtn');
            if (cancelBtn) {
                cancelBtn.addEventListener('click', closeModal);
            }
            
            const signupBtn = modal.querySelector('#cassetteSignupBtn');
            if (signupBtn) {
                signupBtn.addEventListener('click', () => {
                    this.trackEvent('Sign Up Clicked', {
                        modal_type: 'create_cassette',
                        button_text: 'Sign up for free',
                        user_type: 'guest',
                        source: 'create_cassette_modal'
                    });
                    closeModal();
                    window.location.href = 'https://accounts.superfocus.live/sign-up?redirect_url=https%3A%2F%2Fwww.superfocus.live%2F%3Fsignup%3Dsuccess';
                });
            }
        } else {
            // Free/authenticated user - open pricing modal
            this.showPricingPlansModal();
        }
    }

    // Hide custom form
    hideCustomForm() {
        const form = document.getElementById('customForm');
        const createBtn = document.getElementById('createCustomBtn');
        
        if (form && createBtn) {
            form.style.display = 'none';
            createBtn.style.display = 'flex';
            
            // Reset form
            this.resetCustomForm();
        }
    }
    
    // Reset custom form
    resetCustomForm() {
        const nameInput = document.getElementById('customName');
        const workValue = document.getElementById('customWorkValue');
        const shortBreakValue = document.getElementById('customShortBreakValue');
        const longBreakValue = document.getElementById('customLongBreakValue');
        const sessionsValue = document.getElementById('customSessionsValue');
        const emojiOptions = document.querySelectorAll('.emoji-option');
        
        // Get sliders to reset them visually
        const workSlider = document.getElementById('customWorkSlider');
        const shortBreakSlider = document.getElementById('customShortBreakSlider');
        const longBreakSlider = document.getElementById('customLongBreakSlider');
        const sessionsSlider = document.getElementById('customSessionsSlider');
        
        if (nameInput) {
            nameInput.value = '';
        }
        
        // Reset text values AND sliders to default positions
        if (workValue) workValue.value = 25;
        if (workSlider) workSlider.value = 25;
        
        if (shortBreakValue) shortBreakValue.value = 5;
        if (shortBreakSlider) shortBreakSlider.value = 5;
        
        if (longBreakValue) longBreakValue.value = 15;
        if (longBreakSlider) longBreakSlider.value = 15;
        
        if (sessionsValue) sessionsValue.value = 4;
        if (sessionsSlider) sessionsSlider.value = 4;
        
        // Reset emoji to default
        emojiOptions.forEach(option => option.classList.remove('active'));
        if (emojiOptions[0]) emojiOptions[0].classList.add('active');
        
        // Clear editing state
        this.editingTechnique = null;
        
        this.updateWordCount();
        this.validateCustomForm();
    }
    
    // Update character count
    updateWordCount() {
        const nameInput = document.getElementById('customName');
        const wordCount = document.getElementById('wordCount');
        
        if (nameInput && wordCount) {
            const characterCount = nameInput.value.length;
            
            wordCount.textContent = `${characterCount}/20 characters`;
            
            // Update styling based on character count
            wordCount.classList.remove('warning', 'error');
            if (characterCount > 20) {
                wordCount.classList.add('error');
            } else if (characterCount > 16) {
                wordCount.classList.add('warning');
            }
        }
    }
    
    // Validate custom form
    validateCustomForm() {
        const nameInput = document.getElementById('customName');
        const saveBtn = document.getElementById('saveCustomBtn');
        
        if (nameInput && saveBtn) {
            saveBtn.disabled = !nameInput.value.trim();
        }
    }
    
    // Save custom technique
    saveCustomTechnique() {
        try {
            const nameInput = document.getElementById('customName');
            const workValue = document.getElementById('customWorkValue');
            const shortBreakValue = document.getElementById('customShortBreakValue');
            const longBreakValue = document.getElementById('customLongBreakValue');
            const sessionsValue = document.getElementById('customSessionsValue');
            const selectedEmoji = document.querySelector('.emoji-option.active');
            
            if (!nameInput || !workValue || !shortBreakValue || !longBreakValue || !sessionsValue) return;
            
            const name = nameInput.value.trim();
            const workMinutes = parseInt(workValue.value);
            const shortBreakMinutes = parseInt(shortBreakValue.value);
            const longBreakMinutes = parseInt(longBreakValue.value);
            const sessions = parseInt(sessionsValue.value);
            const emoji = selectedEmoji ? selectedEmoji.dataset.emoji : 'üéØ';
            
            if (!name) {
                alert('Please enter a name for your technique');
                return;
            }
            
            // Validate character count
            if (name.length > 20) {
                alert('Technique name cannot exceed 20 characters. Please shorten your name.');
                return;
            }
            
            // Check if we're editing an existing technique
            if (this.editingTechnique) {
                // Update existing technique
                this.editingTechnique.name = name;
                this.editingTechnique.workMinutes = workMinutes;
                this.editingTechnique.shortBreakMinutes = shortBreakMinutes;
                this.editingTechnique.longBreakMinutes = longBreakMinutes;
                this.editingTechnique.sessions = sessions;
                this.editingTechnique.updatedAt = new Date().toISOString();
                
                // Update in localStorage
                this.updateCustomTechniqueInStorage(this.editingTechnique);
                
                // Update card in UI
                this.updateCustomTechniqueCard(this.editingTechnique);
                
                console.log('‚úÖ Custom technique updated:', this.editingTechnique.name);
                
                // Clear editing state
                this.editingTechnique = null;
            } else {
                // Create new custom technique object
                const customTechnique = {
                    id: `custom_${Date.now()}`,
                    name: name,
                    emoji: emoji,
                    workMinutes: workMinutes,
                    shortBreakMinutes: shortBreakMinutes,
                    longBreakMinutes: longBreakMinutes,
                    sessions: sessions,
                    createdAt: new Date().toISOString()
                };
                
                // Save to localStorage
                this.saveCustomTechniqueToStorage(customTechnique);
                
                // Increment lifetime creation counter (for free user limits)
                if (!this.isPremiumUser()) {
                    this.incrementLifetimeTimersCreated();
                }
                
                // Add to UI
                this.addCustomTechniqueCard(customTechnique);
                
                // Select and apply the new technique immediately
                this.selectCustomTechnique(customTechnique);
                
                // Track successful custom technique creation
                this.trackEvent('Custom Technique Created', {
                    feature: 'custom_techniques',
                    technique_name: customTechnique.name,
                    work_minutes: customTechnique.workMinutes,
                    short_break_minutes: customTechnique.shortBreakMinutes,
                    long_break_minutes: customTechnique.longBreakMinutes,
                    sessions: customTechnique.sessions,
                    emoji: customTechnique.emoji,
                    user_type: this.isPremiumUser() ? 'pro' : 'free'
                });
                
                console.log('‚úÖ Custom technique saved and applied:', customTechnique.name);
            }
            
            // Hide form
            this.hideCustomForm();
            
        } catch (error) {
            console.error('Error saving custom technique:', error);
        }
    }
    
    // Save custom technique to localStorage and sync to server
    saveCustomTechniqueToStorage(technique) {
        try {
            const existing = JSON.parse(localStorage.getItem('customTechniques') || '[]');
            existing.push(technique);
            localStorage.setItem('customTechniques', JSON.stringify(existing));
            
            // Increment lifetime counter (permanent tracking)
            this.incrementLifetimeTimersCreated();
            
            // Sync to server in background (don't wait)
            this.syncTechniquesToServer();
        } catch (error) {
            console.error('Error saving to localStorage:', error);
        }
    }
    
    // Update custom technique in localStorage and sync to server
    updateCustomTechniqueInStorage(technique) {
        try {
            const existing = JSON.parse(localStorage.getItem('customTechniques') || '[]');
            const index = existing.findIndex(t => t.id === technique.id);
            if (index !== -1) {
                existing[index] = technique;
                localStorage.setItem('customTechniques', JSON.stringify(existing));
                
                // Sync to server in background (don't wait)
                this.syncTechniquesToServer();
            }
        } catch (error) {
            console.error('Error updating in localStorage:', error);
        }
    }
    
    // Sync custom techniques to server
    async syncTechniquesToServer() {
        if (!this.isAuthenticated || !this.user?.id) return;
        
        try {
            const customTechniques = JSON.parse(localStorage.getItem('customTechniques') || '[]');
            const stats = this.getFocusStats();
            
            await fetch('/api/sync-stats', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-clerk-userid': this.user.id
                },
                body: JSON.stringify({ 
                    totalHours: stats?.totalHours || 0,
                    customTechniques: customTechniques
                })
            });
            console.log('üì§ Custom techniques synced to server');
        } catch (error) {
            console.error('Error syncing techniques to server:', error);
        }
    }
    
    // Update custom technique card in UI
    updateCustomTechniqueCard(technique) {
        try {
            const card = document.querySelector(`[data-technique-id="${technique.id}"]`);
            if (card) {
                const nameElement = card.querySelector('.custom-card-name');
                const durationElement = card.querySelector('.custom-card-duration');
                const breakElement = card.querySelector('.custom-card-break');
                const longBreakElement = card.querySelector('.custom-card-long-break');
                const sessionsElement = card.querySelector('.custom-card-sessions');
                
                if (nameElement) nameElement.textContent = technique.name;
                if (durationElement) durationElement.textContent = `${technique.workMinutes}min focus`;
                if (breakElement) breakElement.textContent = `${technique.shortBreakMinutes}min short break`;
                if (longBreakElement) longBreakElement.textContent = `${technique.longBreakMinutes}min long break`;
                if (sessionsElement) sessionsElement.textContent = `${technique.sessions} sessions`;
            }
        } catch (error) {
            console.error('Error updating card in UI:', error);
        }
    }
    
    // Load custom techniques from localStorage
    loadCustomTechniques() {
        try {
            // Clear existing cards first to prevent duplicates
            const container = document.getElementById('customCardsContainer');
            if (container) {
                container.innerHTML = '';
            }
            
            const techniques = JSON.parse(localStorage.getItem('customTechniques') || '[]');
            const selectedTechnique = localStorage.getItem('selectedTechnique');
            
            console.log(`üìã Loading ${techniques.length} custom techniques`);
            
            techniques.forEach(technique => {
                this.addCustomTechniqueCard(technique);
                
                // Mark as active if this is the selected technique
                if (selectedTechnique === `custom_${technique.id}`) {
                    const card = document.querySelector(`[data-technique-id="${technique.id}"]`);
                    if (card) {
                        card.classList.add('active');
                        console.log(`‚úÖ Custom technique '${technique.name}' marked as active`);
                    }
                }
            });
        } catch (error) {
            console.error('Error loading custom techniques:', error);
        }
    }
    
    // Add custom technique card to UI
    addCustomTechniqueCard(technique) {
        const container = document.getElementById('customCardsContainer');
        if (!container) return;
        
        // Check if card already exists to prevent duplicates
        const existingCard = document.querySelector(`[data-technique-id="${technique.id}"]`);
        if (existingCard) {
            console.log(`‚ö†Ô∏è Custom technique '${technique.name}' already exists, skipping...`);
            return;
        }
        
        // Check if user is authenticated - show disabled style if not
        const isDisabled = !this.isAuthenticated;
        const signupText = isDisabled ? ' <span class="signup-required-text">(Sign up required)</span>' : '';
        
        const card = document.createElement('div');
        card.className = 'custom-card';
        card.dataset.techniqueId = technique.id;
        
        // Apply disabled styling if not authenticated
        if (isDisabled) {
            card.style.opacity = '0.5';
            card.style.pointerEvents = 'none';
        }
        
        card.innerHTML = `
            <div class="custom-card-icon">${technique.emoji || 'üéØ'}</div>
            <div class="custom-card-name">${technique.name}${signupText}</div>
            <div class="custom-card-duration">${technique.workMinutes}min focus</div>
            <div class="custom-card-break">${technique.shortBreakMinutes}min short break</div>
            <div class="custom-card-long-break">${technique.longBreakMinutes}min long break</div>
            <div class="custom-card-sessions">${technique.sessions} sessions</div>
            ${!isDisabled ? `<button class="custom-card-delete" onclick="window.pomodoroTimer.showDeleteTimerConfirmation('${technique.id}', '${technique.name.replace(/'/g, "\\'").replace(/"/g, "&quot;")}')">√ó</button>` : ''}
        `;
        
        // Add click handler to select technique (only if authenticated)
        if (!isDisabled) {
            card.addEventListener('click', (e) => {
                if (!e.target.classList.contains('custom-card-delete')) {
                    this.selectCustomTechnique(technique);
                }
            });
        }
        
        container.appendChild(card);
    }
    
    // Edit custom technique
    editCustomTechnique(technique) {
        try {
            // Store the technique being edited
            this.editingTechnique = technique;
            
            // Show the form
            this.showCustomForm();
            
            // Populate form with technique data
            const nameInput = document.getElementById('customName');
            const workSlider = document.getElementById('customWorkSlider');
            const workValue = document.getElementById('customWorkValue');
            const shortBreakSlider = document.getElementById('customShortBreakSlider');
            const shortBreakValue = document.getElementById('customShortBreakValue');
            const longBreakSlider = document.getElementById('customLongBreakSlider');
            const longBreakValue = document.getElementById('customLongBreakValue');
            const sessionsSlider = document.getElementById('customSessionsSlider');
            const sessionsValue = document.getElementById('customSessionsValue');
            
            if (nameInput) nameInput.value = technique.name;
            if (workSlider && workValue) {
                workSlider.value = technique.workMinutes;
                workValue.value = technique.workMinutes;
            }
            if (shortBreakSlider && shortBreakValue) {
                shortBreakSlider.value = technique.shortBreakMinutes;
                shortBreakValue.value = technique.shortBreakMinutes;
            }
            if (longBreakSlider && longBreakValue) {
                longBreakSlider.value = technique.longBreakMinutes;
                longBreakValue.value = technique.longBreakMinutes;
            }
            if (sessionsSlider && sessionsValue) {
                sessionsSlider.value = technique.sessions;
                sessionsValue.value = technique.sessions;
            }
            
            // Update word count
            this.updateWordCount();
            this.validateCustomForm();
            
            console.log('‚úÖ Editing custom technique:', technique);
            
        } catch (error) {
            console.error('Error editing custom technique:', error);
        }
    }
    
    // Apply technique immediately (all users)
    applyTechniqueImmediately(technique) {
        try {
            console.log('‚ö° Applying technique immediately for all users:', technique);
            
            // Update timer settings
            this.workTime = technique.workMinutes * 60;
            this.shortBreakTime = technique.shortBreakMinutes * 60;
            this.longBreakTime = technique.longBreakMinutes * 60;
            this.sessionsPerCycle = technique.sessions;
            
            // Update cycle sections dynamically based on sessionsPerCycle
            this.buildCycleSections();
            
            // Reset timer to first section using the complete reset function (like Save Changes)
            this.resetTimer();
            
            // Save automatically to localStorage
            this.saveTechniqueSettings(technique);
            
            // Update timer technique button with proper capitalized name
            this.updateTimerTechniqueButton(technique.name);
            
            console.log('‚úÖ Technique applied immediately');
            
        } catch (error) {
            console.error('Error applying technique immediately:', error);
        }
    }
    
    // Update the timer technique button text and sidebar title
    updateTimerTechniqueButton(techniqueName) {
        const techniqueDisplayNames = {
            'pomodoro': 'Pomodoro',
            'sprint': 'Sprint',
            'focus': 'Focus',
            'flow': 'Flow State',
            'marathon': 'Marathon',
            'deepwork': 'Deep Work'
        };
        
        const displayName = techniqueDisplayNames[techniqueName] || techniqueName || 'Pomodoro';
        
        // Update timer technique button (center top)
        if (this.timerTechniqueName) {
            this.timerTechniqueName.textContent = displayName;
        }
        
        // Update sidebar technique title
        if (this.techniqueTitle) {
            this.techniqueTitle.innerHTML = `${displayName}<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down-icon lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg>`;
        }
    }
    
    // Save technique settings to localStorage
    saveTechniqueSettings(technique) {
        try {
            if (this.isAuthenticated) {
                localStorage.setItem('pomodoroTime', String(this.workTime));
                localStorage.setItem('shortBreakTime', String(this.shortBreakTime));
                localStorage.setItem('longBreakTime', String(this.longBreakTime));
                localStorage.setItem('sessionsPerCycle', String(this.sessionsPerCycle));
                
                // Save technique identifier properly
                if (technique.id) {
                    // Custom technique
                    localStorage.setItem('selectedTechnique', `custom_${technique.id}`);
                    console.log(`‚úÖ Custom technique '${technique.name}' (ID: ${technique.id}) saved to localStorage`);
                } else {
                    // Regular technique
                    localStorage.setItem('selectedTechnique', technique.name || 'custom');
                    console.log(`‚úÖ Regular technique '${technique.name}' saved to localStorage`);
                }
            }
        } catch (error) {
            console.error('Error saving technique settings:', error);
        }
    }
    
    // Select custom technique
    selectCustomTechnique(technique) {
        try {
            // Remove active class from all custom cards
            const allCustomCards = document.querySelectorAll('.custom-card');
            allCustomCards.forEach(card => card.classList.remove('active'));
            
            // Remove active class from all regular techniques
            const allTechniquePresets = document.querySelectorAll('.technique-preset');
            allTechniquePresets.forEach(preset => preset.classList.remove('active'));
            
            // Add active class to selected custom card
            const selectedCard = document.querySelector(`[data-technique-id="${technique.id}"]`);
            if (selectedCard) {
                selectedCard.classList.add('active');
            }
            
            // Apply immediately for all users
            this.applyTechniqueImmediately(technique);
            
            console.log('‚úÖ Custom technique selected:', technique);
            
        } catch (error) {
            console.error('Error selecting custom technique:', error);
        }
    }
    
    // Show delete timer confirmation modal
    showDeleteTimerConfirmation(techniqueId, techniqueName) {
        const isPremium = this.isPremiumUser();
        
        // Escape the technique name to prevent XSS
        const escapedName = this.escapeHtml(techniqueName);
        
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';
        
        // Create modal
        const modal = document.createElement('div');
        modal.className = 'logout-modal';
        modal.style.cssText = 'max-width: 440px; padding: 32px; position: relative;';
        
        // Warning message differs for free vs premium
        const warningMessage = !isPremium 
            ? 'This action CANNOT be undone. Free users can only create 1 custom timer permanently.'
            : 'This action cannot be undone.';
        
        modal.innerHTML = `
            <button class="close-modal-x" id="closeDeleteTimerModal" style="position: absolute; top: 16px; right: 16px; background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 8px; display: flex; align-items: center; justify-content: center;">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            
            <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: white; line-height: 1.3; text-align: left;">
                Delete Timer Permanently?
            </h3>
            <p style="font-size: 14px; color: rgba(255,255,255,0.7); margin-bottom: 32px; line-height: 1.5; text-align: left;">
                ${warningMessage}
            </p>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="logout-modal-btn logout-modal-btn-secondary" id="cancelDeleteTimer">Cancel</button>
                <button class="logout-modal-btn logout-modal-btn-primary" id="confirmDeleteTimer">Delete</button>
            </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        const close = () => {
            try { document.body.removeChild(overlay); } catch (_) {}
        };
        
        // Close X button
        modal.querySelector('#closeDeleteTimerModal').addEventListener('click', close);
        
        // Cancel button
        modal.querySelector('#cancelDeleteTimer').addEventListener('click', close);
        
        // Confirm button
        modal.querySelector('#confirmDeleteTimer').addEventListener('click', () => {
            this.deleteCustomTechnique(techniqueId);
            close();
        });
    }
    
    // Delete custom technique
    deleteCustomTechnique(techniqueId) {
        try {
            // Remove from localStorage
            const techniques = JSON.parse(localStorage.getItem('customTechniques') || '[]');
            const filtered = techniques.filter(t => t.id !== techniqueId);
            localStorage.setItem('customTechniques', JSON.stringify(filtered));
            
            // Remove from UI
            const card = document.querySelector(`[data-technique-id="${techniqueId}"]`);
            if (card) {
                card.remove();
            }
            
            // Sync deletion to server
            this.syncTechniquesToServer();
            
            console.log('‚úÖ Custom technique deleted:', techniqueId);
            
        } catch (error) {
            console.error('Error deleting custom technique:', error);
        }
    }
    
    async updateAuthState() {
        console.log('Updating auth state:', { isAuthenticated: this.isAuthenticated, user: this.user });
        
        // Debug multiple account issues
        this.debugAuthState();
        
        // If we just logged out, do NOT rehydrate from Clerk even if window.Clerk.user still exists moment√°neamente
        let justLoggedOut = false;
        try { justLoggedOut = sessionStorage.getItem('just_logged_out') === 'true'; } catch (_) {}

        // Force check current auth state from Clerk unless we just logged out
        if (window.Clerk && window.Clerk.user && !justLoggedOut) {
            this.isAuthenticated = true;
            this.user = window.Clerk.user;
        }
        
        // Update Pro status
        const wasPro = this.isPro;
        this.isPro = this.isPremiumUser();
        
        // Track Pro conversion if user just became Pro
        if (!wasPro && this.isPro && this.isAuthenticated) {
            this.trackEvent('User Upgraded to Pro', {
                user_id: this.user?.id,
                email: this.user?.emailAddresses[0]?.emailAddress,
                conversion_type: 'free_to_pro',
                user_journey: 'free ‚Üí pro',
                source: 'stripe_webhook',
                revenue: 9.0,
                timestamp: new Date().toISOString()
            });
        }
        
        if (this.isAuthenticated && this.user) {
            try { localStorage.setItem('hasAccount', 'true'); } catch (_) {}
            
            // Track user authentication (first time or returning)
            this.trackEvent('User Authenticated', {
                user_id: this.user.id,
                email: this.user.emailAddresses[0]?.emailAddress,
                is_pro: this.isPro,
                signup_date: this.user.createdAt,
                authentication_type: 'clerk_auth'
            });
            
            // Identify user in Mixpanel
            this.identifyUser();
            
            // Enable Timer panel features for authenticated users
            this.enableTimerPanelFeatures();
            
            // Auto-fix panel issues for authenticated users
            this.autoFixPanelIssues();
            
            // üéØ Track User Login event to Mixpanel
            if (window.mixpanelTracker) {
                window.mixpanelTracker.trackUserLogin('clerk');
                console.log('üìä User login event tracked to Mixpanel');
            }
            
            if (this.authContainer) this.authContainer.style.display = 'none';
            if (this.userProfileContainer) this.userProfileContainer.style.display = 'none'; // Always hidden, use settings menu instead
            // Always show logo, never show achievement icon
            if (this.logoIcon) this.logoIcon.style.display = 'flex';
            if (this.achievementIcon) this.achievementIcon.style.display = 'none';
            // Streak info is now always visible via CSS
            this.updateUserProfile();
            // Initialize cycle counter for authenticated users
            this.initializeCycleCounter();
            // Also update badge immediately
            this.updateFocusHoursDisplay();
            // Update premium UI
            this.updatePremiumUI();
            // Update technique presets visibility
            this.updateTechniquePresetsVisibility();
            // Reconciliar premium desde backend
            this.refreshPremiumFromServer().catch(() => {});
            this.handleStripeCheckoutReturn();
            
            // Ensure cassette auth gating and saved Tron theme are applied post-hydration
            try { this.updateThemeAuthState(); } catch (_) {}
            try {
                const savedTheme = localStorage.getItem('lastSelectedTheme');
                // If we deferred Tron application, and user is authenticated now, apply it
                if (this.pendingThemeApply === 'tron' && this.isAuthenticated) {
                    console.log('üé® Auth hydrated: applying deferred Tron theme');
                    this.applyTheme('tron');
                    this.pendingThemeApply = null;
                } else if (savedTheme && savedTheme !== this.currentTheme) {
                    // Ensure saved cassette is honored
                    this.applyTheme(savedTheme);
                }
            } catch (_) {}
            // Check admin access for Developer tab
            this.checkAdminAccess();
            // Welcome modal removed
            // Hide loading screen when user is authenticated
            this.hideLoadingScreen();
            console.log('User is authenticated, showing profile avatar');
            
            // Update settings dropdown for authenticated user
            if (this.settingsUserInfo) this.settingsUserInfo.style.display = 'flex';
            if (this.settingsAuthSection) this.settingsAuthSection.style.display = 'none';
            
            // Add authenticated-user class to dropdown for proper width handling
            if (this.settingsDropdown) {
                this.settingsDropdown.classList.add('authenticated-user');
            }
            if (this.settingsAccountSection) this.settingsAccountSection.style.display = 'block';
            if (this.settingsReportSection) this.settingsReportSection.style.display = 'block';
            if (this.settingsSettingsSection) this.settingsSettingsSection.style.display = 'none';
            if (this.settingsLogoutBtn) this.settingsLogoutBtn.style.display = 'flex';
            if (this.settingsLogoutDivider) this.settingsLogoutDivider.style.display = 'block';
            
            // Show auth status indicator (green dot)
            const authIndicator = document.getElementById('authStatusIndicator');
            if (authIndicator) {
                authIndicator.style.display = 'block';
                authIndicator.classList.remove('expired');
                authIndicator.title = 'Logged in';
            }
            
            // Hide timer header auth buttons when authenticated
            const timerHeaderAuth = document.getElementById('timerHeaderAuth');
            if (timerHeaderAuth) timerHeaderAuth.style.display = 'none';

            
            // Show Report header when authenticated
            const timerHeaderFocusReport = document.getElementById('timerHeaderFocusReport');
            if (timerHeaderFocusReport) timerHeaderFocusReport.style.display = 'block';
            
            // Show/hide Subscribe button based on user type
            const subscribeBtn = document.getElementById('subscribeBtn');
            if (subscribeBtn) {
                if (this.isPro) {
                    // Hide Subscribe button for Pro users
                    subscribeBtn.style.display = 'none';
                } else {
                    // Show Subscribe button for Free users
                    subscribeBtn.style.display = 'flex';
                }
            }

            // Restore stats from Clerk if needed (server ‚Üí localStorage)
            // This ensures users don't lose data when switching between accounts
            await this.restoreStatsFromClerk();
            
            // Sync stats to Clerk on authentication (localStorage ‚Üí server)
            const stats = this.getFocusStats();
            if (stats.totalHours) {
                await this.syncStatsToClerk(stats.totalHours);
            }
            
            // Load user-specific focus seconds today
            this.focusSecondsToday = this.loadFocusSecondsToday();
            console.log('üìä Loaded focus seconds today for user:', this.focusSecondsToday);
            
            // Hide content section and footer when authenticated (only show timer)
            const contentSection = document.querySelector('.content-section');
            const mainFooter = document.querySelector('.main-footer');
            if (contentSection) contentSection.style.display = 'none';
            if (mainFooter) mainFooter.style.display = 'none';
            
            // Update user display name in settings dropdown (First name if available, email if not)
            if (this.settingsUserEmail && this.user) {
                const firstName = this.user.firstName;
                const email = this.user.primaryEmailAddress?.emailAddress || this.user.emailAddresses?.[0]?.emailAddress;
                
                // Use first name if available, otherwise use email
                const displayName = firstName || email || 'User';
                this.settingsUserEmail.textContent = displayName;
            }


            // Apply saved technique now that auth is ready
            this.applySavedTechniqueOnce();
            // Restore user's saved volume preference when authenticated
            try {
                const savedVolume = localStorage.getItem('ambientVolume');
                if (savedVolume !== null) {
                    this.ambientVolume = Math.max(0, Math.min(1, parseFloat(savedVolume)));
                    if (this.backgroundAudio) this.backgroundAudio.volume = this.ambientVolume;
                }
            } catch (_) {}
            
            // Restore user's saved music preferences when authenticated
            try {
                const savedAmbientEnabled = localStorage.getItem('ambientEnabled');
                if (savedAmbientEnabled !== null) {
                    this.ambientEnabled = savedAmbientEnabled === 'true';
                }
                const savedRainEnabled = localStorage.getItem('rainEnabled');
                if (savedRainEnabled !== null) {
                    this.rainEnabled = savedRainEnabled === 'true';
                }
            } catch (_) {}
        } else {
            // Double-check with Clerk before showing login UI
            if (window.Clerk && window.Clerk.user) {
                console.log('Clerk user found, updating auth state');
                this.isAuthenticated = true;
                this.user = window.Clerk.user;
                // Recursively call updateAuthState to handle authenticated case
                this.updateAuthState();
                return;
            }
            
            // Reset Pro status for unauthenticated users
            this.isPro = false;
            
            // Reset technique ASAP for snappy UI when user is not authenticated
            this.resetToDefaultTechniqueIfNeeded();

            // Local tasks only - no integration cleanup needed
            
            if (this.authContainer) this.authContainer.style.display = 'none'; // Always hidden, use settings menu instead
            if (this.userProfileContainer) this.userProfileContainer.style.display = 'none';
            // Always show logo, never show achievement icon
            if (this.logoIcon) this.logoIcon.style.display = 'flex';
            if (this.achievementIcon) this.achievementIcon.style.display = 'none';
            // Streak info is now always visible via CSS
            if (this.loginButton) this.loginButton.textContent = 'Login';
            // Keep header buttons hidden - they're now in the settings menu
            if (this.signupButton) this.signupButton.style.display = 'none';
            if (this.loginButton) this.loginButton.style.display = 'none';
            console.log('User is not authenticated, showing settings menu with login/signup options');
            
            // Reset header settings button to show user icon (not logged in)
            if (this.headerSettingsIcon) this.headerSettingsIcon.style.display = 'block';
            if (this.headerSettingsAvatar) this.headerSettingsAvatar.style.display = 'none';

            this.updateBottomSheetAccountUI();
            
            // Update settings dropdown for non-authenticated user
            if (this.settingsUserInfo) this.settingsUserInfo.style.display = 'none';
            if (this.settingsAuthSection) this.settingsAuthSection.style.display = 'block';
            
            // Remove authenticated-user class from dropdown for guest users
            if (this.settingsDropdown) {
                this.settingsDropdown.classList.remove('authenticated-user');
            }
            if (this.settingsAccountSection) this.settingsAccountSection.style.display = 'none';
            if (this.settingsReportSection) this.settingsReportSection.style.display = 'none';
            if (this.settingsSettingsSection) this.settingsSettingsSection.style.display = 'block';
            if (this.settingsLogoutBtn) this.settingsLogoutBtn.style.display = 'none';
            
            // Reload custom techniques and cassettes to show them disabled
            try { this.loadCustomTechniques(); } catch (_) {}
            try { this.loadCustomCassettes(); } catch (_) {}
            if (this.settingsLogoutDivider) this.settingsLogoutDivider.style.display = 'none';
            
            // Hide auth status indicator when not authenticated
            const authIndicator = document.getElementById('authStatusIndicator');
            if (authIndicator) {
                authIndicator.style.display = 'none';
            }
            
            // Show timer header auth buttons when not authenticated
            const timerHeaderAuth = document.getElementById('timerHeaderAuth');
            if (timerHeaderAuth) timerHeaderAuth.style.display = 'block';

            
            // Hide Report header when not authenticated
            const timerHeaderFocusReport = document.getElementById('timerHeaderFocusReport');
            if (timerHeaderFocusReport) timerHeaderFocusReport.style.display = 'none';
            
            // Hide Subscribe button for Guest users
            const subscribeBtn = document.getElementById('subscribeBtn');
            if (subscribeBtn) {
                subscribeBtn.style.display = 'none';
            }
            
            // Show content section and footer when not authenticated (guest user)
            const contentSection = document.querySelector('.content-section');
            const mainFooter = document.querySelector('.main-footer');
            if (contentSection) contentSection.style.display = 'block';
            if (mainFooter) mainFooter.style.display = 'block';
            
            // Reset badge to zero time for guests
            if (this.achievementCounter) {
                this.achievementCounter.textContent = '00h:00m';
            }
            // Ensure guest default volume (25%) when not authenticated
            // Don't override if user has a saved volume (they might logout and login again)
            const savedVolume = localStorage.getItem('ambientVolume');
            if (savedVolume === null) {
                this.ambientVolume = 0.25;
            if (this.backgroundAudio) this.backgroundAudio.volume = this.ambientVolume;
            }
            
            // Keep music state for logged-out users (they just can't change it)
            // Only new users without saved preferences will have 'false' by default (from initialization)
            // This allows logged-out users to maintain their previous music selection visually
        }
        
        // Update dropdown badges based on authentication state
        this.updateDropdownState();
        
        // Check and reset streak if needed (after auth state is updated)
        this.checkAndResetStreakIfNeeded();
        
        // Update streak display based on authentication state
        this.updateStreakDisplay();
        
        // Update dropdown items disabled state
        this.updateDropdownItemsState();
        
        // Update technique presets visibility based on user type
        this.updateTechniquePresetsVisibility();

        this.updateBottomSheetAccountUI();
    }

    // Close all open modals to focus on timer
    closeAllModals() {
        // Close focus stats overlay (Tasks, Stats, etc.)
        const focusStatsOverlays = document.querySelectorAll('.focus-stats-overlay');
        focusStatsOverlays.forEach(overlay => {
            try { document.body.removeChild(overlay); } catch (_) {}
        });
        
        
        // Close logout modal
        const logoutModal = document.getElementById('logoutModalOverlay');
        if (logoutModal) logoutModal.style.display = 'none';
        
        // Close custom timer modal
        const customTimerModal = document.getElementById('customTimerModal');
        if (customTimerModal) customTimerModal.style.display = 'none';
        
        // Close upgrade modal
        const upgradeModal = document.querySelector('.upgrade-modal-overlay');
        if (upgradeModal) upgradeModal.style.display = 'none';
        
        // Close settings modal
        const settingsModal = document.getElementById('settingsModal');
        if (settingsModal) settingsModal.style.display = 'none';
        
        // Close celebration modal
        const celebrationModal = document.querySelector('.celebration-modal-overlay');
        if (celebrationModal) celebrationModal.style.display = 'none';
        
        // Close technique dropdown
        if (this.techniqueDropdown) {
            this.techniqueDropdown.classList.remove('open');
        }
        
        // Close user profile dropdown
        if (this.userProfileDropdown) {
            this.userProfileDropdown.style.display = 'none';
        }
    }

    // Reset to default technique if current technique requires authentication
    resetToDefaultTechniqueIfNeeded() {
        const savedTechnique = localStorage.getItem('selectedTechnique');
        if (!savedTechnique) return;
        
        // Check if the saved technique requires Pro
        const proTechniques = ['custom'];
        if (proTechniques.includes(savedTechnique)) {
            // Reset to default Pomodoro technique if user is not Pro
            if (!this.isPremiumUser()) {
                localStorage.setItem('selectedTechnique', 'pomodoro');
                
                // Update UI to show Pomodoro
                if (this.techniqueTitle) {
                    this.techniqueTitle.innerHTML = `Pomodoro<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down-icon lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg>`;
                }
                
                // Update dropdown selection to show check icon on Pomodoro
                if (this.dropdownItems) {
                    this.dropdownItems.forEach(item => {
                        item.classList.remove('selected');
                        if (item.dataset.technique === 'pomodoro') {
                            item.classList.add('selected');
                        }
                    });
                }
                
                // Load the default Pomodoro technique only if not already applied
                if (this.currentTechniqueKey !== 'pomodoro') {
                    this.loadTechnique('pomodoro');
                }
            }
        }
    }


    // Sync the settings panel technique selection with the main timer
    syncSettingsPanelTechnique(technique) {
        // Don't sync if technique is 'custom'
        if (technique === 'custom') {
            this.deselectTechniqueInPanel();
            return;
        }
        
        // For guest users, don't interfere with the default Pomodoro selection
        if (!this.isAuthenticated && technique === 'pomodoro') {
            console.log('‚úÖ Guest user - keeping default Pomodoro selection');
            return;
        }
        
        // Use setTimeout to ensure the panel is rendered
        setTimeout(() => {
            const settingsPanel = document.getElementById('settingsSidePanel');
            if (!settingsPanel) {
                console.log('‚ö†Ô∏è Settings panel not found in DOM');
                return;
            }
            
            const techniquePresets = settingsPanel.querySelectorAll('.technique-preset');
            if (!techniquePresets.length) {
                console.log('‚ö†Ô∏è No technique presets found in panel');
                return;
            }
            
            // Remove active class from all presets
            techniquePresets.forEach(preset => {
                preset.classList.remove('active');
            });
            
            // Add active class to the matching technique
            const matchingPreset = Array.from(techniquePresets).find(preset => 
                preset.dataset.technique === technique
            );
            
            if (matchingPreset) {
                matchingPreset.classList.add('active');
                console.log(`‚úÖ Settings panel synced with technique: ${technique}`);
                
                // Also update the sliders to reflect current settings
                this.updateSettingsPanelSliders();
            } else {
                console.log(`‚ö†Ô∏è Technique '${technique}' not found in settings panel`);
            }
        }, 100);
    }
    
    // Deselect technique in panel when user manually changes duration
    deselectTechniqueInPanel() {
        const settingsPanel = document.getElementById('settingsSidePanel');
        if (!settingsPanel) return;
        
        const techniquePresets = settingsPanel.querySelectorAll('.technique-preset');
        techniquePresets.forEach(preset => {
            preset.classList.remove('active');
        });
        
        console.log('üîÑ Technique deselected due to manual duration change');
    }

    // Update the sliders in the settings panel to reflect current values
    updateSettingsPanelSliders() {
        const pomodoroSlider = document.getElementById('sidebarPomodoroSlider');
        const shortBreakSlider = document.getElementById('sidebarShortBreakSlider');
        const longBreakSlider = document.getElementById('sidebarLongBreakSlider');
        const sessionsSlider = document.getElementById('sidebarSessionsSlider');
        
        const pomodoroValue = document.getElementById('sidebarPomodoroValue');
        const shortBreakValue = document.getElementById('sidebarShortBreakValue');
        const longBreakValue = document.getElementById('sidebarLongBreakValue');
        const sessionsValue = document.getElementById('sidebarSessionsValue');
        
        if (pomodoroSlider && pomodoroValue) {
            const minutes = Math.floor(this.workTime / 60);
            pomodoroSlider.value = minutes;
            pomodoroValue.value = minutes;
        }
        
        if (shortBreakSlider && shortBreakValue) {
            const minutes = Math.floor(this.shortBreakTime / 60);
            shortBreakSlider.value = minutes;
            shortBreakValue.value = minutes;
        }
        
        if (longBreakSlider && longBreakValue) {
            const minutes = Math.floor(this.longBreakTime / 60);
            longBreakSlider.value = minutes;
            longBreakValue.value = minutes;
        }
        
        if (sessionsSlider && sessionsValue) {
            sessionsSlider.value = this.sessionsPerCycle;
            sessionsValue.value = this.sessionsPerCycle;
        }
    }

    // Setup editable duration inputs to allow manual keyboard input
    setupEditableDurationInputs(container) {
        const editableInputs = container.querySelectorAll('.editable-duration');
        
        editableInputs.forEach(input => {
            const sliderId = input.dataset.slider;
            const slider = document.getElementById(sliderId);
            const min = parseInt(input.dataset.min);
            const max = parseInt(input.dataset.max);
            const unit = input.dataset.unit;
            
            if (!slider) return;
            
            // Skip if already initialized
            if (input.dataset.initialized === 'true') return;
            input.dataset.initialized = 'true';
            
            // Store the last valid value
            let lastValidValue = input.value;
            
            // Handle focus - select all text for easy editing
            input.addEventListener('focus', (e) => {
                lastValidValue = e.target.value;
                e.target.select();
            });
            
            // Handle input - only allow numbers and max 3 digits
            input.addEventListener('input', (e) => {
                let value = e.target.value;
                
                // Remove non-numeric characters
                value = value.replace(/[^0-9]/g, '');
                
                // Limit to 3 digits
                if (value.length > 3) {
                    value = value.slice(0, 3);
                }
                
                // If value is empty after cleaning, restore last valid value
                if (value === '') {
                    e.target.value = lastValidValue;
                } else {
                    // Check if value exceeds max and auto-correct it
                    let numValue = parseInt(value);
                    if (!isNaN(numValue) && numValue > max) {
                        value = max.toString();
                    }
                    
                    e.target.value = value;
                    lastValidValue = value;
                }
            });
            
            // Handle blur - validate and sync with slider
            input.addEventListener('blur', (e) => {
                let value = parseInt(e.target.value);
                
                // Validate value
                if (isNaN(value) || value < min) {
                    value = min;
                } else if (value > max) {
                    value = max;
                }
                
                // Update input and slider
                e.target.value = value;
                slider.value = value;
                lastValidValue = value.toString();
                
                // Trigger slider input event to update everything
                slider.dispatchEvent(new Event('input', { bubbles: true }));
            });
            
            // Handle Enter key - blur to apply changes
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.target.blur();
                }
            });
        });
    }

    // Apply saved technique once, after auth/user state is hydrated
    applySavedTechniqueOnce() {
        if (this.hasAppliedSavedTechnique) return;
        const saved = localStorage.getItem('selectedTechnique');
        const savedCustom = localStorage.getItem('customTimer');

        // Nothing saved ‚Üí keep default until user picks one
        if (!saved) {
            this.hasAppliedSavedTechnique = true;
            return;
        }

        // Custom selected
        if (saved === 'custom') {
            // Check if we have custom durations saved (from manual changes)
            const savedPomodoroTime = localStorage.getItem('pomodoroTime');
            const savedShortBreakTime = localStorage.getItem('shortBreakTime');
            const savedLongBreakTime = localStorage.getItem('longBreakTime');
            const savedSessionsPerCycle = localStorage.getItem('sessionsPerCycle');
            
            if (savedPomodoroTime || savedShortBreakTime || savedLongBreakTime || savedSessionsPerCycle) {
                // Apply saved custom durations
                if (savedPomodoroTime) this.workTime = parseInt(savedPomodoroTime);
                if (savedShortBreakTime) this.shortBreakTime = parseInt(savedShortBreakTime);
                if (savedLongBreakTime) this.longBreakTime = parseInt(savedLongBreakTime);
                if (savedSessionsPerCycle) this.sessionsPerCycle = parseInt(savedSessionsPerCycle);
                
                // Update cycle sections with custom durations (dynamic based on sessionsPerCycle)
                this.buildCycleSections();
                
                // Update UI to reflect custom durations
                this.updateProgressRing();
                this.updateDisplay();
                this.updateProgress();
                this.updateSections();
                this.updateSessionInfo();
                this.updateCurrentSessionTask();
                
                console.log('‚úÖ Applied saved custom configuration');
                this.hasAppliedSavedTechnique = true;
                return;
            }
            
            // Check for saved custom timer config
            if (savedCustom) {
                try {
                    const config = JSON.parse(savedCustom);
                    this.loadCustomTechnique(config);
                    this.hasAppliedSavedTechnique = true;
                    return;
                } catch (_) {
                    localStorage.removeItem('customTimer');
                    // No valid custom ‚Üí mark applied and keep default
                    this.hasAppliedSavedTechnique = true;
                    return;
                }
            }
            // No custom saved ‚Üí mark applied and keep default
            this.hasAppliedSavedTechnique = true;
            return;
        }

        // Built-in technique - load technique first
        const item = document.querySelector(`[data-technique="${saved}"]`);
        if (item) {
            this.selectTechnique(item);
            
            // After loading technique, check if there are saved custom durations
            // and apply them if they exist (user had customized the technique)
            const savedPomodoroTime = localStorage.getItem('pomodoroTime');
            const savedShortBreakTime = localStorage.getItem('shortBreakTime');
            const savedLongBreakTime = localStorage.getItem('longBreakTime');
            const savedSessionsPerCycle = localStorage.getItem('sessionsPerCycle');
            
            if (savedPomodoroTime || savedShortBreakTime || savedLongBreakTime || savedSessionsPerCycle) {
                // Apply saved custom durations
                if (savedPomodoroTime) this.workTime = parseInt(savedPomodoroTime);
                if (savedShortBreakTime) this.shortBreakTime = parseInt(savedShortBreakTime);
                if (savedLongBreakTime) this.longBreakTime = parseInt(savedLongBreakTime);
                if (savedSessionsPerCycle) this.sessionsPerCycle = parseInt(savedSessionsPerCycle);
                
                // Update cycle sections with custom durations (dynamic based on sessionsPerCycle)
                this.buildCycleSections();
                
                // Update UI to reflect custom durations
                this.updateProgressRing();
                this.updateDisplay();
                this.updateProgress();
                this.updateSections();
                this.updateSessionInfo();
                this.updateCurrentSessionTask();
                
                console.log('‚úÖ Applied saved custom durations to technique');
            }
            
            // Sync settings panel with the loaded technique
            this.syncSettingsPanelTechnique(saved);
            
            this.hasAppliedSavedTechnique = true;
            return;
        }

        // Unknown saved technique ‚Üí mark applied
        this.hasAppliedSavedTechnique = true;
    }

    updateUserProfile() {
        if (!this.user) return;
        
        // Update user display name in dropdown (First name if available, email if not)
        const userEmailElement = document.getElementById('userEmail');
        if (userEmailElement) {
            const firstName = this.user.firstName;
            const email = this.user.primaryEmailAddress?.emailAddress || this.user.emailAddresses?.[0]?.emailAddress;
            
            // Use first name if available, otherwise use email
            const displayName = firstName || email || 'User';
            userEmailElement.textContent = displayName;
        }
        
        // Update user avatar
        if (this.user.imageUrl && this.userAvatar) {
            this.userAvatar.src = this.user.imageUrl;
        } else if (this.userAvatar) {
            const initials = this.getInitials(this.user.fullName || this.user.firstName || (this.user.emailAddresses?.[0]?.emailAddress || 'U'));
            const svg = `
                <svg width="36" height="36" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg">
                    <rect width="36" height="36" fill="#555" rx="18"/>
                    <text x="18" y="22" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold">${initials}</text>
                </svg>`;
            this.userAvatar.src = `data:image/svg+xml;base64,${btoa(svg)}`;
        }
        
        // Update header settings button with user profile image
        if (this.user.imageUrl && this.headerSettingsAvatar && this.headerSettingsIcon) {
            this.headerSettingsAvatar.src = this.user.imageUrl;
            this.headerSettingsAvatar.style.display = 'block';
            this.headerSettingsIcon.style.display = 'none';
        } else if (this.headerSettingsAvatar && this.headerSettingsIcon) {
            const initials = this.getInitials(this.user.fullName || this.user.firstName || (this.user.emailAddresses?.[0]?.emailAddress || 'U'));
            const svg = `
                <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
                    <rect width="32" height="32" fill="#555" rx="16"/>
                    <text x="16" y="20" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="11" font-weight="bold">${initials}</text>
                </svg>`;
            this.headerSettingsAvatar.src = `data:image/svg+xml;base64,${btoa(svg)}`;
            this.headerSettingsAvatar.style.display = 'block';
            this.headerSettingsIcon.style.display = 'none';
        }

        this.updateBottomSheetAccountUI();
    }

    updateBottomSheetAccountUI() {
        if (!this.bottomSheetAccountName) return;

        const isLoggedIn = this.isAuthenticated && this.user;
        if (this.bottomSheetAccountItem) {
            this.bottomSheetAccountItem.classList.toggle('is-guest', !isLoggedIn);
        }
        if (isLoggedIn) {
            const firstName = this.user.firstName;
            const email = this.user.primaryEmailAddress?.emailAddress || this.user.emailAddresses?.[0]?.emailAddress;
            const displayName = firstName || email || 'User';
            this.bottomSheetAccountName.textContent = displayName;

            if (this.bottomSheetAccountAvatar && this.bottomSheetAccountIcon) {
                if (this.user.imageUrl) {
                    this.bottomSheetAccountAvatar.src = this.user.imageUrl;
                } else {
                    const initials = this.getInitials(this.user.fullName || this.user.firstName || (email || 'U'));
                    const svg = `
                        <svg width="28" height="28" viewBox="0 0 28 28" xmlns="http://www.w3.org/2000/svg">
                            <rect width="28" height="28" fill="#555" rx="14"/>
                            <text x="14" y="17" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="10" font-weight="bold">${initials}</text>
                        </svg>`;
                    this.bottomSheetAccountAvatar.src = `data:image/svg+xml;base64,${btoa(svg)}`;
                }
                this.bottomSheetAccountAvatar.style.display = 'block';
                this.bottomSheetAccountIcon.style.display = 'none';
            }
        } else {
            this.bottomSheetAccountName.textContent = 'Account';
            if (this.bottomSheetAccountAvatar && this.bottomSheetAccountIcon) {
                this.bottomSheetAccountAvatar.style.display = 'none';
                this.bottomSheetAccountIcon.style.display = 'flex';
            }
        }

        if (this.bottomSheetAccountBadge) {
            const isPremium = this.isAuthenticated && this.isPremiumUser();
            this.bottomSheetAccountBadge.style.display = isPremium ? 'inline-flex' : 'none';
        }

        const isPremium = this.isAuthenticated && this.isPremiumUser();
        const isFreeUser = this.isAuthenticated && !isPremium;
        const isGuest = !this.isAuthenticated;

        if (this.accountMenuLogin) this.accountMenuLogin.style.display = isGuest ? 'flex' : 'none';
        if (this.accountMenuSignup) this.accountMenuSignup.style.display = isGuest ? 'flex' : 'none';
        if (this.accountMenuUnlock) this.accountMenuUnlock.style.display = isFreeUser ? 'flex' : 'none';
        if (this.accountMenuManageSubscription) this.accountMenuManageSubscription.style.display = isPremium ? 'flex' : 'none';
        if (this.accountMenuSettings) this.accountMenuSettings.style.display = this.isAuthenticated ? 'flex' : 'none';
        if (this.accountMenuLogout) this.accountMenuLogout.style.display = this.isAuthenticated ? 'flex' : 'none';
    }

    getInitials(name) {
        return name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
    }
    
    showLogoutModal() {
        if (this.user && this.logoutModalMessage) {
            const userEmail = this.user.emailAddresses?.[0]?.emailAddress || 'user';
            this.logoutModalMessage.textContent = `Log out of Superfocus as ${userEmail}?`;
        }
        if (this.logoutModalOverlay) {
            this.logoutModalOverlay.style.display = 'flex';
        }
    }
    
    hideLogoutModal() {
        if (this.logoutModalOverlay) {
            this.logoutModalOverlay.style.display = 'none';
        }
    }

    showFeedbackModal() {
        if (this.feedbackModalOverlay) {
            this.feedbackModalOverlay.style.display = 'flex';
            // Clear previous feedback
            if (this.feedbackText) {
                this.feedbackText.value = '';
            }
        }
    }

    hideFeedbackModal() {
        if (this.feedbackModalOverlay) {
            this.feedbackModalOverlay.style.display = 'none';
        }
    }
    
    showProductivityResourcesModal() {
        if (this.productivityResourcesModalOverlay) {
            this.productivityResourcesModalOverlay.style.display = 'flex';
            // Initialize share buttons in modal
            this.initializeResourceShareButtons();
        }
    }
    
    initializeResourceShareButtons() {
        // Get all share buttons within the modal
        const modal = this.productivityResourcesModalOverlay;
        if (!modal) return;
        
        const shareButtons = modal.querySelectorAll('.resource-share-btn');
        shareButtons.forEach(btn => {
            // Remove existing listeners to avoid duplicates
            const newBtn = btn.cloneNode(true);
            btn.parentNode.replaceChild(newBtn, btn);
            
            newBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                const shareUrl = newBtn.getAttribute('data-share-url');
                const shareTitle = newBtn.getAttribute('data-share-title');
                
                // Copy to clipboard
                try {
                    await navigator.clipboard.writeText(shareUrl);
                    // Show toast notification
                    this.showResourceShareToast('Link copied to clipboard');
                    
                    // Track share event
                    this.trackEvent('Resource Shared', {
                        resource_title: shareTitle,
                        resource_url: shareUrl,
                        share_method: 'clipboard',
                        source: 'productivity_resources_modal'
                    });
                } catch (err) {
                    console.error('Failed to copy to clipboard:', err);
                    this.showResourceShareToast('Failed to copy link', true);
                }
            });
        });
    }
    
    showResourceShareToast(message, isError = false) {
        // Remove existing toast if any
        const existingToast = document.querySelector('.resource-share-toast');
        if (existingToast) {
            existingToast.remove();
        }
        
        // Create toast element
        const toast = document.createElement('div');
        toast.className = 'resource-share-toast';
        if (isError) {
            toast.classList.add('error');
        }
        toast.textContent = message;
        
        // Add to DOM
        document.body.appendChild(toast);
        
        // Trigger animation
        setTimeout(() => {
            toast.classList.add('show');
        }, 10);
        
        // Remove after 2 seconds
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 2000);
    }
    
    hideProductivityResourcesModal() {
        if (this.productivityResourcesModalOverlay) {
            this.productivityResourcesModalOverlay.style.display = 'none';
        }
    }
    
    showLeaderboardModal() {
        if (this.leaderboardModalOverlay) {
            this.leaderboardModalOverlay.style.display = 'flex';
            // Load leaderboard in modal
            this.loadLeaderboardForModal();
            this.startLeaderboardAutoRefresh();
        }
    }
    
    hideLeaderboardModal() {
        if (this.leaderboardModalOverlay) {
            this.leaderboardModalOverlay.style.display = 'none';
        }
        this.stopLeaderboardAutoRefreshIfIdle();
    }

    isLeaderboardModalOpen() {
        return this.leaderboardModalOverlay?.style.display === 'flex';
    }

    isLeaderboardPanelOpen() {
        const panel = document.getElementById('leaderboardSidePanel');
        return !!panel?.classList.contains('open');
    }

    startLeaderboardAutoRefresh() {
        if (this.leaderboardAutoRefreshId) return;

        this.leaderboardAutoRefreshId = setInterval(() => {
            if (this.isLeaderboardPanelOpen()) {
                this.loadLeaderboardForPanel(this.leaderboardCurrentPage || 1);
            }
            if (this.isLeaderboardModalOpen()) {
                this.loadLeaderboardForModal(this.leaderboardModalCurrentPage || 1);
            }
        }, this.LEADERBOARD_AUTO_REFRESH_MS);
    }

    stopLeaderboardAutoRefreshIfIdle() {
        if (this.isLeaderboardPanelOpen() || this.isLeaderboardModalOpen()) {
            return;
        }
        if (this.leaderboardAutoRefreshId) {
            clearInterval(this.leaderboardAutoRefreshId);
            this.leaderboardAutoRefreshId = null;
        }
    }
    
    async loadLeaderboardForModal(page = 1) {
        // Only load if authenticated
        if (!this.isAuthenticated || !this.user?.id) {
            const leaderboardContent = document.getElementById('leaderboardModalContent');
            if (leaderboardContent) {
                leaderboardContent.innerHTML = `
                    <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                        Please log in to view the leaderboard.
                    </div>
                `;
            }
            return;
        }

        const leaderboardContent = document.getElementById('leaderboardModalContent');
        if (!leaderboardContent) return;

        this.leaderboardModalCurrentPage = page;

        // Get current user's total hours
        const stats = this.getFocusStats();
        const currentTotalHours = stats.totalHours || 0;

        // Check if we have cached leaderboard data for this specific page
        const cachedData = this.leaderboardCache[page];
        const cachedTotalHours = this.leaderboardCachedAtHours || 0;
        const cacheAgeMs = cachedData?.cachedAt ? Date.now() - cachedData.cachedAt : Number.POSITIVE_INFINITY;
        const isCacheStale = cacheAgeMs > this.LEADERBOARD_CACHE_TTL_MS;

        // Calculate if user has earned at least 1 minute (0.0167 hours) since last cache
        const hoursEarnedSinceCache = currentTotalHours - cachedTotalHours;
        const needsRefresh = hoursEarnedSinceCache >= (1 / 60); // 1 minute = 1/60 hours

        // If user earned 1+ minute, clear ALL page caches (position may have changed)
        if (needsRefresh) {
            console.log(`üóëÔ∏è Clearing all leaderboard page caches (earned ${(hoursEarnedSinceCache * 60).toFixed(1)} min)`);
            this.leaderboardCache = {};
            localStorage.removeItem('leaderboardCache');
            localStorage.removeItem('leaderboardCachedAtHours');
        }

        // If we have cache for this page, show it immediately
        if (cachedData) {
            console.log(`üì¶ Using cached leaderboard page ${page}`);
            console.log(`   Current: ${currentTotalHours.toFixed(2)}h, Cached at: ${cachedTotalHours.toFixed(2)}h, Diff: ${(hoursEarnedSinceCache * 60).toFixed(1)} min`);
            
            this.displayLeaderboardInModal(
                leaderboardContent,
                cachedData.leaderboard,
                cachedData.currentUserPosition,
                cachedData.pagination,
                cachedData.rankMeta
            );

            if (!needsRefresh && !isCacheStale) {
                return;
            }
        }

        console.log(`üîÑ Fetching fresh leaderboard page ${page} from server...`);
        if (needsRefresh) {
            console.log(`   Reason: Earned ${(hoursEarnedSinceCache * 60).toFixed(1)} minutes since last load`);
        } else if (!cachedData) {
            console.log(`   Reason: First time loading page ${page}`);
        }

        // Sync local stats to Clerk if they exist (one-time sync for existing users)
        // Only sync on page 1 to avoid unnecessary calls
        if (page === 1) {
            if (stats.totalHours && stats.totalHours > 0) {
                // Sync stats to ensure they're in Clerk (async, don't wait)
                this.syncStatsToClerk(stats.totalHours);
            }
        }

        try {
            const response = await fetch(`/api/leaderboard?page=${page}&limit=100`, {
                method: 'GET',
                headers: {
                    'x-clerk-userid': this.user.id
                }
            });

            if (!response.ok) {
                throw new Error('Failed to fetch leaderboard');
            }

            const data = await response.json();
            if (data.success && data.leaderboard) {
                // Log debug info if available
                if (data.debug) {
                    console.log('Leaderboard Debug:', data.debug);
                }

                // Cache the leaderboard data for this page
                this.leaderboardCache[page] = {
                    leaderboard: data.leaderboard,
                    currentUserPosition: data.currentUserPosition,
                    pagination: {
                        page: data.page,
                        totalPages: data.totalPages,
                        totalUsers: data.totalUsers,
                        hasMore: data.hasMore
                    },
                    rankMeta: {
                        nextRankGapMinutes: data.nextRankGapMinutes,
                        nextRankTargetRank: data.nextRankTargetRank
                    },
                    cachedAt: Date.now()
                };
                
                // Update cached hours timestamp (shared across all pages)
                this.leaderboardCachedAtHours = currentTotalHours;
                
                // Persist cache to localStorage (survives page reloads and browser close)
                try {
                    localStorage.setItem('leaderboardCache', JSON.stringify(this.leaderboardCache));
                    localStorage.setItem('leaderboardCachedAtHours', currentTotalHours.toString());
                    localStorage.setItem('leaderboardCacheVersion', this.LEADERBOARD_CACHE_VERSION);
                } catch (err) {
                    console.error('Failed to save leaderboard cache to localStorage:', err);
                }
                
                console.log(`‚úÖ Leaderboard page ${page} cached at ${currentTotalHours.toFixed(2)}h`);

                this.displayLeaderboardInModal(
                    leaderboardContent,
                    data.leaderboard,
                    data.currentUserPosition,
                    {
                        page: data.page,
                        totalPages: data.totalPages,
                        totalUsers: data.totalUsers,
                        hasMore: data.hasMore
                    },
                    {
                        nextRankGapMinutes: data.nextRankGapMinutes,
                        nextRankTargetRank: data.nextRankTargetRank
                    }
                );
            } else {
                leaderboardContent.innerHTML = `
                    <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                        Failed to load leaderboard.
                    </div>
                `;
            }
        } catch (error) {
            console.error('Error loading leaderboard:', error);
            leaderboardContent.innerHTML = `
                <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                    Error loading leaderboard. Please try again later.
                </div>
            `;
        }
    }

    displayLeaderboardInModal(containerElement, leaderboard, currentUserPosition, pagination = null, rankMeta = null) {
        // Find current user's stats
        const stats = this.getFocusStats();
        const totalHours = stats.totalHours || 0;
        const hours = Math.floor(totalHours);
        const minutes = Math.round((totalHours - hours) * 60);
        const userTimeString = `${hours}h ${minutes}m`;
        const nextRankGapMinutes = rankMeta?.nextRankGapMinutes;
        const nextRankTargetRank = rankMeta?.nextRankTargetRank;

        let nextRankGapLine = '';
        if (
            currentUserPosition &&
            Number.isFinite(nextRankGapMinutes) &&
            nextRankGapMinutes > 0 &&
            nextRankTargetRank
        ) {
            const gapHours = Math.floor(nextRankGapMinutes / 60);
            const gapMinutes = nextRankGapMinutes % 60;
            const gapTime = gapHours > 0 ? `${gapHours}h ${gapMinutes}m` : `${gapMinutes}m`;
            nextRankGapLine = `You need ${gapTime} to pass Rank ${nextRankTargetRank}.`;
        }

        let html = '';
        const isPremiumUser = this.isPremiumUser ? this.isPremiumUser() : false;

        // Header with user position (Premium: full card; Free: rank + CTA to appear on list)
        if (isPremiumUser && currentUserPosition) {
            const totalUsersText = pagination?.totalUsers ?? leaderboard.length;
            html += `
                <div style="padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin-bottom: 16px; border: 1px solid rgba(255, 255, 255, 0.08);">
                    <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 4px;">Your Rank</div>
                    <div style="color: #fff; font-size: 24px; font-weight: 700;">#${currentUserPosition}</div>
                    <div style="color: #a3a3a3; font-size: 12px; margin-top: 4px;">${userTimeString} ‚Ä¢ ${totalUsersText} premium users</div>
                    ${nextRankGapLine ? `<div style="color: #a3a3a3; font-size: 12px; margin-top: 6px;">${nextRankGapLine}</div>` : ''}
                </div>
            `;
        } else if (!isPremiumUser) {
            const rankLine = currentUserPosition
                ? `<div style="color: #fff; font-size: 24px; font-weight: 700;">#${currentUserPosition}</div><div style="color: #a3a3a3; font-size: 12px; margin-top: 4px;">${userTimeString}</div>`
                : '';
            const ctaLine = currentUserPosition
                ? 'Want to appear on the list? Upgrade to Premium.'
                : 'Upgrade to Premium to see your ranking.';
            html += `
                <div style="padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin-bottom: 16px; border: 1px solid rgba(255, 255, 255, 0.08);">
                    <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 6px;">Your rank would be</div>
                    ${rankLine}
                    <div style="color: #a3a3a3; font-size: 12px; margin-top: 8px; margin-bottom: 12px;">${ctaLine}</div>
                    <button id="leaderboardModalUpgradeBtn" style="background: #fff; color: #000; border: none; padding: 10px 18px; border-radius: 10px; font-weight: 700; cursor: pointer; font-size: 13px;">Unlock Unlimited</button>
                </div>
            `;
        }

        // Leaderboard list
        const topUsers = leaderboard.filter((user) => user.isPremium === true);
        const currentPage = pagination?.page || 1;
        const totalPages = pagination?.totalPages || 1;
        const pageSize = pagination?.pageSize || 100;
        const startRank = (currentPage - 1) * pageSize + 1;
        
        if (topUsers.length === 0) {
            html += `
                <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                    No Premium users yet. Be the first!
                </div>
            `;
        } else {
            html += '<div style="display: flex; flex-direction: column; gap: 8px;">';
            html += topUsers.map((user, index) => {
                const isCurrentUser = user.isCurrentUser;
                const isPremium = user.isPremium === true;
                const userHours = Math.floor(user.totalFocusHours);
                const userMinutes = Math.round((user.totalFocusHours - userHours) * 60);
                const userTimeStr = `${userHours}h ${userMinutes}m`;
                
                const globalRank = startRank + index;

                const premiumCrown = isPremium ? `
                    <span 
                        style="
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            margin-left: 8px;
                            cursor: help;
                            position: relative;
                        "
                        title="Premium Member"
                        class="premium-crown-badge"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z"/>
                            <path d="M5 21h14"/>
                        </svg>
                    </span>
                ` : '';

                const rankChange = user.rankChange;
                let rankChangeIcon = '';
                if (typeof rankChange === 'number' && rankChange !== 0) {
                    const isUp = rankChange > 0;
                    const color = isUp ? '#22c55e' : '#ef4444';
                    const iconSvg = isUp
                        ? `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-move-up-icon"><path d="M8 6L12 2L16 6"/><path d="M12 2V22"/></svg>`
                        : `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-move-down-icon"><path d="M8 18L12 22L16 18"/><path d="M12 2V22"/></svg>`;

                    rankChangeIcon = `
                        <span style="display: inline-flex; align-items: center; margin-left: 6px; color: ${color};">
                            ${iconSvg}
                        </span>
                    `;
                }

                return `
                    <div style="
                        padding: 12px 16px;
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        background: ${isCurrentUser ? 'rgba(34, 197, 94, 0.1)' : 'rgba(255, 255, 255, 0.05)'};
                        border-radius: 8px;
                        border: ${isCurrentUser ? '1px solid rgba(34, 197, 94, 0.3)' : '1px solid rgba(255, 255, 255, 0.05)'};
                        position: relative;
                    ">
                        <div style="display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0;">
                            <div style="display: flex; align-items: center; min-width: 60px;">
                                <span style="color: #a3a3a3; font-size: 14px; font-weight: 600;">${globalRank}.</span>
                                ${premiumCrown}
                                ${rankChangeIcon}
                            </div>
                            <span style="
                                color: ${isCurrentUser ? '#22c55e' : '#fff'}; 
                                font-size: 14px; 
                                font-weight: ${isCurrentUser ? '600' : '500'}; 
                                overflow: hidden; 
                                text-overflow: ellipsis; 
                                white-space: nowrap;
                            ">
                                ${this.escapeHtml(user.username)}
                            </span>
                        </div>
                        <span style="color: #a3a3a3; font-size: 14px; font-weight: 500;">${userTimeStr}</span>
                    </div>
                `;
            }).join('');
            html += '</div>';
        }

        // Pagination controls (only show if there are more than 100 users)
        if (pagination && totalPages > 1) {
            html += `
                <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; align-items: center; justify-content: space-between; gap: 16px;">
                    <button 
                        id="leaderboardModalPrevPage" 
                        style="
                            padding: 8px 16px;
                            background: ${currentPage > 1 ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 255, 255, 0.05)'};
                            color: ${currentPage > 1 ? '#fff' : '#d0d0d0'};
                            border: 1px solid rgba(255, 255, 255, 0.1);
                            border-radius: 8px;
                            cursor: ${currentPage > 1 ? 'pointer' : 'not-allowed'};
                            font-size: 14px;
                            font-weight: 500;
                            transition: all 0.2s;
                            ${currentPage > 1 ? '' : 'opacity: 0.5;'}
                        "
                        ${currentPage > 1 ? '' : 'disabled'}
                    >
                        ‚Üê Previous
                    </button>
                    <div style="color: #a3a3a3; font-size: 14px;">
                        Page ${currentPage} of ${totalPages}
                    </div>
                    <button 
                        id="leaderboardModalNextPage" 
                        style="
                            padding: 8px 16px;
                            background: ${currentPage < totalPages ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 255, 255, 0.05)'};
                            color: ${currentPage < totalPages ? '#fff' : '#d0d0d0'};
                            border: 1px solid rgba(255, 255, 255, 0.1);
                            border-radius: 8px;
                            cursor: ${currentPage < totalPages ? 'pointer' : 'not-allowed'};
                            font-size: 14px;
                            font-weight: 500;
                            transition: all 0.2s;
                            ${currentPage < totalPages ? '' : 'opacity: 0.5;'}
                        "
                        ${currentPage < totalPages ? '' : 'disabled'}
                    >
                        Next ‚Üí
                    </button>
                </div>
            `;
        }

        containerElement.innerHTML = html;

        const upgradeBtn = containerElement.querySelector('#leaderboardModalUpgradeBtn');
        if (upgradeBtn) {
            upgradeBtn.addEventListener('click', () => {
                this.trackEvent('Subscribe Clicked', {
                    source: 'leaderboard_modal',
                    location: 'leaderboard_modal',
                    button_text: 'Unlock Unlimited'
                });
                this.showPricingPlansModal();
            });
        }

        // Add event listeners for pagination buttons
        if (pagination && totalPages > 1) {
            const prevBtn = document.getElementById('leaderboardModalPrevPage');
            const nextBtn = document.getElementById('leaderboardModalNextPage');
            
            if (prevBtn && currentPage > 1) {
                prevBtn.addEventListener('click', () => {
                    this.loadLeaderboardForModal(currentPage - 1);
                });
            }
            
            if (nextBtn && currentPage < totalPages) {
                nextBtn.addEventListener('click', () => {
                    this.loadLeaderboardForModal(currentPage + 1);
                });
            }
        }
    }
    
    showTechniqueModal(technique) {
        
        // Get technique name
        const techniqueNames = {
            'sprint': 'Sprint',
            'focus': 'Focus', 
            'flow': 'Flow State',
            'marathon': 'Marathon',
            'deepwork': 'Deep Work'
        };
        
        const techniqueName = techniqueNames[technique] || 'Advanced Technique';
        
        // Create technique modal using exact same structure as Task limit reached
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'logout-modal-overlay';
        
        const modal = document.createElement('div');
        modal.className = 'logout-modal';
        
        modal.innerHTML = `
            <button class="close-logout-modal-x" id="closeTechniqueModal">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <h3 class="logout-modal-title">${techniqueName}</h3>
            <p class="logout-modal-message">Sign up to unlock advanced focus techniques and boost your productivity!</p>
            <div class="logout-modal-buttons">
                <button class="logout-modal-btn logout-modal-btn-primary" id="techniqueSignupBtn">Sign up for free</button>
                <button class="logout-modal-btn logout-modal-btn-secondary" id="techniqueLearnMoreBtn">Cancel</button>
            </div>
        `;
        
        modalOverlay.appendChild(modal);
        document.body.appendChild(modalOverlay);
        
        // Show modal
        modalOverlay.style.display = 'flex';
        
        // Event listeners
        const closeBtn = modal.querySelector('#closeTechniqueModal');
        const signupBtn = modal.querySelector('#techniqueSignupBtn');
        const learnMoreBtn = modal.querySelector('#techniqueLearnMoreBtn');
        
        const closeModal = () => {
            modalOverlay.remove();
        };
        
        closeBtn.addEventListener('click', closeModal);
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) closeModal();
        });
        
        signupBtn.addEventListener('click', () => {
            this.trackEvent('Signup from Technique Modal', {
                button_type: 'signup',
                source: 'technique_modal',
                technique_name: technique,
                user_type: this.isAuthenticated ? 'free_user' : 'guest',
                conversion_funnel: 'technique_interest'
            });
            closeModal();
            window.location.href = 'https://accounts.superfocus.live/sign-up?redirect_url=https%3A%2F%2Fwww.superfocus.live%2F%3Fsignup%3Dsuccess';
        });
        
        learnMoreBtn.addEventListener('click', () => {
            closeModal();
        });
    }
    
    
    showTaskLimitModal() {
        if (!this.isAuthenticated) {
            // Guest user - show modal with Sign up CTA
            if (this.guestTaskLimitModalOverlay) {
                const button = this.guestTaskLimitModalOverlay.querySelector('#guestTaskLimitSignupBtn');
                if (button) {
                    button.textContent = 'Sign up for free';
                }
                this.guestTaskLimitModalOverlay.style.display = 'flex';
            }
        } else {
            // Free/authenticated user - open pricing modal
            this.showPricingPlansModal();
        }
    }
    
    showGuestTaskLimitModal() {
        if (this.guestTaskLimitModalOverlay) {
            this.guestTaskLimitModalOverlay.style.display = 'flex';
        }
    }
    
    hideGuestTaskLimitModal() {
        if (this.guestTaskLimitModalOverlay) {
            this.guestTaskLimitModalOverlay.style.display = 'none';
        }
    }
    
    // Daily focus limit helpers
    hasReachedDailyFocusLimit() {
        // Pro users are unlimited; guests and free users are limited
        const isLimitedUser = !this.isPremiumUser();
        if (!isLimitedUser) return false;
        // If cooldown is active, limit is reached
        return !!this.focusLimitCooldownUntil && Date.now() < this.focusLimitCooldownUntil;
    }
    
    showDailyLimitModal() {
        if (!this.dailyLimitModalOverlay) return;
        // Always pause and block controls while visible
        this.pauseTimerSilent();
        this.dailyLimitModalOverlay.style.display = 'flex';
        
        // Update focused time display
        const focusHoursUsed = Math.floor((this.focusSecondsToday || 0) / 3600);
        const focusMinutesUsed = Math.floor(((this.focusSecondsToday || 0) % 3600) / 60);
        
        // Update the focused time stat
        const dailyLimitFocusedTime = document.getElementById('dailyLimitFocusedTime');
        if (dailyLimitFocusedTime) {
            if (focusHoursUsed > 0) {
                dailyLimitFocusedTime.textContent = `${focusHoursUsed} hour${focusHoursUsed !== 1 ? 's' : ''}`;
            } else {
                dailyLimitFocusedTime.textContent = `${focusMinutesUsed} min`;
            }
        }
        
        // Title is now static in HTML: "You've maxed out today's focus!"
        // Message is now static in HTML: "Don't let the momentum stop..."
        
        // üéØ Track Daily Limit Modal Opened event to Mixpanel
        if (window.mixpanelTracker) {
            const focusMinutesUsed = Math.floor((this.focusSecondsToday || 0) / 60);
            window.mixpanelTracker.trackCustomEvent('Daily Limit Modal Opened', {
                focus_minutes_used: focusMinutesUsed,
                user_type: this.isAuthenticated ? (this.isPremiumUser() ? 'pro' : 'free_user') : 'guest',
                cooldown_remaining_ms: this.focusLimitCooldownUntil ? Math.max(0, this.focusLimitCooldownUntil - Date.now()) : 0
            });
            console.log('üìä Daily limit modal opened event tracked to Mixpanel');
        }
        // Start countdown updates
        this.startDailyLimitCountdown();
        // Keep controls clickable; Start will re-open modal via guard in startTimer
    }
    
    hideDailyLimitModal() {
        if (!this.dailyLimitModalOverlay) return;
        this.dailyLimitModalOverlay.style.display = 'none';
        this.stopDailyLimitCountdown();
    }
    
    // Pricing Plans Modal
    showPricingPlansModal() {
        if (!this.pricingPlansModalOverlay) return;
        this.pricingPlansModalOverlay.style.display = 'flex';
        // Default to lifetime selected
        this.selectPlan('lifetime');
    }
    
    hidePricingPlansModal() {
        if (!this.pricingPlansModalOverlay) return;
        this.pricingPlansModalOverlay.style.display = 'none';
    }
    
    selectPlan(plan) {
        this.selectedPlan = plan;
        
        // Update check icons visibility
        if (this.monthlyCheckIcon && this.lifetimeCheckIcon) {
            if (plan === 'monthly') {
                this.monthlyCheckIcon.style.display = 'flex';
                this.lifetimeCheckIcon.style.display = 'none';
            } else {
                this.monthlyCheckIcon.style.display = 'none';
                this.lifetimeCheckIcon.style.display = 'flex';
            }
        }
        
        // Update card styles
        if (this.monthlyPlanCard && this.lifetimePlanCard) {
            if (plan === 'monthly') {
                this.monthlyPlanCard.style.background = 'linear-gradient(135deg, rgba(6, 78, 59, 0.3), rgba(6, 78, 59, 0.1))';
                this.monthlyPlanCard.style.border = '2px solid rgba(6, 78, 59, 0.8)';
                this.lifetimePlanCard.style.background = 'rgba(255, 255, 255, 0.05)';
                this.lifetimePlanCard.style.border = '2px solid rgba(255, 255, 255, 0.1)';
            } else {
                this.lifetimePlanCard.style.background = 'linear-gradient(135deg, rgba(6, 78, 59, 0.3), rgba(6, 78, 59, 0.1))';
                this.lifetimePlanCard.style.border = '2px solid rgba(6, 78, 59, 0.8)';
                this.monthlyPlanCard.style.background = 'rgba(255, 255, 255, 0.05)';
                this.monthlyPlanCard.style.border = '2px solid rgba(255, 255, 255, 0.1)';
            }
        }
        
        // Update CTA button text and plan details
        if (this.selectedPlanCTA && this.planDetailsText) {
            if (plan === 'monthly') {
                this.selectedPlanCTA.textContent = 'Subscribe Monthly';
                this.planDetailsText.textContent = 'Cancel anytime';
            } else {
                this.selectedPlanCTA.textContent = 'Get Lifetime Access';
                this.planDetailsText.textContent = 'No subscription ‚Ä¢ One-time payment';
            }
        }
    }
    
    async proceedToCheckout() {
        const planType = this.selectedPlan;
        
        try {
            // Verify user is authenticated
            if (!this.isAuthenticated) {
                console.log('‚ùå User not authenticated, showing sign up prompt');
                alert('Please sign up or log in first to upgrade to Premium.');
                return;
            }
            
            const userEmail = window.Clerk?.user?.primaryEmailAddress?.emailAddress || '';
            const userId = window.Clerk?.user?.id || '';
            
            if (!userId) {
                console.log('‚ùå User ID not found');
                alert('Please sign up or log in first to upgrade to Premium.');
                return;
            }
            
            // Track to Mixpanel
            if (window.mixpanelTracker) {
                window.mixpanelTracker.trackCustomEvent('Subscribe Clicked', {
                    button_type: 'subscribe',
                    source: 'pricing_plans_modal',
                    location: 'pricing_plans_modal',
                    plan_type: planType,
                    user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                    modal_type: 'pricing_plans',
                    timestamp: new Date().toISOString()
                });
                console.log('üìä Pricing modal subscribe clicked event tracked to Mixpanel:', planType);
            }
            
            // Track Subscribe Clicked to Google Ads (intent signal, not final conversion)
            try {
                if (typeof window.gtag === 'function') {
                    // Set Enhanced Conversions user data BEFORE the conversion event
                    if (userEmail && typeof window.hashEmail === 'function') {
                        try {
                            const hashedEmail = await window.hashEmail(userEmail);
                            if (hashedEmail) {
                                window.gtag('set', 'user_data', {
                                    'sha256_email_address': hashedEmail
                                });
                                console.log('‚úÖ Enhanced Conversions: User data set (Subscribe Clicked)');
                            }
                        } catch (error) {
                            console.log('‚ö†Ô∏è Enhanced Conversions: Email hashing failed');
                        }
                    }
                    
                    window.gtag('event', 'conversion', {
                        'send_to': 'AW-17614436696/zsizCNqYgbgbENjym89B',
                        'value': 1.0,
                        'currency': 'USD'
                    });
                    console.log('üìä Google Ads Subscribe Clicked tracked:', planType);
                }
            } catch (error) {
                console.error('‚ö†Ô∏è Google Ads tracking failed:', error);
            }
            
            console.log('üöÄ Creating checkout session for plan:', planType);
            console.log('   User ID:', userId);
            console.log('   User Email:', userEmail);
            
            let adsClickIds = null;
            try {
                adsClickIds = JSON.parse(localStorage.getItem('ads_click_ids') || 'null');
            } catch (error) {
                adsClickIds = null;
            }
            
            const response = await fetch('/api/create-checkout-session', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-clerk-userid': userId
                },
                body: JSON.stringify({
                    planType: planType,
                    userEmail: userEmail,
                    userId: userId,
                    adsClickIds: adsClickIds
                })
            });
            
            console.log('üì° Checkout session response status:', response.status);
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                console.error('‚ùå Checkout session error:', errorData);
                throw new Error(errorData.error || 'Failed to create checkout session');
            }
            
            const data = await response.json();
            console.log('‚úÖ Checkout session created:', data);
            
            if (data.url) {
                // Track Stripe Checkout Session Created to Mixpanel
                if (window.mixpanelTracker) {
                    window.mixpanelTracker.trackCustomEvent('Stripe Checkout Session Created', {
                        source: 'pricing_modal',
                        plan_type: planType,
                        user_email: userEmail,
                        timestamp: new Date().toISOString()
                    });
                    console.log('üìä Stripe Checkout Session Created tracked to Mixpanel:', planType);
                }
                
                // Track Stripe Checkout Session Created to Google Ads
                // This is a key funnel step - user has committed to starting checkout
                try {
                    if (typeof window.gtag === 'function') {
                        // Set Enhanced Conversions user data BEFORE the conversion event
                        if (userEmail && typeof window.hashEmail === 'function') {
                            try {
                                const hashedEmail = await window.hashEmail(userEmail);
                                if (hashedEmail) {
                                    window.gtag('set', 'user_data', {
                                        'sha256_email_address': hashedEmail
                                    });
                                    console.log('‚úÖ Enhanced Conversions: User data set (Checkout Created)');
                                }
                            } catch (error) {
                                console.log('‚ö†Ô∏è Enhanced Conversions: Email hashing failed');
                            }
                        }
                        
                        window.gtag('event', 'conversion', {
                            'send_to': 'AW-17614436696/d75YCJ7Ti8IbENjym89B',
                            'value': 1.0,
                            'currency': 'USD'
                        });
                        console.log('üìä Google Ads Stripe Checkout Session Created tracked:', planType);
                    }
                } catch (error) {
                    console.error('‚ö†Ô∏è Google Ads checkout tracking failed:', error);
                }
                
                // Wait 500ms to ensure Google Ads beacon is sent before redirect
                // This is critical because page unload can cancel pending network requests
                console.log('‚è≥ Waiting for tracking beacons to send...');
                await new Promise(resolve => setTimeout(resolve, 500));
                
                console.log('‚úÖ Redirecting to Stripe checkout:', data.url);
                window.location.href = data.url;
            } else {
                throw new Error('No checkout URL received from server');
            }
        } catch (error) {
            console.error('‚ùå Error in proceedToCheckout:', error);
            console.error('Error details:', {
                message: error.message,
                planType: planType,
                isAuthenticated: this.isAuthenticated
            });
            alert(`There was an error starting the checkout: ${error.message}\n\nPlease try again or contact support.`);
        }
    }

    // Countdown handling for daily limit modal
    startDailyLimitCountdown() {
        if (!this.dailyLimitCountdownEl) return;
        this.stopDailyLimitCountdown();
        const update = () => {
            // If cooldown expired, clear and close
            if (!this.focusLimitCooldownUntil || Date.now() >= this.focusLimitCooldownUntil) {
                this.focusLimitCooldownUntil = 0;
                try { localStorage.removeItem('focusLimitCooldownUntil'); } catch (_) {}
                this.dailyLimitCountdownEl.textContent = '00:00:00';
                this.hideDailyLimitModal();
                return;
            }
            const remainingMs = this.focusLimitCooldownUntil - Date.now();
            this.dailyLimitCountdownEl.textContent = this.formatMsHHMMSS(remainingMs);
        };
        update();
        this.dailyLimitCountdownTimer = setInterval(update, 1000);
    }
    stopDailyLimitCountdown() {
        if (this.dailyLimitCountdownTimer) {
            clearInterval(this.dailyLimitCountdownTimer);
            this.dailyLimitCountdownTimer = null;
        }
    }
    formatMsHHMMSS(ms) {
        const totalSeconds = Math.max(0, Math.floor(ms / 1000));
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        const hh = String(hours).padStart(2, '0');
        const mm = String(minutes).padStart(2, '0');
        const ss = String(seconds).padStart(2, '0');
        return `${hh}:${mm}:${ss}`;
    }
    
    
    
    
    
    
    async submitFeedback() {
        const feedbackText = this.feedbackText?.value?.trim();
        
        if (!feedbackText) {
            alert('Please enter your feedback before submitting.');
            return;
        }

        if (!this.user) {
            alert('Please log in to submit feedback.');
            return;
        }

        try {
            // Store feedback locally for admin panel
            const feedbackData = {
                id: Date.now().toString(),
                feedback: feedbackText,
                userEmail: this.user.primaryEmailAddress?.emailAddress || this.user.emailAddresses?.[0]?.emailAddress,
                userId: this.user.id,
                timestamp: new Date().toISOString(),
                status: 'new'
            };

            // Store in localStorage for admin panel
            let localFeedback = [];
            try {
                const stored = localStorage.getItem('superfocus_feedback');
                if (stored) {
                    localFeedback = JSON.parse(stored);
                }
            } catch (e) {
                localFeedback = [];
            }

            localFeedback.push(feedbackData);
            localStorage.setItem('superfocus_feedback', JSON.stringify(localFeedback));

            // Also send to API for logging
            const response = await fetch('/api/submit-feedback', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    feedback: feedbackText,
                    userEmail: this.user.primaryEmailAddress?.emailAddress || this.user.emailAddresses?.[0]?.emailAddress,
                    userId: this.user.id
                })
            });

            if (response.ok) {
                alert('Thank you for your feedback! We appreciate your input.');
                this.hideFeedbackModal();
            } else {
                // Even if API fails, local storage worked
                alert('Thank you for your feedback! We appreciate your input.');
                this.hideFeedbackModal();
            }
        } catch (error) {
            console.error('Error submitting feedback:', error);
            alert('Sorry, there was an error submitting your feedback. Please try again.');
        }
    }
    
    ensureLogoutButtonBinding() {
        // Ensure logout button is properly bound
        const confirmBtn = document.getElementById('confirmLogoutBtn');
        if (confirmBtn && !confirmBtn.hasAttribute('data-bound')) {
            confirmBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                this.hideLogoutModal();
                await this.performLogout();
            });
            confirmBtn.setAttribute('data-bound', 'true');
        }
        
        const cancelBtn = document.getElementById('cancelLogoutBtn');
        if (cancelBtn && !cancelBtn.hasAttribute('data-bound')) {
            cancelBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.hideLogoutModal();
            });
            cancelBtn.setAttribute('data-bound', 'true');
        }
    }
    
    resetThemeAndMusicForGuest() {
        // Reset theme to minimalist if it's premium
        const currentTheme = localStorage.getItem('selectedTheme');
        // All themes are now available for guests, no reset needed
        
        // Reset music to none if it's premium
        if (this.rainEnabled || this.ambientEnabled) {
            this.stopRainPlaylist();
            this.stopAmbientPlaylist();
            this.rainEnabled = false;
            this.ambientEnabled = false;
            localStorage.setItem('rainEnabled', 'false');
            localStorage.setItem('ambientEnabled', 'false');
        }
        
        // Clear saved timer state (guests don't get session restore)
        sessionStorage.removeItem('timerState');
        
        console.log('üîÑ Reset theme, music, and timer state to guest defaults');
    }

    async performLogout() {
        try {
            // üéØ Track User Logout event to Mixpanel
            if (window.mixpanelTracker) {
                window.mixpanelTracker.trackUserLogout();
                console.log('üìä User logout event tracked to Mixpanel');
            }
            
            // Add loading state to confirm button
            if (this.confirmLogoutBtn) {
                this.confirmLogoutBtn.textContent = 'Logging out...';
                this.confirmLogoutBtn.disabled = true;
            }
            
            // Add fade out effect to the entire page
            document.body.style.transition = 'opacity 0.5s ease-out';
            document.body.style.opacity = '0.3';
            
            // Wait a moment for the fade effect
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Mark that user just logged out to prevent re-hydration and welcome modal
            try { sessionStorage.setItem('just_logged_out', 'true'); } catch (_) {}
            // Force clear any forced view mode and premium hints
            try {
                localStorage.removeItem('viewMode');
                localStorage.removeItem('hasAccount');
                localStorage.setItem('isPremium', 'false');
                localStorage.setItem('hasPaidSubscription', 'false');
            } catch (_) {}
            
            // üî• CRITICAL: Backup data before clearing to prevent data loss
            try {
                console.log('üì§ Backing up user data before logout...');
                
                // Get user-specific keys before clearing user reference
                const userId = this.user?.id;
                
                // Perform full backup to Clerk before clearing local data
                if (userId && this.isAuthenticated) {
                    try {
                        const stats = this.getFocusStats();
                        if (stats && stats.totalHours > 0) {
                            console.log('üì§ Performing final data backup to server...');
                            await this.syncStatsToClerk(stats.totalHours, true);
                            console.log('‚úÖ Final backup completed');
                        }
                    } catch (backupError) {
                        console.error('‚ö†Ô∏è Backup failed, but continuing with logout:', backupError);
                    }
                }
                
                console.log('üßπ Cleaning user data on logout...');
                
                // Clear focus statistics (both user-specific and generic)
                if (userId) {
                    localStorage.removeItem(`focusStats_${userId}`);
                    localStorage.removeItem(`focusSecondsToday_${userId}`);
                    localStorage.removeItem(`focusSecondsTodayDate_${userId}`);
                }
                localStorage.removeItem('focusStats');
                localStorage.removeItem('focusSecondsToday');
                localStorage.removeItem('focusSecondsTodayDate');
                localStorage.removeItem('focusLimitCooldownUntil');
                
                // Clear streak data
                localStorage.removeItem('streakData');
                
                // Clear saved timer configurations (user-specific)
                localStorage.removeItem('pomodoroTime');
                localStorage.removeItem('shortBreakTime');
                localStorage.removeItem('longBreakTime');
                
                // Clear task data (note: actual tasks are in 'localTasks', keeping that)
                localStorage.removeItem('tasks');
                
                // Clear integration tokens (security - must clear these)
                localStorage.removeItem('todoistToken');
                localStorage.removeItem('notionToken');
                
                // NOTE: We NO LONGER clear customTechniques and customCassettes
                // They are backed up to server and will be shown disabled when logged out
                // This provides better UX as users can see their creations (like Tasks do)
                // localStorage.removeItem('customTechniques');
                // localStorage.removeItem('customCassettes');
                
                // Clear saved technique selection
                localStorage.removeItem('savedTechnique');
                
                console.log('‚úÖ User data cleaned successfully (backup was sent to server)');
            } catch (err) {
                console.error('‚ö†Ô∏è Error cleaning user data:', err);
            }
            
            // Sign out from Clerk (all sessions) without adding extra query params FIRST
            try {
                await window.Clerk.signOut({ signOutAll: true });
            } catch (_) { /* ignore */ }

            // Now optimistic UI update to guest mode
            this.isAuthenticated = false;
            this.user = null;
            // Local tasks only - no integration cleanup needed
            
            // Don't reset theme and music - keep them visible but disabled for logged out users
            // Only clear saved timer state (guests don't get session restore)
            sessionStorage.removeItem('timerState');
            
            this.updateAuthState();

            // Clean Clerk params and hard reload the page without query string
            this.stripClerkParamsFromUrl();
            const cleanUrl = `${window.location.origin}${window.location.pathname}`;
            window.location.replace(cleanUrl);
        } catch (err) {
            console.error('Logout failed:', err);
            // Reset button state on error
            if (this.confirmLogoutBtn) {
                this.confirmLogoutBtn.textContent = 'Log out';
                this.confirmLogoutBtn.disabled = false;
            }
            // Reset page opacity
            document.body.style.opacity = '1';
        }
    }
    
    async handleLogin() {
        try {
            // Force check auth state before deciding what to do
            await this.waitForClerk();
            this.checkAuthState();
            
            // Double-check with Clerk directly
            const clerkUser = window.Clerk?.user;
            const clerkSession = window.Clerk?.session;
            
            if (this.isAuthenticated && (clerkUser || clerkSession)) {
                console.log('User is authenticated, showing logout confirmation...');
                this.showLogoutModal();
            } else {
                console.log('User not authenticated, redirecting to Clerk hosted Sign In...');
                
                // üéØ Track Login Attempt event to Mixpanel
                if (window.mixpanelTracker) {
                    window.mixpanelTracker.trackCustomEvent('Login Attempt', {
                        method: 'clerk_redirect'
                    });
                    console.log('üìä Login attempt event tracked to Mixpanel');
                }
                
                // Fixed redirect to homepage as requested
                window.location.href = 'https://accounts.superfocus.live/sign-in?redirect_url=' + encodeURIComponent('https://www.superfocus.live/');
            }
        } catch (error) {
            console.error('Login/logout failed:', error);
        }
    }

    async handleSignup() {
        try {
            // Check if user is already authenticated before redirecting to signup
            await this.waitForClerk();
            this.checkAuthState();
            
            if (this.isAuthenticated && this.user) {
                console.log('User is already authenticated, not redirecting to signup');
                // Update UI to reflect authenticated state
                this.updateAuthState();
                return;
            }
            
            console.log('Redirecting to Clerk hosted Sign Up...');
            
            // üéØ Track Signup Attempt event to Mixpanel
            if (window.mixpanelTracker) {
                window.mixpanelTracker.trackCustomEvent('Signup Attempt', {
                    method: 'clerk_redirect'
                });
                console.log('üìä Signup attempt event tracked to Mixpanel');
            }
            
            // Redirect to signup with success URL that includes signup=success parameter
            const successUrl = 'https://www.superfocus.live/?signup=success';
            const signupUrl = 'https://accounts.superfocus.live/sign-up?redirect_url=' + encodeURIComponent(successUrl);
            window.location.assign(signupUrl);
        } catch (error) {
            console.error('Sign up failed:', error);
        }
    }


    updateTechniqueTitle() {
        const saved = localStorage.getItem('selectedTechnique');
        let label = 'Pomodoro';
        
        if (saved) {
            // Handle custom techniques
            if (saved.startsWith('custom_')) {
                const customId = saved.replace('custom_', '');
                try {
                    const techniques = JSON.parse(localStorage.getItem('customTechniques') || '[]');
                    const customTechnique = techniques.find(t => t.id === customId);
                    if (customTechnique) {
                        label = customTechnique.name;
                    }
                } catch (_) {}
            } else {
                const map = {
                    'pomodoro': 'Pomodoro',
                    'sprint': 'Sprint',
                    'focus': 'Focus',
                    'flow': 'Flow State',
                    'marathon': 'Marathon',
                    'deepwork': 'Deep Work',
                    'custom': (document.querySelector('[data-technique="custom"] .item-title')?.textContent || 'Custom')
                };
                label = map[saved] || 'Pomodoro';
            }
        }
        
        // Update sidebar technique title
        if (this.techniqueTitle) {
            this.techniqueTitle.innerHTML = `${label}<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down-icon lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg>`;
        }
        
        // Update timer technique button (center top)
        if (this.timerTechniqueName) {
            this.timerTechniqueName.textContent = label;
        }
    }
    
    toggleDropdown() {
        if (this.techniqueDropdown) {
            this.techniqueDropdown.classList.toggle('open');
        }
    }
    
    closeDropdown() {
        if (this.techniqueDropdown) {
            this.techniqueDropdown.classList.remove('open');
        }
    }
    
    selectTechnique(item) {
        if (!item) return;
        const technique = item.dataset ? item.dataset.technique : undefined;
        // Try both .item-title and .technique-name for different UI elements
        let titleEl = item.querySelector ? item.querySelector('.item-title') : null;
        if (!titleEl) {
            titleEl = item.querySelector ? item.querySelector('.technique-name') : null;
        }
        const title = titleEl ? (titleEl.textContent || '') : '';
        if (!technique) return;
        const requiresAccount = item.dataset.requiresAccount === 'true';
        
        // Check if technique requires account and user is not authenticated
        if (requiresAccount && !this.isAuthenticated) {
            // Close dropdown
            this.closeDropdown();
            
            // Redirect to Clerk signup/login
            this.handleSignup();
            
            // Don't change technique
            return;
        }
        
        // Update the button text (sidebar)
        // Update both sidebar and timer technique button with proper capitalized name
        this.updateTimerTechniqueButton(technique);
        
        // Update selected state
        if (this.dropdownItems && this.dropdownItems.forEach) {
            this.dropdownItems.forEach(dropdownItem => {
                dropdownItem.classList.remove('selected');
            });
        }
        if (item.classList) item.classList.add('selected');
        
        // Save selected technique to localStorage
        localStorage.setItem('selectedTechnique', technique);
        
        // Close dropdown
        this.closeDropdown();
        
        // Here you could implement different timer configurations based on technique
        this.loadTechnique(technique);
        
        // Sync the settings panel with the selected technique
        this.syncSettingsPanelTechnique(technique);
    }
    
    // Helper function to build cycle sections dynamically based on sessionsPerCycle
    buildCycleSections() {
        this.cycleSections = [];
        for (let i = 0; i < this.sessionsPerCycle; i++) {
            // Add work session
            this.cycleSections.push({
                type: 'work',
                duration: this.workTime,
                name: `Focus ${i + 1}`
            });
            
            // Add break after work session
            if (i < this.sessionsPerCycle - 1) {
                // Not the last session, add short break
                this.cycleSections.push({
                    type: 'break',
                    duration: this.shortBreakTime,
                    name: `Break ${i + 1}`
                });
            } else {
                // Last session - add long break if configured, otherwise short break
                if (this.longBreakTime > 0) {
                    this.cycleSections.push({
                        type: 'long-break',
                        duration: this.longBreakTime,
                        name: 'Long Break'
                    });
                } else {
                    this.cycleSections.push({
                        type: 'break',
                        duration: this.shortBreakTime,
                        name: `Break ${i + 1}`
                    });
                }
            }
        }
    }

    loadTechnique(technique) {
        // Avoid redundant loads
        if (this.currentTechniqueKey === technique) {
            return;
        }

        // Different timer configurations based on technique
        switch(technique) {
            case 'sprint':
                this.workTime = 15 * 60;
                this.shortBreakTime = 3 * 60;
                this.longBreakTime = 10 * 60;
                this.sessionsPerCycle = 4;
                this.buildCycleSections();
                break;
            case 'pomodoro':
                this.workTime = 25 * 60;
                this.shortBreakTime = 5 * 60;
                this.longBreakTime = 15 * 60;
                this.sessionsPerCycle = 4;
                this.buildCycleSections();
                break;
            case 'focus':
                this.workTime = 30 * 60;
                this.shortBreakTime = 6 * 60;
                this.longBreakTime = 20 * 60;
                this.sessionsPerCycle = 4;
                this.buildCycleSections();
                break;
            case 'flow':
                this.workTime = 45 * 60;
                this.shortBreakTime = 8 * 60;
                this.longBreakTime = 25 * 60;
                this.sessionsPerCycle = 4;
                this.buildCycleSections();
                break;
            case 'marathon':
                this.workTime = 60 * 60;
                this.shortBreakTime = 10 * 60;
                this.longBreakTime = 30 * 60;
                this.sessionsPerCycle = 4;
                this.buildCycleSections();
                break;
            case 'deepwork':
                this.workTime = 90 * 60;
                this.shortBreakTime = 20 * 60;
                this.longBreakTime = 30 * 60;
                this.sessionsPerCycle = 2;
                this.buildCycleSections();
                break;
            case 'custom':
                // Load and apply saved custom configuration
                try {
                    const savedCustomTimer = localStorage.getItem('customTimer');
                    if (savedCustomTimer) {
                        const customConfig = JSON.parse(savedCustomTimer);
                        this.loadCustomTechnique(customConfig);
                        this.currentTechniqueKey = technique; // UI/state handled by loadCustomTechnique
                        return;
                    }
                } catch (_) {
                    try { localStorage.removeItem('customTimer'); } catch (_) {}
                }
                // No valid config; keep current technique until user configures
                return;
        }
        
        // Track applied technique key to short-circuit future loads
        this.currentTechniqueKey = technique;
        
        // Calculate required focus time for complete cycle
        this.calculateRequiredFocusTime();
        
        // Update progress ring to match new technique
        this.updateProgressRing();
        
        // Reset timer with new configuration
        this.pauseTimerSilent();
        this.currentSection = 1;
        this.loadCurrentSection();
        
        // Update session dots
        this.updateSessionDots();
        this.updateNavigationButtons();
        this.updateSessionInfo();
    }

    calculateRequiredFocusTime() {
        // Calculate total focus time required for a complete cycle
        this.requiredFocusTimeForCycle = 0;
        this.cycleSections.forEach(section => {
            if (section.type === 'work') {
                this.requiredFocusTimeForCycle += section.duration;
            }
        });
    }

    updateProgressRing() {
        // Get the progress segments container
        const progressSegments = document.querySelector('.progress-segments');
        if (!progressSegments) return;
        
        // Preserve existing opacity before clearing
        const existingOpacity = progressSegments.style.opacity || '';
        
        // Clear existing segments
        progressSegments.innerHTML = '';
        
        // Create all 8 segments for the complete cycle
        this.cycleSections.forEach((section, index) => {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('class', `progress-segment ${section.type === 'work' ? 'work-segment' : section.type === 'long-break' ? 'long-break-segment' : 'break-segment'}`);
            circle.setAttribute('data-section', (index + 1).toString());
            circle.setAttribute('data-minutes', Math.floor(section.duration / 60).toString());
            circle.setAttribute('cx', '50');
            circle.setAttribute('cy', '50');
            circle.setAttribute('r', '45');
            circle.setAttribute('fill', 'none');
            circle.setAttribute('stroke-width', '4');
                circle.setAttribute('stroke', 'url(#liquidGlassOverlay)');
            
            progressSegments.appendChild(circle);
        });
            
        // Restore opacity if it existed
        if (existingOpacity) {
            progressSegments.style.opacity = existingOpacity;
        }
        
        // Update overlays: create overlays for each section (dynamic based on cycleSections)
        const progressOverlays = document.querySelector('.progress-overlays');
        if (progressOverlays) {
            // Preserve existing opacity before clearing
            const existingOverlayOpacity = progressOverlays.style.opacity || '';
            
            progressOverlays.innerHTML = '';
            
            // Create overlays for each section (dynamic count based on cycleSections)
            const totalSections = this.cycleSections.length;
            for (let i = 1; i <= totalSections; i++) {
                const overlay = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                overlay.setAttribute('class', 'progress-overlay');
                overlay.setAttribute('data-ol', i.toString());
                overlay.setAttribute('cx', '50');
                overlay.setAttribute('cy', '50');
                overlay.setAttribute('r', '45');
                overlay.setAttribute('fill', 'none');
                overlay.setAttribute('stroke-width', '4');
                overlay.setAttribute('stroke-linecap', 'round');
                overlay.setAttribute('stroke-linejoin', 'round');
                overlay.setAttribute('stroke', 'url(#liquidGlassOverlay)');
                progressOverlays.appendChild(overlay);
            }
                
            // Restore opacity if it existed
            if (existingOverlayOpacity) {
                progressOverlays.style.opacity = existingOverlayOpacity;
            }
        }
        
        // Refresh cached NodeLists so subsequent layout uses the new elements
        this.progressSegments = document.querySelectorAll('.progress-segment');
        this.progressOverlays = document.querySelectorAll('.progress-overlay');

        // Re-layout segments with new configuration and update progress visuals
        this.layoutSegments();
        this.updateProgress();
    }

    // Minimal layout: ensure background circle is full and store circumference
    layoutSegments() {
        const CIRCUMFERENCE = 2 * Math.PI * 45; // 283
        this._segmentMeta = { CIRCUMFERENCE };

        // Ensure any existing background circle is a FULL circle (no dasharray)
        const bgSegments = document.querySelectorAll('.progress-segment');
        bgSegments.forEach(seg => {
            seg.removeAttribute('stroke-dasharray');
            seg.removeAttribute('stroke-dashoffset');
            seg.style.display = 'inline';
        });
    }
    bindEvents() {
        // Primary binding for Play/Pause button (original behavior)
        if (this.startPauseBtn) this.startPauseBtn.addEventListener('click', () => {
            this.trackEvent('Start Button Clicked', {
                button_type: 'start_pause',
                timer_state: this.isRunning ? 'running' : 'paused',
                current_section: this.currentSection
            });
            this.toggleTimer();
        });
        if (this.prevSectionBtn) this.prevSectionBtn.addEventListener('click', () => this.goToPreviousSection());
        if (this.nextSectionBtn) this.nextSectionBtn.addEventListener('click', () => this.goToNextSection());
        if (this.musicToggleBtn) this.musicToggleBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.toggleMusic();
        });
        if (this.taskToggleBtn) this.taskToggleBtn.addEventListener('click', () => this.toggleTaskList());
        if (this.sessionLabelElement) this.sessionLabelElement.addEventListener('click', () => this.toggleTaskList());
        if (this.techniqueTitle) this.techniqueTitle.addEventListener('click', () => this.toggleDropdown());
        if (this.timerTechniqueBtn) {
            this.timerTechniqueBtn.addEventListener('click', () => {
                // Track event
                this.trackEvent('Timer Settings Clicked', {
                    button_type: 'timer_technique',
                    source: 'timer_header'
                });
                
                // Check if we're on mobile/tablet (< 1200px)
                if (window.innerWidth < 1200) {
                    // Use bottom sheet on mobile
                    if (window.sidebarManager && typeof window.sidebarManager.openPanel === 'function') {
                        window.sidebarManager.openPanel('settings');
                    }
                } else {
                    // Open Timer settings panel by clicking nav item on desktop
                    const settingsNavItem = document.querySelector('.nav-item[data-section="settings"]');
                    if (settingsNavItem) {
                        settingsNavItem.click();
                    }
                }
            });
        }
        
        // Subscribe button event listener
        const subscribeBtn = document.getElementById('subscribeBtn');
        if (subscribeBtn) {
            subscribeBtn.addEventListener('click', () => {
                const eventProperties = {
                    button_type: 'subscribe',
                    source: 'timer_header',
                    user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                    location: 'timer_header'
                };
                this.trackEvent('Subscribe Clicked', eventProperties);
                
                this.showPricingPlansModal();
            });
        }

        if (this.leaderboardRefreshBtn) {
            this.leaderboardRefreshBtn.addEventListener('click', () => {
                this.refreshLeaderboardSnapshot();
            });
        }

        // Streak button event listener
        const streakButtons = document.querySelectorAll('.streak-info');
        streakButtons.forEach((streakInfo) => {
            streakInfo.addEventListener('click', () => {
                this.trackEvent('Report Clicked', {
                    button_type: 'report',
                    source: 'timer_header'
                });
                
                // Check if we're on mobile/tablet (< 1200px)
                if (window.innerWidth < 1200) {
                    // Use bottom sheet on mobile
                    if (window.sidebarManager && typeof window.sidebarManager.openPanel === 'function') {
                        window.sidebarManager.openPanel('report');
                    }
                } else {
                    // Show modal on desktop
                    this.showStreakInfo();
                }
            });
        });
        
        // Timer Settings button event listeners (footer legacy)
        const timerSettingsBtn = document.getElementById('timerSettingsBtn');
        if (timerSettingsBtn) {
            timerSettingsBtn.addEventListener('click', () => this.showTimerSettingsModal());
        }
        
        // Header Settings dropdown toggle
        if (this.headerSettingsBtn) {
            this.headerSettingsBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Track account button click in Google Analytics
                if (typeof gtag !== 'undefined') {
                    gtag('event', 'account_button_click', {
                        'event_category': 'navigation',
                        'event_label': 'account_settings',
                        'value': 1
                    });
                    console.log('üìä Account button click tracked');
                }
                
                if (this.settingsDropdown) {
                    const isShown = this.settingsDropdown.style.display === 'block';
                    // Close user profile dropdown if open
                    if (this.userProfileDropdown) {
                        this.userProfileDropdown.style.display = 'none';
                    }
                    // Close help panel when closing settings dropdown
                    if (!isShown && this.helpPanel) {
                        this.helpPanel.style.display = 'none';
                    }
                    this.settingsDropdown.style.display = isShown ? 'none' : 'block';
                }
            });
        }
        
        // Settings dropdown - Login button
        if (this.settingsLoginBtn) {
            this.settingsLoginBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.trackEvent('Account Menu Login Clicked', {
                    button_type: 'login',
                    source: 'account_menu'
                });
                this.settingsDropdown.style.display = 'none';
                this.handleLogin();
            });
        }
        
        // Settings dropdown - Signup button
        if (this.settingsSignupBtn) {
            this.settingsSignupBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.trackEvent('Account Menu Signup Clicked', {
                    modal_type: 'account_menu',
                    button_type: 'signup',
                    source: 'account_menu'
                });
                this.settingsDropdown.style.display = 'none';
                this.handleSignup();
            });
        }
        
        // Settings dropdown - Shortcuts
        if (this.shortcutsItem) {
            this.shortcutsItem.addEventListener('click', (e) => {
                e.preventDefault();
                this.trackEvent('Account Menu Help Clicked', {
                    button_type: 'help',
                    source: 'account_menu',
                    help_option: 'shortcuts'
                });
                this.settingsDropdown.style.display = 'none';
                this.showShortcutsModal();
            });
        }
        
        // Settings dropdown - Upgrade to Pro
        if (this.settingsUpgradeToProBtn) {
            this.settingsUpgradeToProBtn.addEventListener('click', (e) => {
                e.preventDefault();
                
                // Track Profile menu Upgrade to Pro click
                const eventProperties = {
                    button_type: 'subscribe',
                    source: 'profile_dropdown',
                    location: 'settings_dropdown',
                    user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                    modal_type: 'profile_menu'
                };
                this.trackEvent('Subscribe Clicked', eventProperties);
                
                this.settingsDropdown.style.display = 'none';
                this.showPricingPlansModal();
            });
        }
        
        // Settings dropdown - Manage Subscription
        if (this.settingsManageSubscriptionBtn) {
            this.settingsManageSubscriptionBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.settingsDropdown.style.display = 'none';
                this.handleManageSubscription();
            });
        }
        
        // Settings dropdown - Account
        if (this.settingsAccountBtn) {
            this.settingsAccountBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.trackEvent('Account Menu Account Clicked', {
                    button_type: 'account',
                    source: 'account_menu'
                });
                this.settingsDropdown.style.display = 'none';
                this.showSettingsModal();
            });
        }
        
        // Settings dropdown - Leaderboard
        // Close Leaderboard Modal
        const closeLeaderboardModal = document.getElementById('closeLeaderboardModal');
        if (closeLeaderboardModal) {
            closeLeaderboardModal.addEventListener('click', () => {
                this.hideLeaderboardModal();
            });
        }
        
        // Close modal when clicking overlay
        if (this.leaderboardModalOverlay) {
            this.leaderboardModalOverlay.addEventListener('click', (e) => {
                if (e.target === this.leaderboardModalOverlay) {
                    this.hideLeaderboardModal();
                }
            });
        }
        
        // Settings dropdown - Productivity Resources
        if (this.productivityResourcesBtn) {
            this.productivityResourcesBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.trackEvent('Productivity Resources Clicked', {
                    button_type: 'productivity_resources',
                    source: 'account_menu'
                });
                this.settingsDropdown.style.display = 'none';
                this.showProductivityResourcesModal();
            });
        }
        
        // Close Productivity Resources Modal
        const closeProductivityResourcesModal = document.getElementById('closeProductivityResourcesModal');
        if (closeProductivityResourcesModal) {
            closeProductivityResourcesModal.addEventListener('click', () => {
                this.hideProductivityResourcesModal();
            });
        }
        
        // Close modal when clicking overlay
        if (this.productivityResourcesModalOverlay) {
            this.productivityResourcesModalOverlay.addEventListener('click', (e) => {
                if (e.target === this.productivityResourcesModalOverlay) {
                    this.hideProductivityResourcesModal();
                }
            });
        }
        
        // Settings dropdown - Integrations (removed from menu, now only in Account)
        // if (this.settingsIntegrationsBtn) {
        //     this.settingsIntegrationsBtn.addEventListener('click', (e) => {
        //         e.preventDefault();
        //         this.settingsDropdown.style.display = 'none';
        //         this.showIntegrationsModal();
        //     });
        // }
        
        // Settings dropdown - Report (Guest) - REMOVED
        // Guest users can now use the streak-info button directly
        // if (this.settingsStatisticsGuestBtn) {
        //     this.settingsStatisticsGuestBtn.addEventListener('click', (e) => {
        //         e.preventDefault();
        //         this.settingsDropdown.style.display = 'none';
        //         this.showGuestFocusReportTeaser();
        //     });
        // }
        
        // Settings dropdown - Feedback
        if (this.settingsFeedbackBtn) {
            this.settingsFeedbackBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.trackEvent('Account Menu Help Clicked', {
                    button_type: 'help',
                    source: 'account_menu',
                    help_option: 'feedback'
                });
                this.settingsDropdown.style.display = 'none';
                this.showFeedbackModal();
            });
        }
        
        // Settings dropdown - Help Toggle
        if (this.helpToggle) {
            this.helpToggle.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (this.helpPanel) {
                    const isOpen = this.helpPanel.style.display === 'block';
                    this.helpPanel.style.display = isOpen ? 'none' : 'block';
                }
            });
        }
        
        // Close help panel when clicking outside
        document.addEventListener('click', (e) => {
            if (this.helpPanel && this.helpPanel.style.display === 'block') {
                if (!this.helpPanel.contains(e.target) && !this.helpToggle.contains(e.target)) {
                    this.helpPanel.style.display = 'none';
                }
            }
        });
        
        // Settings dropdown - Logout
        if (this.settingsLogoutBtn) {
            this.settingsLogoutBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.settingsDropdown.style.display = 'none';
                this.showLogoutModal();
            });
        }
        
        // Custom timer event listeners
        if (this.closeCustomTimer) this.closeCustomTimer.addEventListener('click', () => this.hideCustomTimerModal());
        if (this.cancelCustomTimer) this.cancelCustomTimer.addEventListener('click', () => this.hideCustomTimerModal());
        if (this.saveCustomTimer) this.saveCustomTimer.addEventListener('click', () => this.saveCustomTimerConfig());
        
        // Custom timer form inputs
        const customInputs = ['customName', 'focusTime', 'breakTime', 'longBreakTime', 'cycles'];
        customInputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                input.addEventListener('input', () => {
                    // Optional: Add any real-time validation here
                });
            }
        });
        
        // Close dropdown when clicking outside (but ignore technique info modal)
        document.addEventListener('click', (e) => {
            // If click is inside the technique info modal, do nothing
            const inTechniqueInfo = e.target.closest && e.target.closest('.technique-info-overlay');
            if (inTechniqueInfo) return;

            if (this.techniqueDropdown && !this.techniqueDropdown.contains(e.target)) {
                this.closeDropdown();
            }
        });
        
        // Handle dropdown item selection
        this.dropdownItems.forEach(item => {
            item.addEventListener('click', (e) => {
                // Don't select technique if clicking on learn more link
                if (e.target.classList.contains('learn-more-link')) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.showTechniqueInfo(e.target.dataset.technique);
                    return;
                }

                // Don't select technique if clicking on login button
                if (e.target.classList.contains('login-btn')) {
                    e.preventDefault();
                    e.stopPropagation();
                const technique = item.getAttribute('data-technique');
                    this.showLoginRequiredModal(technique);
                    return;
                }

                const technique = item.getAttribute('data-technique');
                
                // Check if technique requires authentication
                const proTechniques = ['custom'];
                if (proTechniques.includes(technique) && !this.isPremiumUser()) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.showLoginRequiredModal(technique);
                    return;
                }
                
                if (technique === 'custom') {
                    e.preventDefault();
                    e.stopPropagation();
                    this.handleCustomTechniqueClick(item);
                    return;
                }
                this.selectTechnique(item);
            });
        });
        
        // Handle login buttons for advanced techniques
        this.setupLoginButtons();
        
        // Initialize dropdown items state after auth state is determined
        setTimeout(() => {
            this.initializeDropdownItemsState();
        }, 100);
        
        // Force update dropdown state after auth is fully determined
        setTimeout(() => {
            this.updateDropdownItemsState();
        }, 500);
        
        
        // Handle keyboard shortcuts
        document.addEventListener('keydown', (e) => this.handleKeydown(e));

        // Improve scroll performance by pausing heavy animations while scrolling
        let scrollTimeoutId = null;
        window.addEventListener('scroll', () => {
            document.body.classList.add('is-scrolling');
            if (scrollTimeoutId) {
                clearTimeout(scrollTimeoutId);
            }
            scrollTimeoutId = setTimeout(() => {
                document.body.classList.remove('is-scrolling');
            }, 150);
        }, { passive: true });
        
        // Handle login button
        if (this.loginButton) {
            this.loginButton.addEventListener('click', (e) => {
                e.preventDefault();
                this.trackEvent('Login Button Clicked', {
                    button_type: 'login',
                    source: 'main_header'
                });
                this.handleLogin();
            });
        }
        
        // Handle signup button
        if (this.signupButton) {
            this.signupButton.addEventListener('click', (e) => {
                e.preventDefault();
                this.trackEvent('Signup Button Clicked', {
                    modal_type: 'main_header',
                    button_type: 'signup',
                    source: 'main_header'
                });
                this.handleSignup();
            });
        }
        
        // Profile dropdown click behavior
        if (this.userProfileButton) {
            this.userProfileButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (this.userProfileDropdown) {
                    const isShown = this.userProfileDropdown.style.display === 'block';
                    this.userProfileDropdown.style.display = isShown ? 'none' : 'block';
                }
            });
        }

        // Achievement badge click - show focus stats in a simple way
        if (this.achievementIcon) {
            this.achievementIcon.addEventListener('click', (e) => {
                e.preventDefault();
                this.showSimpleFocusStats();
            });
        }

        // Logo click - redirect to home
        if (this.logoIcon) {
            this.logoIcon.addEventListener('click', (e) => {
                e.preventDefault();
                this.trackEvent('Logo Clicked', {
                    button_type: 'logo',
                    destination: 'homepage'
                });
                window.location.href = 'https://superfocus.live';
            });
        }

        // Modal close buttons
        const closeUpgradeX = document.querySelector('.close-upgrade-x');
        if (closeUpgradeX) {
            closeUpgradeX.addEventListener('click', () => this.hideUpgradeModal());
        }

        const closeSettingsX = document.querySelector('.close-settings-x');
        if (closeSettingsX) {
            closeSettingsX.addEventListener('click', () => this.hideSettingsModal());
        }

        const closePricingX = document.querySelector('.close-pricing-x');
        if (closePricingX) {
            closePricingX.addEventListener('click', () => this.hidePricingModal());
        }

        // Close modals when clicking overlay
        const upgradeModal = document.getElementById('upgradeModal');
        if (upgradeModal) {
            upgradeModal.addEventListener('click', (e) => {
                if (e.target === upgradeModal) {
                    this.hideUpgradeModal();
                }
            });
        }

        // Settings modal tab navigation
        this.setupSettingsTabs();
        
        // View mode toggle buttons
        this.setupViewModeButtons();
        
        // Check if user is admin and show/hide Developer tab
        this.checkAdminAccess();

        // Upgrade button
        const upgradeBtn = document.querySelector('.upgrade-btn');
        if (upgradeBtn) {
            upgradeBtn.addEventListener('click', async () => {
                try {
                    let userId = '';
                    let userEmail = '';
                    try {
                        if (window.Clerk && window.Clerk.user) {
                            userId = window.Clerk.user.id || '';
                            userEmail = (window.Clerk.user.primaryEmailAddress?.emailAddress || window.Clerk.user.emailAddresses?.[0]?.emailAddress || '') + '';
                        }
                    } catch (_) {}

                    // If user is not logged in, show login prompt
                    if (!userId && !userEmail) {
                        alert('Please log in first to upgrade to Pro. Click "Sign up for free" or "Login" to continue.');
                        return;
                    }

                    // Redirect to pricing page first so users see full value proposition
                    window.location.href = '/pricing';
                } catch (err) {
                    console.error('Error in upgrade flow:', err);
                    // Fallback to pricing page even on error
                    window.location.href = '/pricing';
                }
            });
        }

        // Upgrade modal Cancel button
        const upgradeCancelBtn = document.getElementById('upgradeCancelBtn');
        if (upgradeCancelBtn) {
            upgradeCancelBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.hideUpgradeModal();
            });
        }

        const settingsModal = document.getElementById('settingsModal');
        if (settingsModal) {
            settingsModal.addEventListener('click', (e) => {
                if (e.target === settingsModal) {
                    this.hideSettingsModal();
                }
            });
        }
        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            if (this.userProfileDropdown) this.userProfileDropdown.style.display = 'none';
            if (this.settingsDropdown) this.settingsDropdown.style.display = 'none';
            if (this.helpPanel) this.helpPanel.style.display = 'none';
        });
        
        // Logout action
        if (this.logoutButton) {
            this.logoutButton.addEventListener('click', (e) => {
                e.preventDefault();
                this.showLogoutModal();
            });
        }

        // Wire daily limit modal buttons
        if (this.dailyLimitSubscribeBtn && !this.dailyLimitSubscribeBtn.hasAttribute('data-bound')) {
            this.dailyLimitSubscribeBtn.setAttribute('data-bound', 'true');
            this.dailyLimitSubscribeBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.hideDailyLimitModal();
                // üéØ Track Daily Limit Subscribe Click event to Mixpanel
                if (window.mixpanelTracker) {
                    const focusMinutesUsed = Math.floor((this.focusSecondsToday || 0) / 60);
                    window.mixpanelTracker.trackCustomEvent('Daily Limit Subscribe Clicked', {
                        focus_minutes_used: focusMinutesUsed,
                        user_type: this.isAuthenticated ? (this.isPremiumUser() ? 'pro' : 'free_user') : 'guest',
                        cooldown_remaining_ms: this.focusLimitCooldownUntil ? Math.max(0, this.focusLimitCooldownUntil - Date.now()) : 0,
                        source: 'daily_limit_modal'
                    });
                    console.log('üìä Daily limit subscribe clicked event tracked to Mixpanel');
                }
                try {
                    const eventProperties = {
                        button_type: 'subscribe',
                        source: 'daily_limit_modal',
                        user_type: this.isAuthenticated ? (this.isPremiumUser() ? 'pro' : 'free_user') : 'guest'
                    };
                    this.trackEvent && this.trackEvent('Subscribe Clicked', eventProperties);
                } catch (_) {}
                this.showPricingPlansModal();
            });
        }
        
        // If user already at limit when loading, ensure modal will show on Start (we don't disable Start)
        if (this.dailyLimitLaterBtn && !this.dailyLimitLaterBtn.hasAttribute('data-bound')) {
            this.dailyLimitLaterBtn.setAttribute('data-bound', 'true');
            this.dailyLimitLaterBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.hideDailyLimitModal();
            });
        }
        if (this.closeDailyLimitModalX && !this.closeDailyLimitModalX.hasAttribute('data-bound')) {
            this.closeDailyLimitModalX.setAttribute('data-bound', 'true');
            this.closeDailyLimitModalX.addEventListener('click', (e) => {
                e.preventDefault();
                this.hideDailyLimitModal();
            });
        }

        // Pricing Plans Modal
        this.pricingPlansModalOverlay = document.getElementById('pricingPlansModalOverlay');
        this.closePricingPlansModalX = document.getElementById('closePricingPlansModalX');
        this.monthlyPlanCard = document.getElementById('monthlyPlanCard');
        this.lifetimePlanCard = document.getElementById('lifetimePlanCard');
        this.monthlyCheckIcon = document.getElementById('monthlyCheckIcon');
        this.lifetimeCheckIcon = document.getElementById('lifetimeCheckIcon');
        this.selectedPlanCTA = document.getElementById('selectedPlanCTA');
        this.planDetailsText = document.getElementById('planDetailsText');
        this.selectedPlan = 'lifetime'; // Default to lifetime
        
        if (this.closePricingPlansModalX && !this.closePricingPlansModalX.hasAttribute('data-bound')) {
            this.closePricingPlansModalX.setAttribute('data-bound', 'true');
            this.closePricingPlansModalX.addEventListener('click', (e) => {
                e.preventDefault();
                this.hidePricingPlansModal();
            });
        }
        
        if (this.monthlyPlanCard && !this.monthlyPlanCard.hasAttribute('data-bound')) {
            this.monthlyPlanCard.setAttribute('data-bound', 'true');
            this.monthlyPlanCard.addEventListener('click', () => {
                this.selectPlan('monthly');
            });
        }
        
        if (this.lifetimePlanCard && !this.lifetimePlanCard.hasAttribute('data-bound')) {
            this.lifetimePlanCard.setAttribute('data-bound', 'true');
            this.lifetimePlanCard.addEventListener('click', () => {
                this.selectPlan('lifetime');
            });
        }
        
        if (this.selectedPlanCTA && !this.selectedPlanCTA.hasAttribute('data-bound')) {
            this.selectedPlanCTA.setAttribute('data-bound', 'true');
            this.selectedPlanCTA.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('üîò Pricing modal CTA button clicked');
                await this.proceedToCheckout();
            });
        }

        // Reset focus stats (from settings modal)
        const settingsResetButton = document.getElementById('settingsResetButton');
        if (settingsResetButton) {
            settingsResetButton.addEventListener('click', async (e) => {
                e.preventDefault();
                await this.resetAllData();
                this.hideSettingsModal();
            });
        }
        
        // Manage Account button (from settings modal)
        const manageAccountBtn = document.getElementById('manageAccountBtn');
        if (manageAccountBtn) {
            manageAccountBtn.addEventListener('click', (e) => {
                e.preventDefault();
                if (window.Clerk && window.Clerk.user) {
                    window.Clerk.openUserProfile();
                }
            });
        }
        
        // Upgrade to Pro button (from settings modal)
        const upgradeToProModalBtn = document.getElementById('upgradeToProModalBtn');
        if (upgradeToProModalBtn) {
            upgradeToProModalBtn.addEventListener('click', (e) => {
                e.preventDefault();
                
                // Track Settings modal Upgrade to Pro click
                const eventProperties = {
                    button_type: 'subscribe',
                    source: 'settings_modal',
                    location: 'settings_modal',
                    user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                    modal_type: 'settings_modal'
                };
                this.trackEvent('Subscribe Clicked', eventProperties);
                
                this.hideSettingsModal();
                this.showPricingPlansModal();
            });
        }
        
        // Manage Subscription button (from settings modal)
        const manageSubscriptionModalBtn = document.getElementById('manageSubscriptionModalBtn');
        if (manageSubscriptionModalBtn) {
            manageSubscriptionModalBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.handleManageSubscription();
            });
        }


        // Manage subscription button
        const manageSubscriptionButton = document.getElementById('manageSubscriptionButton');
        if (manageSubscriptionButton) {
            manageSubscriptionButton.addEventListener('click', async (e) => {
                e.preventDefault();
                try {
                    let userEmail = '';
                    try {
                        if (window.Clerk && window.Clerk.user) {
                            userEmail = (window.Clerk.user.primaryEmailAddress?.emailAddress || window.Clerk.user.emailAddresses?.[0]?.emailAddress || '') + '';
                        }
                    } catch (_) {}
                    const response = await fetch('/api/customer-portal', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-clerk-userid': (window.Clerk && window.Clerk.user ? window.Clerk.user.id : ''),
                            'x-clerk-user-email': userEmail,
                            // Pass cached stripe customer id if Clerk has it
                            'x-stripe-customer-id': (window.Clerk && window.Clerk.user && window.Clerk.user.publicMetadata ? (window.Clerk.user.publicMetadata.stripeCustomerId || '') : ''),
                        },
                    });

                    if (!response.ok) {
                        throw new Error('Failed to create customer portal session');
                    }

                    const { url } = await response.json();
                    window.location.href = url;
                } catch (error) {
                    console.error('Error creating customer portal session:', error);
                    alert('Error accessing subscription management. Please try again.');
                }
            });
        }

        // Mark as Premium button (for testing)
        const markPremiumButton = document.getElementById('markPremiumButton');
        if (markPremiumButton) {
            markPremiumButton.addEventListener('click', (e) => {
                e.preventDefault();
                localStorage.setItem('isPremium', 'true');
                localStorage.setItem('hasPaidSubscription', 'true');
                this.updatePremiumUI();
                alert('‚úÖ Marked as Premium user!\n\nRefresh the page to see changes.');
            });
        }
        
        // Handle dropdown item clicks
        const dropdownItems = document.querySelectorAll('.dropdown-item');
        dropdownItems.forEach(item => {
            item.addEventListener('click', (e) => {
                const text = item.querySelector('span').textContent;
                if (text === 'Log out') {
                    e.preventDefault();
                    this.showLogoutModal();
                    if (this.userProfileDropdown) this.userProfileDropdown.style.display = 'none';
                } else if (text === 'Upgrade to Unlimited' || text === 'Unlock Premium' || text === 'Upgrade to Premium' || text === 'Claim Lifetime Access' || text === 'Claim Lifetime Access Now' || text === 'Get Lifetime Access' || text === 'Get Unlimited Access' || text === 'Remove All Limits' || text === 'Unlock Unlimited Time' || text === 'Unlock Custom Timers' || text === 'Unlock Custom Sounds' || text === 'Unlock Analytics' || text === 'Start Free Trial' || text === 'Start FREE Trial' || text === 'Unlock Unlimited') {
                    e.preventDefault();
                    this.showUpgradeModal();
                    if (this.userProfileDropdown) this.userProfileDropdown.style.display = 'none';
                } else if (text === 'Settings') {
                    e.preventDefault();
                    this.showSettingsModal();
                    if (this.userProfileDropdown) this.userProfileDropdown.style.display = 'none';
                } else if (text === 'Integrations') {
                    e.preventDefault();
                    this.showIntegrationsModal();
                    if (this.userProfileDropdown) this.userProfileDropdown.style.display = 'none';
                } else if (text === 'Feedback') {
                    e.preventDefault();
                    this.showFeedbackModal();
                    if (this.userProfileDropdown) this.userProfileDropdown.style.display = 'none';
                }
            });
        });
        
        // Logout modal actions
        if (this.confirmLogoutBtn) {
            this.confirmLogoutBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                this.hideLogoutModal();
                await this.performLogout();
            });
        } else {
            // Fallback: try to find the button again and bind the event
            const confirmBtn = document.getElementById('confirmLogoutBtn');
            if (confirmBtn) {
                confirmBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    this.hideLogoutModal();
                    await this.performLogout();
                });
            }
        }
        
        if (this.cancelLogoutBtn) {
            this.cancelLogoutBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.hideLogoutModal();
            });
        }

        // Feedback modal actions
        const closeFeedbackModalX = document.getElementById('closeFeedbackModalX');
        const cancelFeedbackBtn = document.getElementById('cancelFeedbackBtn');
        const submitFeedbackBtn = document.getElementById('submitFeedbackBtn');
        
        if (closeFeedbackModalX) {
            closeFeedbackModalX.addEventListener('click', (e) => {
                e.preventDefault();
                this.hideFeedbackModal();
            });
        }
        
        if (cancelFeedbackBtn) {
            cancelFeedbackBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.hideFeedbackModal();
            });
        }
        if (submitFeedbackBtn) {
            submitFeedbackBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.submitFeedback();
            });
        }

        // Guest task limit modal actions
        const closeGuestTaskLimitModalX = document.getElementById('closeGuestTaskLimitModalX');
        
        if (closeGuestTaskLimitModalX) {
            closeGuestTaskLimitModalX.addEventListener('click', (e) => {
                e.preventDefault();
                this.hideGuestTaskLimitModal();
            });
        }
        
        if (this.guestTaskLimitSignupBtn) {
            this.guestTaskLimitSignupBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                
                // Check if user is authenticated (Free user trying to upgrade)
                if (this.isAuthenticated) {
                    // Track Task limit modal upgrade click
                    const eventProperties = {
                        button_type: 'subscribe',
                        source: 'task_limit_modal',
                        location: 'task_limit_modal',
                        user_type: 'free',
                        modal_type: 'task_limit_reached',
                        task_count: this.getLocalTasks().length
                    };
                    this.trackEvent('Subscribe Clicked', eventProperties);
                    
                    this.hideGuestTaskLimitModal();
                    this.showPricingPlansModal();
                    return;
                }
                
                this.trackEvent('Signup from Task Limit Modal', {
                    button_type: 'signup',
                    source: 'task_limit_modal',
                    user_type: this.isAuthenticated ? 'free_user' : 'guest',
                    task_count: this.getLocalTasks().length,
                    conversion_funnel: 'task_limit_reached'
                });
                
                this.hideGuestTaskLimitModal();
                
                if (!this.isAuthenticated) {
                    // Guest user - show signup
                    this.handleSignup();
                } else {
                    // Free user - redirect to pricing page
                    window.location.href = '/pricing';
                }
            });
        }
        
        if (this.guestTaskLimitCancelBtn) {
            this.guestTaskLimitCancelBtn.addEventListener('click', (e) => {
                e.preventDefault();
                this.hideGuestTaskLimitModal();
            });
        }
        
        // Close guest task limit modal when clicking overlay
        if (this.guestTaskLimitModalOverlay) {
            this.guestTaskLimitModalOverlay.addEventListener('click', (e) => {
                if (e.target === this.guestTaskLimitModalOverlay) {
                    this.hideGuestTaskLimitModal();
                }
            });
        }
        
        
        
        // Close modal when clicking overlay
        if (this.logoutModalOverlay) {
            this.logoutModalOverlay.addEventListener('click', (e) => {
                if (e.target === this.logoutModalOverlay) {
                    this.hideLogoutModal();
                }
            });
        }

        if (this.feedbackModalOverlay) {
            this.feedbackModalOverlay.addEventListener('click', (e) => {
                if (e.target === this.feedbackModalOverlay) {
                    this.hideFeedbackModal();
                }
            });
        }
        
        // Integration Modal event listeners
        if (this.closeIntegrationModalX) {
            this.closeIntegrationModalX.addEventListener('click', () => {
                this.hideIntegrationModal();
            });
        }
        
        if (this.integrationModalOverlay) {
            this.integrationModalOverlay.addEventListener('click', (e) => {
                if (e.target === this.integrationModalOverlay) {
                    this.hideIntegrationModal();
                }
            });
        }
        
        if (this.integrationModalPrimaryBtn) {
            this.integrationModalPrimaryBtn.addEventListener('click', async () => {
                this.trackEvent('Upgrade to Pro from Integration Modal', {
                    button_type: 'upgrade_to_pro',
                    source: 'integration_modal',
                    user_type: this.isAuthenticated ? 'free_user' : 'guest'
                });
                if (this.isAuthenticated) {
                    // Free user - redirect to pricing page
                    window.location.href = '/pricing';
                } else {
                    // Guest user - redirect to pricing
                    window.location.href = '/pricing';
                }
            });
        }
        
        if (this.integrationModalSecondaryBtn) {
            this.integrationModalSecondaryBtn.addEventListener('click', () => {
                // Cancel button - always close modal
                this.hideIntegrationModal();
            });
        }
        
    }

    resetFocusStats() {
        try {
            // Remove user-specific stats if authenticated
            const key = this.isAuthenticated && this.user?.id 
                ? `focusStats_${this.user.id}` 
                : 'focusStats';
            localStorage.removeItem(key);
            // Also remove generic key for cleanup
            localStorage.removeItem('focusStats');
        } catch (_) {}
        // Update UI immediately
        if (this.achievementCounter) {
            this.achievementCounter.textContent = '00h:00m';
        }
        // Reset cycle tracking for current cycle
        this.completedFocusSessionsInCycle = 0;
        this.cheatedDuringFocusInCycle = false;
        this.actualFocusTimeCompleted = 0;
        this.focusSecondsToday = 0;
        this.saveFocusSecondsToday(0);
    }

    showUpgradeModal() {
        // Show pricing plans modal instead of redirecting
        this.showPricingPlansModal();
    }
    
    hidePricingModal() {
        // No-op - modal removed
    }

    showCycleStatsModal(cycleData) {
        const modal = document.getElementById('cycleStatsModal');
        if (!modal) return;

        // Store cycle data for sharing
        this._lastCycleData = cycleData;

        // Populate modal with cycle statistics
        const totalMinutes = Math.round(cycleData.cycleDuration / 60);
        document.getElementById('cycleStatTotalTime').textContent = `${totalMinutes} min`;
        document.getElementById('cycleStatWorkSessions').textContent = cycleData.workSessions;

        // Show modal
        modal.style.display = 'flex';

        // Close modal function
        const closeModal = () => {
            modal.style.display = 'none';
        };

        // Share on X function
        const shareOnX = () => {
            const minutes = Math.round(cycleData.cycleDuration / 60);
            const sessions = cycleData.workSessions;
            const taskName = this.currentTaskName || this._lastTaskName || null;
            
            // Create tweet text - simple and direct
            let tweetText;
            if (taskName && taskName !== 'Focus' && taskName !== 'Short Break' && taskName !== 'Long Break') {
                // Include task name for context
                tweetText = `Just finished ${minutes} min of deep work on "${taskName}"\n\n${sessions} focus sessions done. Time for a break.`;
            } else {
                // Generic version without task
                tweetText = `${minutes} min of deep work done. ${sessions} focus sessions completed.\n\nBack to it after a break.`;
            }
            
            // Create X share URL
            const shareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}&url=${encodeURIComponent('https://superfocus.live')}`;
            
            // Open X share dialog
            window.open(shareUrl, '_blank', 'width=550,height=420,noopener,noreferrer');
            
            // Track the share event
            this.trackEvent('Cycle Shared on X', {
                total_minutes: minutes,
                focus_sessions: sessions,
                task_name: taskName,
                source: 'cycle_completion_modal'
            });
        };

        // Setup event listeners for modal buttons (use replaceWith to prevent duplicates)
        const closeBtn = document.getElementById('closeCycleStatsX');
        const shareXBtn = document.getElementById('cycleStatsShareXBtn');
        const closeSecondaryBtn = document.getElementById('cycleStatsCloseBtn');

        if (closeBtn) {
            closeBtn.replaceWith(closeBtn.cloneNode(true));
            document.getElementById('closeCycleStatsX').addEventListener('click', closeModal);
        }

        if (shareXBtn) {
            shareXBtn.replaceWith(shareXBtn.cloneNode(true));
            document.getElementById('cycleStatsShareXBtn').addEventListener('click', shareOnX);
        }

        if (closeSecondaryBtn) {
            closeSecondaryBtn.replaceWith(closeSecondaryBtn.cloneNode(true));
            document.getElementById('cycleStatsCloseBtn').addEventListener('click', closeModal);
        }

        // Close on overlay click - remove previous handler before adding new one
        if (this._cycleStatsOverlayHandler) {
            modal.removeEventListener('click', this._cycleStatsOverlayHandler);
        }
        this._cycleStatsOverlayHandler = (e) => {
            if (e.target === modal) {
                closeModal();
            }
        };
        modal.addEventListener('click', this._cycleStatsOverlayHandler);
    }

    async handleUpgrade() {
        try {
            // üéØ TRACKING: Upgrade flow initiated (tracking before redirect to pricing)
            this.trackEvent('Stripe Checkout Opened', {
                source: 'upgrade_flow',
                user_type: this.isAuthenticated ? 'free_user' : 'guest',
                timestamp: new Date().toISOString()
            });
            
            // Always redirect to pricing page - never direct checkout
            window.location.href = '/pricing';
        } catch (error) {
            console.error('Error in handleUpgrade:', error);
            // Always redirect to pricing page even on error
            window.location.href = '/pricing';
        }
    }

    hideUpgradeModal() {
        const upgradeModal = document.getElementById('upgradeModal');
        if (upgradeModal) {
            upgradeModal.style.display = 'none';
        }
    }

    showSettingsModal() {
        const settingsModal = document.getElementById('settingsModal');
        if (settingsModal) {
            settingsModal.style.display = 'flex';
            
            // üéØ Track Modal Opened event to Mixpanel
            if (window.mixpanelTracker) {
                window.mixpanelTracker.trackModalOpened('settings');
                console.log('üìä Settings modal opened event tracked to Mixpanel');
            }
            
            // Populate user info
            const emailElement = document.getElementById('settingsModalUserEmail');
            const planElement = document.getElementById('settingsUserPlan');
            const upgradeBtn = document.getElementById('upgradeToProModalBtn');
            const manageSubBtn = document.getElementById('manageSubscriptionModalBtn');
            
            if (emailElement && window.Clerk && window.Clerk.user) {
                const userEmail = window.Clerk.user.primaryEmailAddress?.emailAddress || 
                                window.Clerk.user.emailAddresses?.[0]?.emailAddress || 
                                'Not available';
                emailElement.textContent = userEmail;
            }
            
            if (planElement) {
                planElement.textContent = this.isPremium ? 'Pro' : 'Free';
            }
            
            // Show/hide buttons based on premium status
            if (upgradeBtn && manageSubBtn) {
                if (this.isPremium) {
                    upgradeBtn.style.display = 'none';
                    manageSubBtn.style.display = 'block';
                } else {
                    upgradeBtn.style.display = 'block';
                    manageSubBtn.style.display = 'none';
                }
            }
        }
    }

    showIntegrationsModal() {
        const settingsModal = document.getElementById('settingsModal');
        if (settingsModal) {
            // Switch to integrations tab and make it active
            this.switchToSettingsTab('integrations');
            // Make integrations nav item active
            const integrationsNav = document.querySelector('[data-tab="integrations"]');
            if (integrationsNav) {
                integrationsNav.classList.add('active');
            }
            settingsModal.style.display = 'flex';
        }
    }


    switchToSettingsTab(tabName) {
        // Hide all tabs
        const tabs = document.querySelectorAll('.settings-tab');
        tabs.forEach(tab => tab.style.display = 'none');
        
        // Remove active class from all nav items
        const navItems = document.querySelectorAll('.settings-nav-item');
        navItems.forEach(item => item.classList.remove('active'));
        
        // Show the requested tab
        const targetTab = document.getElementById(`${tabName}-tab`);
        const targetNavItem = document.querySelector(`[data-tab="${tabName}"]`);
        
        if (targetTab) targetTab.style.display = 'block';
        if (targetNavItem) targetNavItem.classList.add('active');
    }

    hideSettingsModal() {
        const settingsModal = document.getElementById('settingsModal');
        if (settingsModal) {
            settingsModal.style.display = 'none';
        }
    }

    // Sound system methods
    isPremiumUser() {
        // 1) Prefer real Pro from Clerk metadata regardless of any previous forced mode
        try {
            if (window.Clerk && window.Clerk.user) {
                const meta = window.Clerk.user.publicMetadata || {};
                console.log('Checking Pro status from Clerk:', {
                    isPremium: meta.isPremium,
                    metadata: meta,
                    userId: window.Clerk.user.id
                });
                if (meta.isPremium === true) return true;
            }
        } catch (_) {}

        // 2) Then check if a forced view mode exists (legacy/dev only)
        const forcedMode = localStorage.getItem('viewMode');
        if (forcedMode === 'pro') {
            console.log('Pro status from forced viewMode');
            return true;
        }
        if (forcedMode === 'free' || forcedMode === 'guest') return false;

        const urlParams = new URLSearchParams(window.location.search);
        const hasPremiumParam = urlParams.get('premium') === '1';
        const hasPremiumStorage = localStorage.getItem('isPremium') === 'true';
        const hasPaidSubscription = localStorage.getItem('hasPaidSubscription') === 'true';
        if (hasPremiumParam) {
            // Clear any forced mode to avoid overriding real Pro
            try { localStorage.removeItem('viewMode'); } catch (_) {}
            localStorage.setItem('isPremium', 'true');
            localStorage.setItem('hasPaidSubscription', 'true');
            return true;
        }
        
        const result = hasPremiumStorage || hasPaidSubscription;
        console.log('Pro status from localStorage:', {
            isPremium: hasPremiumStorage,
            hasPaidSubscription: hasPaidSubscription,
            result: result
        });
        return result;
    }

    // Simple ambient sounds system
    toggleMusic() {
        this.showAmbientModal();
    }
    
    showTimerSettingsModal() {
        // Get current durations in minutes
        const pomodoroMin = Math.floor(this.workTime / 60);
        const shortBreakMin = Math.floor(this.shortBreakTime / 60);
        const longBreakMin = Math.floor(this.longBreakTime / 60);
        
        const modalContent = `
            <div class="focus-stats-modal timer-settings-modal">
                <button class="close-focus-stats-x">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18"/><path d="m6 6 12 12"/>
                    </svg>
                </button>
                <div class="modal-header">
                    <h3>Timer Settings</h3>
                    <p class="modal-subtitle">Customize your focus sessions</p>
                </div>
                
                <!-- Sessions Count -->
                <div class="settings-section">
                    <h4 class="section-title">Sessions</h4>
                    <div class="sessions-control">
                        <div class="duration-item">
                            <div class="duration-header">
                                <label>Number of Sessions</label>
                                <span class="duration-value" id="sessionsValue">${this.sessionsPerCycle} sessions</span>
                            </div>
                            <input type="range" id="sessionsSlider" min="1" max="12" value="${this.sessionsPerCycle}" class="duration-slider">
                        </div>
                    </div>
                </div>

                <!-- Techniques -->
                <div class="settings-section">
                    <h4 class="section-title">Techniques</h4>
                    <div class="techniques-grid">
                        <button class="technique-preset" data-technique="pomodoro">
                            <div class="technique-icon">üçÖ</div>
                            <div class="technique-name">Pomodoro</div>
                            <div class="technique-desc">25min focus, 5min break</div>
                        </button>
                        <button class="technique-preset" data-technique="flow">
                            <div class="technique-icon">üåä</div>
                            <div class="technique-name">Flow State</div>
                            <div class="signup-required-text hidden">(Sign up required)</div>
                            <div class="subscribe-required-text hidden">(Premium required)</div>
                            <div class="technique-desc">45min focus, 15min break</div>
                        </button>
                        <button class="technique-preset" data-technique="deepwork">
                            <div class="technique-icon">üß†</div>
                            <div class="technique-name">Deep Work</div>
                            <div class="signup-required-text hidden">(Sign up required)</div>
                            <div class="subscribe-required-text hidden">(Premium required)</div>
                            <div class="technique-desc">90min focus, 20min break</div>
                        </button>
                        <button class="technique-preset" data-technique="sprint">
                            <div class="technique-icon">‚ö°</div>
                            <div class="technique-name">Sprint</div>
                            <div class="signup-required-text hidden">(Sign up required)</div>
                            <div class="technique-desc">15min focus, 3min break</div>
                        </button>
                        <button class="technique-preset" data-technique="marathon">
                            <div class="technique-icon">üèÉ</div>
                            <div class="technique-name">Marathon</div>
                            <div class="signup-required-text hidden">(Sign up required)</div>
                            <div class="subscribe-required-text hidden">(Premium required)</div>
                            <div class="technique-desc">60min focus, 10min break</div>
                        </button>
                    </div>
                </div>

                <!-- Timer Durations -->
                <div class="settings-section">
                    <h4 class="section-title">Duration</h4>
                    <div class="duration-controls">
                        <div class="duration-item">
                            <div class="duration-header">
                                <label>Pomodoro</label>
                                <span class="duration-value" id="pomodoroValue">${pomodoroMin} min</span>
                            </div>
                            <input type="range" id="pomodoroSlider" min="1" max="120" value="${pomodoroMin}" class="duration-slider">
                        </div>
                        <div class="duration-item">
                            <div class="duration-header">
                                <label>Short Break</label>
                                <span class="duration-value" id="shortBreakValue">${shortBreakMin} min</span>
                            </div>
                            <input type="range" id="shortBreakSlider" min="1" max="30" value="${shortBreakMin}" class="duration-slider">
                        </div>
                        <div class="duration-item">
                            <div class="duration-header">
                                <label>Long Break</label>
                                <span class="duration-value" id="longBreakValue">${longBreakMin} min</span>
                            </div>
                            <input type="range" id="longBreakSlider" min="1" max="60" value="${longBreakMin}" class="duration-slider">
                        </div>
                    </div>
                </div>
                
                <!-- Save Button -->
                <div class="modal-actions">
                    <button class="save-settings-btn" id="saveTimerSettings">Save Changes</button>
                </div>
            </div>
        `;
        
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'focus-stats-overlay';
        modalOverlay.innerHTML = modalContent;
        document.body.appendChild(modalOverlay);
        modalOverlay.style.display = 'flex';
        
        // Duration sliders
        const pomodoroSlider = modalOverlay.querySelector('#pomodoroSlider');
        const shortBreakSlider = modalOverlay.querySelector('#shortBreakSlider');
        const longBreakSlider = modalOverlay.querySelector('#longBreakSlider');
        const pomodoroValue = modalOverlay.querySelector('#pomodoroValue');
        const shortBreakValue = modalOverlay.querySelector('#shortBreakValue');
        const longBreakValue = modalOverlay.querySelector('#longBreakValue');
        
        pomodoroSlider.addEventListener('input', (e) => {
            this.trackEvent('Duration Control Changed', {
                button_type: 'duration_control',
                control_name: 'pomodoro',
                value: e.target.value,
                source: 'timer_modal'
            });
            pomodoroValue.textContent = `${e.target.value} min`;
        });
        shortBreakSlider.addEventListener('input', (e) => {
            this.trackEvent('Duration Control Changed', {
                button_type: 'duration_control',
                control_name: 'short_break',
                value: e.target.value,
                source: 'timer_modal'
            });
            shortBreakValue.textContent = `${e.target.value} min`;
        });
        longBreakSlider.addEventListener('input', (e) => {
            this.trackEvent('Duration Control Changed', {
                button_type: 'duration_control',
                control_name: 'long_break',
                value: e.target.value,
                source: 'timer_modal'
            });
            longBreakValue.textContent = `${e.target.value} min`;
        });
        
        // Sessions slider
        const sessionsSlider = modalOverlay.querySelector('#sessionsSlider');
        const sessionsValue = modalOverlay.querySelector('#sessionsValue');
        sessionsSlider.addEventListener('input', (e) => {
            this.trackEvent('Duration Control Changed', {
                button_type: 'duration_control',
                control_name: 'sessions',
                value: e.target.value,
                source: 'timer_modal'
            });
            sessionsValue.textContent = `${e.target.value} sessions`;
        });

        // Techniques presets
        const techniquePresets = modalOverlay.querySelectorAll('.technique-preset');
        techniquePresets.forEach(preset => {
            // Remove any existing event listeners to prevent duplicates
            const newPreset = preset.cloneNode(true);
            preset.parentNode.replaceChild(newPreset, preset);
            
            newPreset.addEventListener('click', () => {
                const technique = newPreset.dataset.technique;
                
                // Check if preset is disabled (opacity 0.5 means disabled)
                if (getComputedStyle(newPreset).opacity === '0.5' || newPreset.style.opacity === '0.5') {
                    // Check if it requires authentication (Flow, Marathon, Deep Work require login)
                    const proTechniques = ['flow', 'marathon', 'deepwork'];
                    if (proTechniques.includes(technique) && !this.isAuthenticated) {
                        // Guest users must login first
                        this.showLoginRequiredModal(technique);
                        return;
                    }
                    // Check if it requires authentication
                    if (technique !== 'pomodoro' && !this.isAuthenticated) {
                        // Show signup modal or do nothing (already disabled)
                        return;
                    }
                    return; // Don't do anything if preset is disabled
                }
                
                // Check if technique requires authentication (Flow, Marathon, Deep Work require login for free users)
                const proTechniques = ['flow', 'marathon', 'deepwork'];
                if (proTechniques.includes(technique) && !this.isAuthenticated) {
                    // Guest users must login first
                    this.showLoginRequiredModal(technique);
                    return;
                }
                
                // Check if technique requires authentication (Sprint, Focus for guests)
                if (technique !== 'pomodoro' && !this.isAuthenticated) {
                    return; // Don't show modal, preset is already disabled
                }
                
                this.trackEvent('Technique Selected', {
                    modal_type: 'timer_modal',
                    button_type: 'technique_preset',
                    technique_name: technique,
                    source: 'timer_modal',
                    user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                    conversion_funnel: 'technique_exploration'
                });
                
                // Get fresh reference to all presets after cloning
                const currentTechniquePresets = modalOverlay.querySelectorAll('.technique-preset');
                // Remove active class from all presets
                currentTechniquePresets.forEach(p => p.classList.remove('active'));
                // Add active class to clicked preset
                newPreset.classList.add('active');
                
                // Apply technique settings
                this.applyTechniquePreset(technique, pomodoroSlider, shortBreakSlider, longBreakSlider, sessionsSlider);
            });
        });
        
        // Update preset visibility/disabled state after adding event listeners
        setTimeout(() => {
            this.updateTechniquePresetsVisibility();
        }, 0);

        // Close button
        modalOverlay.querySelector('.close-focus-stats-x').addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
        });
        
        // Save button
        modalOverlay.querySelector('#saveTimerSettings').addEventListener('click', () => {
            // Save new durations
            this.workTime = parseInt(pomodoroSlider.value) * 60;
            this.shortBreakTime = parseInt(shortBreakSlider.value) * 60;
            this.longBreakTime = parseInt(longBreakSlider.value) * 60;
            this.sessionsPerCycle = parseInt(sessionsSlider.value);
            
            // Save to localStorage
            localStorage.setItem('pomodoroTime', String(this.workTime));
            localStorage.setItem('shortBreakTime', String(this.shortBreakTime));
            localStorage.setItem('longBreakTime', String(this.longBreakTime));
            localStorage.setItem('sessionsPerCycle', String(this.sessionsPerCycle));
            
            // Update cycle sections dynamically based on sessionsPerCycle
            this.buildCycleSections();
            
            // Reset timer to first section
            this.pauseTimerSilent();
            this.currentSection = 1;
            this.loadCurrentSection();
            this.updateProgressRing();
            
            // Close modal
            document.body.removeChild(modalOverlay);
        });
    }

    applyTechniquePreset(technique, pomodoroSlider, shortBreakSlider, longBreakSlider, sessionsSlider) {
        
        const presets = {
            pomodoro: { work: 25, shortBreak: 5, longBreak: 15, sessions: 4 },
            flow: { work: 45, shortBreak: 15, longBreak: 30, sessions: 3 },
            deepwork: { work: 90, shortBreak: 20, longBreak: 45, sessions: 2 },
            sprint: { work: 15, shortBreak: 3, longBreak: 10, sessions: 6 },
            marathon: { work: 60, shortBreak: 10, longBreak: 20, sessions: 4 }
        };

        const preset = presets[technique];
        if (preset) {
            pomodoroSlider.value = preset.work;
            shortBreakSlider.value = preset.shortBreak;
            longBreakSlider.value = preset.longBreak;
            sessionsSlider.value = preset.sessions;

            // Update display values
            document.querySelector('#pomodoroValue').textContent = `${preset.work} min`;
            document.querySelector('#shortBreakValue').textContent = `${preset.shortBreak} min`;
            document.querySelector('#longBreakValue').textContent = `${preset.longBreak} min`;
            document.querySelector('#sessionsValue').textContent = `${preset.sessions} sessions`;
        }
    }

    applySidebarTechniquePreset(technique, pomodoroSlider, shortBreakSlider, longBreakSlider, sessionsSlider) {
        const presets = {
            pomodoro: { work: 25, shortBreak: 5, longBreak: 15, sessions: 4 },
            flow: { work: 45, shortBreak: 15, longBreak: 30, sessions: 3 },
            deepwork: { work: 90, shortBreak: 20, longBreak: 45, sessions: 2 },
            sprint: { work: 15, shortBreak: 3, longBreak: 10, sessions: 6 },
            marathon: { work: 60, shortBreak: 10, longBreak: 20, sessions: 4 },
            focus: { work: 30, shortBreak: 8, longBreak: 20, sessions: 4 }
        };

        const preset = presets[technique];
        if (preset) {
            pomodoroSlider.value = preset.work;
            shortBreakSlider.value = preset.shortBreak;
            longBreakSlider.value = preset.longBreak;
            sessionsSlider.value = preset.sessions;

            // Update display values
            document.querySelector('#sidebarPomodoroValue').value = preset.work;
            document.querySelector('#sidebarShortBreakValue').value = preset.shortBreak;
            document.querySelector('#sidebarLongBreakValue').value = preset.longBreak;
            document.querySelector('#sidebarSessionsValue').value = preset.sessions;
        }
    }

    showAmbientLoginModal() {
        const modalContent = `
            <div class="focus-stats-modal">
                <button class="close-focus-stats-x">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x">
                        <path d="M18 6 6 18"/>
                        <path d="m6 6 12 12"/>
                    </svg>
                </button>
                <div class="login-required-content">
                    <div class="login-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-music-icon lucide-music">
                            <path d="M9 18V5l12-2v13"/>
                            <circle cx="6" cy="18" r="3"/>
                            <circle cx="18" cy="16" r="3"/>
                        </svg>
                    </div>
                    <h3>Ambient Sounds</h3>
                    <p>Create a free account to access ambient sounds and enhance your focus sessions.</p>
                    <div class="login-required-buttons">
                        <button class="login-btn" id="ambientLoginBtn">Login</button>
                        <button class="cancel-btn" id="ambientCancelBtn">Cancel</button>
                    </div>
                </div>
            </div>
        `;

        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'focus-stats-overlay';
        modalOverlay.innerHTML = modalContent;
        document.body.appendChild(modalOverlay);
        modalOverlay.style.display = 'flex';

		// Hard-remove any Spotify-related UI from the Background Music modal (defensive)
		(() => {
			const selectors = [
				'#spotifyPlaylistsList',
				'.spotify-actions',
				'#connectSpotifyBtn',
				'#disconnectSpotifyBtn',
				'#spotifyToggle',
				'#spotifyPlaylists'
			];
			selectors.forEach((sel) => {
				const el = modalOverlay.querySelector(sel);
				if (!el) return;
				const container = el.closest('.music-section') || el.closest('.music-controls > *') || el.parentElement;
				if (container && container.parentElement) {
					container.parentElement.removeChild(container);
				} else {
					el.remove();
				}
			});

			// Remove any headings/text blocks that mention Spotify/Playlists
			Array.from(modalOverlay.querySelectorAll('h4, p, div, span')).forEach((node) => {
				try {
					const text = (node.textContent || '').trim();
					if (!text) return;
					if (/spotify/i.test(text) || /playlists/i.test(text)) {
						const container = node.closest('.music-section') || node.closest('.music-controls > *') || node.parentElement;
						if (container && container.parentElement && container !== modalOverlay) {
							container.parentElement.removeChild(container);
						} else {
							node.remove();
						}
					}
				} catch (_) {}
			});

			// Also remove any Preview control if present
			const previewBtnInDom = modalOverlay.querySelector('#previewBtn');
			if (previewBtnInDom && previewBtnInDom.parentElement) {
				previewBtnInDom.parentElement.removeChild(previewBtnInDom);
			}
		})();

		// Remove Spotify UI and Preview button from the modal UI
		const spotifyListSection = modalOverlay.querySelector('#spotifyPlaylistsList');
		if (spotifyListSection) {
			const spotifySectionContainer = spotifyListSection.closest('.music-section') || spotifyListSection.parentElement;
			if (spotifySectionContainer && spotifySectionContainer.parentElement) {
				spotifySectionContainer.parentElement.removeChild(spotifySectionContainer);
			}
		}
		const spotifyActions = modalOverlay.querySelector('.spotify-actions');
		if (spotifyActions && spotifyActions.parentElement) {
			spotifyActions.parentElement.removeChild(spotifyActions);
		}
		const previewBtnInDom = modalOverlay.querySelector('#previewBtn');
		if (previewBtnInDom && previewBtnInDom.parentElement) {
			previewBtnInDom.parentElement.removeChild(previewBtnInDom);
		}

        // Event listeners
        modalOverlay.querySelector('.close-focus-stats-x').addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
        });

        modalOverlay.querySelector('#ambientLoginBtn').addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
            window.location.href = 'https://accounts.superfocus.live/sign-in?redirect_url=' + encodeURIComponent(window.location.href);
        });

        modalOverlay.querySelector('#ambientCancelBtn').addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
        });

        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                document.body.removeChild(modalOverlay);
            }
        });
    }
    
    showShortcutsModal() {
        // Evitar abrir m√°s de un modal: si ya existe uno visible, no crear otro
        const existing = document.querySelector('.shortcuts-modal-overlay');
        if (existing && existing.parentNode) {
            return;
        }
        const modalContent = `
            <div class="focus-stats-modal timer-settings-modal">
                <button class="close-focus-stats-x">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M18 6 6 18"/><path d="m6 6 12 12"/>
                    </svg>
                </button>
                <div class="modal-header">
                    <h3>Keyboard Shortcuts</h3>
                    <p class="modal-subtitle">Quick actions to boost your productivity</p>
                </div>
                
                <div class="settings-section">
                    <div class="shortcuts-list">
                        <div class="shortcut-item">
                            <span class="shortcut-description">Start/Pause Timer</span>
                            <kbd class="shortcut-key">Space</kbd>
                        </div>
                        <div class="shortcut-item">
                            <span class="shortcut-description">Reset Timer</span>
                            <kbd class="shortcut-key">R</kbd>
                        </div>
                        <div class="shortcut-item">
                            <span class="shortcut-description">Next Section</span>
                            <kbd class="shortcut-key">‚Üí</kbd>
                        </div>
                        <div class="shortcut-item">
                            <span class="shortcut-description">Previous Section</span>
                            <kbd class="shortcut-key">‚Üê</kbd>
                        </div>
                        <div class="shortcut-item">
                            <span class="shortcut-description">Open Shortcuts</span>
                            <kbd class="shortcut-key">‚åòK</kbd>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'focus-stats-overlay shortcuts-modal-overlay';
        modalOverlay.innerHTML = modalContent;
        document.body.appendChild(modalOverlay);
        modalOverlay.style.display = 'flex';
        
        const closeShortcutsModal = () => {
            modalOverlay.style.display = 'none';
            if (modalOverlay.parentNode) {
                document.body.removeChild(modalOverlay);
            }
        };
        
        // Close button
        const closeBtn = modalOverlay.querySelector('.close-focus-stats-x');
        closeBtn.addEventListener('click', closeShortcutsModal);
        
        // Close on overlay click
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                closeShortcutsModal();
            }
        });
    }

    showAmbientModal() {
        const initialVolumePct = Math.round(this.ambientVolume * 100);
        const lofiEnabled = this.ambientEnabled;
        const rainEnabled = this.rainEnabled;
        const modalContent = `
            <div class="focus-stats-modal background-music-modal">
                <button class="close-focus-stats-x">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x">
                        <path d="M18 6 6 18"/>
                        <path d="m6 6 12 12"/>
                    </svg>
                </button>
                <div class="modal-header">
                    <h3>Focus Sounds - UPDATED</h3>
                    <p class="modal-subtitle">Set the mood for deep concentration</p>
                </div>
                <div class="music-controls">
                    <div class="volume-section">
                        <div class="volume-header">
                            <label class="volume-label">Volume</label>
                            <span class="volume-value" id="ambientVolumeValue">${initialVolumePct}%</span>
                                </div>
                        <div class="volume-control">
                            <input type="range" id="ambientVolume" min="0" max="100" value="${initialVolumePct}" class="volume-slider">
                        </div>
                    </div>
                    <div class="music-section">
                        <div class="music-header">
                            <div class="music-info">
                                <div class="music-details">
                                    <h4>Rain Sounds</h4>
                                    <p>Natural rain and thunder for deep concentration</p>
                                </div>
                            </div>
                            <div class="toggle-container">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="musicRainToggle" ${rainEnabled ? 'checked' : ''}>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        ${this.isAuthenticated ? `
                        <div class="music-header">
                            <div class="music-info">
                                <div class="music-details">
                                    <h4>Lofi Music</h4>
                                    <p>Relaxing beats for deep focus</p>
                                </div>
                            </div>
                            <div class="toggle-container">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="musicLofiToggle" ${lofiEnabled ? 'checked' : ''}>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        ` : `
                        <div class="music-header disabled">
                            <div class="music-info">
                                <div class="music-details">
                                    <h4 style="color: #d0d0d0;">Lofi Music</h4>
                                    <p style="color: #888;">Relaxing beats for deep focus</p>
                                </div>
                            </div>
                            <div class="login-container">
                                <button id="lofiLoginBtn" class="login-btn">Sign up</button>
                            </div>
                        </div>
                        `}
                            </div>
                </div>
            </div>
        `;

        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'focus-stats-overlay';
        modalOverlay.innerHTML = modalContent;
        document.body.appendChild(modalOverlay);
        modalOverlay.style.display = 'flex';

        // Event listeners
        modalOverlay.querySelector('.close-focus-stats-x').addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
        });

        const volumeSlider = modalOverlay.querySelector('#ambientVolume');
        const volumeValue = modalOverlay.querySelector('#ambientVolumeValue');
        const musicLofiToggle = modalOverlay.querySelector('#musicLofiToggle');
        const musicRainToggle = modalOverlay.querySelector('#musicRainToggle');
        const previewBtn = modalOverlay.querySelector('#previewBtn');
        const lofiLoginBtn = modalOverlay.querySelector('#lofiLoginBtn');
        
        // Initialize controls with current state (volume applies to active source)
        volumeSlider.disabled = !(lofiEnabled || rainEnabled);
        // The same slider controls the single <audio> element, regardless of source
		if (previewBtn) previewBtn.disabled = !lofiEnabled;
        
        // Initialize toggle states based on current settings
        if (musicLofiToggle) musicLofiToggle.checked = lofiEnabled;
        if (musicRainToggle) musicRainToggle.checked = rainEnabled;

        // Lofi toggle logic
        if (musicLofiToggle) {
            musicLofiToggle.addEventListener('change', (e) => {
                const enabled = e.target.checked;
                this.ambientEnabled = enabled;
                localStorage.setItem('ambientEnabled', String(enabled));
                volumeSlider.disabled = !(this.ambientEnabled || this.rainEnabled);
                if (previewBtn) previewBtn.disabled = !enabled;
                
                if (enabled) {
                    // If enabling lofi, disable rain
                    this.rainEnabled = false;
                    localStorage.setItem('rainEnabled', 'false');
                    if (musicRainToggle) musicRainToggle.checked = false;
                    this.stopRainPlaylist();
                    
                    // Start lofi music if timer is running
                    if (this.isRunning) {
                        this.playPlaylist();
                    }
                } else {
                    this.stopPlaylist();
                }
            });
        }


        // Lofi Login button and card (for guests)
        if (lofiLoginBtn) {
            // Make the entire disabled card clickable
            const disabledLofiCard = modalOverlay.querySelector('.music-header.disabled');
            if (disabledLofiCard) {
                disabledLofiCard.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    document.body.removeChild(modalOverlay);
                    this.showLofiLoginModal();
                });
            }
            
            // Keep button click handler for backwards compatibility
            lofiLoginBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                document.body.removeChild(modalOverlay);
                this.showLofiLoginModal();
            });
        }

        // Rain toggle logic
        if (musicRainToggle) {
            musicRainToggle.addEventListener('change', (e) => {
                const enabled = e.target.checked;
                this.rainEnabled = enabled;
                localStorage.setItem('rainEnabled', String(enabled));
                volumeSlider.disabled = !(this.ambientEnabled || this.rainEnabled);
                if (previewBtn) previewBtn.disabled = true;
                
                if (enabled) {
                    // If enabling rain, disable lofi
                    this.ambientEnabled = false;
                    localStorage.setItem('ambientEnabled', 'false');
                    if (musicLofiToggle) musicLofiToggle.checked = false;
                    this.stopPlaylist();
                    
                    // Start Rain music if timer is running
                    if (this.isRunning) {
                        this.playRainPlaylist();
                    }
                } else {
                    this.stopRainPlaylist();
                }
            });
        }

        // Preview button (play/pause functionality)
		if (previewBtn) {
        previewBtn.addEventListener('click', async () => {
            if (lofiToggle.checked) {
                if (previewBtn.textContent === 'Preview') {
                    await this.playPlaylist();
                    previewBtn.textContent = 'Pause';
                } else {
                    this.stopPlaylist();
                    previewBtn.textContent = 'Preview';
                }
            }
        });
		}

        volumeSlider.addEventListener('input', (e) => {
            volumeValue.textContent = e.target.value + '%';
            this.setAmbientVolume(e.target.value / 100);
        });


        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                document.body.removeChild(modalOverlay);
            }
        });
    }

    // Helper to set playlist after uploading files
    setPlaylist(trackFilenames = []) {
        if (!Array.isArray(trackFilenames)) return;
        // Keep only .mp3 and .wav for safety
        this.playlist = trackFilenames.filter(name => /\.(mp3|wav)$/i.test(name));
        this.currentTrackIndex = 0;
    }

    async playPlaylist() {
        if (!this.backgroundAudio) return;
        if (!this.playlist || this.playlist.length === 0) {
            alert('No background tracks available yet. Upload MP3s to /audio/lofi');
            return;
        }
        // If switching from Bury the Light, ensure src actually changes to lofi
        this.backgroundAudio.pause();
        this.backgroundAudio.src = '/audio/lofi/' + this.playlist[this.currentTrackIndex];
        this.backgroundAudio.loop = false;
        this.backgroundAudio.volume = this.ambientVolume;
        try { await this.backgroundAudio.play(); } catch (_) {}
        this.ambientPlaying = true;
        this.buryTheLightPlaying = false; // Ensure only one flag is set
        if (this.musicToggleBtn) this.musicToggleBtn.classList.add('playing');
    }

    stopPlaylist() {
        if (!this.backgroundAudio) return;
        try { this.backgroundAudio.pause(); } catch (_) {}
        this.ambientPlaying = false;
        if (this.musicToggleBtn) this.musicToggleBtn.classList.remove('playing');
    }

    // Lofi music methods
    setLofiVolume(vol) {
        this.lofiVolume = Math.max(0, Math.min(1, vol));
        localStorage.setItem('lofiVolume', String(this.lofiVolume));
        if (this.backgroundAudio) this.backgroundAudio.volume = this.lofiVolume;
    }

    shuffleLofiPlaylist() {
        // Fisher-Yates shuffle algorithm for random order
        this.lofiShuffledPlaylist = [...this.lofiPlaylist];
        for (let i = this.lofiShuffledPlaylist.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.lofiShuffledPlaylist[i], this.lofiShuffledPlaylist[j]] = [this.lofiShuffledPlaylist[j], this.lofiShuffledPlaylist[i]];
        }
        this.currentLofiTrackIndex = 0;
    }

    async playLofiPlaylist() {
        // Don't play Lofi music if immersive theme is active
        if (this.currentImmersiveTheme && this.currentImmersiveTheme !== 'none') {
            console.log(`üéµ Lofi music blocked - immersive theme '${this.currentImmersiveTheme}' is active`);
            return;
        }
        
        // Don't play if lofi is disabled
        if (!this.lofiEnabled) {
            console.log(`üéµ Lofi music blocked - lofi disabled`);
            return;
        }
        
        if (!this.backgroundAudio) return;
        if (!this.lofiShuffledPlaylist || this.lofiShuffledPlaylist.length === 0) {
            console.log('‚ùå No Lofi tracks available yet');
            return;
        }
        
        this.backgroundAudio.pause();
        this.backgroundAudio.src = '/audio/Lofi/' + this.lofiShuffledPlaylist[this.currentLofiTrackIndex];
        this.backgroundAudio.loop = false;
        this.backgroundAudio.volume = this.lofiVolume;
        
        try { 
            await this.backgroundAudio.play(); 
            console.log('‚úÖ Lofi music started:', this.lofiShuffledPlaylist[this.currentLofiTrackIndex]);
        } catch (error) {
            console.log('‚ùå Error playing Lofi:', error);
        }
        
        this.lofiPlaying = true;
        if (this.musicToggleBtn) this.musicToggleBtn.classList.add('playing');
    }


    stopLofiPlaylist() {
        if (!this.backgroundAudio) return;
        try { this.backgroundAudio.pause(); } catch (_) {}
        this.lofiPlaying = false;
        if (this.musicToggleBtn) this.musicToggleBtn.classList.remove('playing');
    }

    pauseLofiPlaylist() {
        if (!this.backgroundAudio) return;
        try { this.backgroundAudio.pause(); } catch (_) {}
        this.lofiPlaying = false;
        if (this.musicToggleBtn) this.musicToggleBtn.classList.remove('playing');
    }

    resumeLofiPlaylist() {
        if (!this.backgroundAudio) return;
        if (!this.lofiEnabled) return;
        
        const src = this.backgroundAudio.currentSrc || this.backgroundAudio.src || '';
        const isLofiSrc = /\/audio\/Lofi\//.test(src);
        
        if (!isLofiSrc && this.lofiShuffledPlaylist.length > 0) {
            this.backgroundAudio.src = '/audio/Lofi/' + this.lofiShuffledPlaylist[this.currentLofiTrackIndex];
        }
        
        try { this.backgroundAudio.play(); } catch (_) {}
        this.lofiPlaying = true;
        if (this.musicToggleBtn) this.musicToggleBtn.classList.add('playing');
    }

    // Missing music pause methods
    pausePlaylist() {
        // Generic pause method for background music
        if (!this.backgroundAudio) return;
        try { this.backgroundAudio.pause(); } catch (_) {}
        this.lofiPlaying = false;
        if (this.musicToggleBtn) this.musicToggleBtn.classList.remove('playing');
    }

    pauseNatureSound() {
        // Pause nature sounds if playing
        if (!this.backgroundAudio) return;
        try { this.backgroundAudio.pause(); } catch (_) {}
        this.naturePlaying = false;
        if (this.musicToggleBtn) this.musicToggleBtn.classList.remove('playing');
    }

    pauseTronMusic() {
        // Pause Tron music if playing
        if (!this.backgroundAudio) return;
        try { this.backgroundAudio.pause(); } catch (_) {}
        // Reset any Tron-specific music state if needed
        if (this.musicToggleBtn) this.musicToggleBtn.classList.remove('playing');
    }

    nextLofiTrack() {
        if (!this.lofiShuffledPlaylist || this.lofiShuffledPlaylist.length === 0 || !this.backgroundAudio) return;
        
        this.currentLofiTrackIndex = (this.currentLofiTrackIndex + 1) % this.lofiShuffledPlaylist.length;
        
        // Re-shuffle when playlist loops back to beginning
        if (this.currentLofiTrackIndex === 0) {
            this.shuffleLofiPlaylist();
        }
        
        this.backgroundAudio.src = '/audio/Lofi/' + this.lofiShuffledPlaylist[this.currentLofiTrackIndex];
        this.backgroundAudio.volume = this.lofiVolume;
        this.backgroundAudio.play().catch(() => {});
        this.lofiPlaying = true;
        if (this.musicToggleBtn) this.musicToggleBtn.classList.add('playing');
    }

    async loadLofiPlaylist() {
        try {
            // Lofi playlist - 27 relaxing tracks
            this.lofiPlaylist = [
                "A Sip of Yesterday.mp3",
                "Autumn Reverie.mp3",
                "Autumn's Whisper.mp3",
                "Dream in Slow Motion.mp3",
                "Dreaming in Dandelions.mp3",
                "Dreaming in Pastels.mp3",
                "Dreams in Sepia.mp3",
                "Dreams in the Windowlight.mp3",
                "Driftwood Dreams.mp3",
                "Evening in a Teacup.mp3",
                "Evening's Gentle Glow.mp3",
                "Falling for Yesterday.mp3",
                "Golden Glow.mp3",
                "Golden Hour Glow.mp3",
                "Golden Hour Memory.mp3",
                "Lantern Glow.mp3",
                "Lost in the Glow.mp3",
                "Lost in the Quiet.mp3",
                "Moonlight Whispers.mp3",
                "Starlit Whispers.mp3",
                "Under the Velvet Sky.mp3",
                "Whispered Breezes.mp3",
                "Whispered Dreams.mp3",
                "Whispered Horizons.mp3",
                "Whispered Memories.mp3",
                "Whispered Pines.mp3",
                "Whispering Lights.mp3"
            ];
            
            console.log(`üìÇ Loaded ${this.lofiPlaylist.length} Lofi tracks`);
            
            // Shuffle the playlist for first playback
            if (this.lofiPlaylist.length > 0) {
                this.shuffleLofiPlaylist();
            }
        } catch (error) {
            console.error('‚ùå Error loading Lofi playlist:', error);
        }
    }

    // Smooth fades
    fadeMusicTo(targetVolume, durationMs) {
        if (!this.backgroundAudio) return;
        // Only fade if music is actually playing
        if (!this.lofiPlaying) return;
        
        if (this.fadeTimer) {
            clearInterval(this.fadeTimer);
            this.fadeTimer = null;
        }
        const start = this.backgroundAudio.volume;
        const delta = targetVolume - start;
        const steps = Math.max(1, Math.floor(durationMs / 50));
        let count = 0;
        this.fadeTimer = setInterval(() => {
            count++;
            const t = count / steps;
            const v = start + delta * t;
            this.backgroundAudio.volume = Math.max(0, Math.min(1, v));
            if (count >= steps) {
                clearInterval(this.fadeTimer);
                this.fadeTimer = null;
                this.backgroundAudio.volume = Math.max(0, Math.min(1, targetVolume));
            }
        }, 50);
    }

    fadeMusicIn(durationMs) {
        if (!this.backgroundAudio) return;
        // Only fade in if music is actually playing
        if (!this.lofiPlaying) return;
        
        const target = this.lofiVolume;
        if (this.backgroundAudio.volume > 0.001) this.backgroundAudio.volume = 0;
        this.fadeMusicTo(target, durationMs);
    }

    fadeMusicOut(durationMs) {
        if (!this.backgroundAudio) return;
        // Only fade out if music is actually playing
        if (!this.lofiPlaying) return;
        
        this.fadeMusicTo(0, durationMs);
    }

    updatePremiumUI() {
        const upgradeButton = document.getElementById('upgradeToProButton');
        const manageSubscriptionButton = document.getElementById('manageSubscriptionButton');
        const userProBadge = document.getElementById('userProBadge');
        const integrationsButton = document.getElementById('integrationsButton');
        const integrationsSection = document.getElementById('integrationsSection');
        const leaderboardRefreshBtn = this.leaderboardRefreshBtn;
        const hasPremiumAccess = this.isAuthenticated && this.isPremiumUser();
        
        if (this.isPremiumUser()) {
            const meta = window.Clerk?.user?.publicMetadata || {};
            const isLifetime = meta.isLifetime === true || meta.paymentType === 'lifetime';
            
            // Show Manage subscription only for non-lifetime premium users
            if (upgradeButton) upgradeButton.style.display = 'none';
            if (manageSubscriptionButton) manageSubscriptionButton.style.display = isLifetime ? 'none' : 'flex';
            if (userProBadge) userProBadge.style.display = 'inline-block';
            if (integrationsButton) integrationsButton.style.display = 'flex';
            if (integrationsSection) integrationsSection.style.display = 'block';
            if (leaderboardRefreshBtn) {
                leaderboardRefreshBtn.style.display = hasPremiumAccess ? 'inline-flex' : 'none';
                leaderboardRefreshBtn.disabled = !hasPremiumAccess;
            }
            
            // Settings dropdown elements
            if (this.settingsUpgradeToProBtn) this.settingsUpgradeToProBtn.style.display = 'none';
            if (this.settingsManageSubscriptionBtn) this.settingsManageSubscriptionBtn.style.display = isLifetime ? 'none' : 'flex';
            if (this.settingsProBadge) this.settingsProBadge.style.display = 'inline-block';
            // Integrations removed from menu
            // if (this.settingsIntegrationsBtn) this.settingsIntegrationsBtn.style.display = 'flex';
        } else {
            // Show Upgrade, hide Manage subscription, hide Pro badge
            if (upgradeButton) upgradeButton.style.display = 'flex';
            if (manageSubscriptionButton) manageSubscriptionButton.style.display = 'none';
            if (userProBadge) userProBadge.style.display = 'none';
            if (integrationsButton) integrationsButton.style.display = 'none';
            if (integrationsSection) integrationsSection.style.display = 'none';
            if (leaderboardRefreshBtn) {
                leaderboardRefreshBtn.style.display = 'none';
                leaderboardRefreshBtn.disabled = true;
            }
            
            // Settings dropdown elements
            if (this.settingsUpgradeToProBtn) this.settingsUpgradeToProBtn.style.display = 'flex';
            if (this.settingsManageSubscriptionBtn) this.settingsManageSubscriptionBtn.style.display = 'none';
            if (this.settingsProBadge) this.settingsProBadge.style.display = 'none';
            // Integrations removed from menu
            // if (this.settingsIntegrationsBtn) this.settingsIntegrationsBtn.style.display = 'none';
        }
        
        // Update technique presets visibility based on user type
        this.updateTechniquePresetsVisibility();

        if (window.updateCoachAccess) {
            window.updateCoachAccess();
        }
    }

    clearLeaderboardCache() {
        this.leaderboardCache = {};
        this.leaderboardCachedAtHours = 0;
        try {
            localStorage.removeItem('leaderboardCache');
            localStorage.removeItem('leaderboardCachedAtHours');
        } catch (_) {}
    }

    async refreshLeaderboardSnapshot() {
        if (!this.isAuthenticated) {
            this.showResourceShareToast('Log in to refresh the leaderboard', true);
            return;
        }

        if (!this.isPremiumUser()) {
            this.showResourceShareToast('Premium only: refresh unavailable', true);
            return;
        }

        if (!this.leaderboardRefreshBtn || this.leaderboardRefreshBtn.classList.contains('loading')) {
            return;
        }

        this.leaderboardRefreshBtn.classList.add('loading');
        this.leaderboardRefreshBtn.disabled = true;
        this.leaderboardRefreshBtn.setAttribute('aria-busy', 'true');
        const loadingStartedAt = Date.now();

        try {
            const userId = this.user?.id || window.Clerk?.user?.id || '';
            if (!userId) {
                throw new Error('Missing user session');
            }

            const response = await fetch('/api/leaderboard-refresh', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-clerk-userid': userId
                }
            });

            if (!response.ok) {
                const errorPayload = await response.json().catch(() => ({}));
                throw new Error(errorPayload?.error || 'Failed to refresh leaderboard');
            }

            this.clearLeaderboardCache();
            await this.loadLeaderboardForPanel(this.leaderboardCurrentPage || 1);
            if (this.isLeaderboardModalOpen()) {
                await this.loadLeaderboardForModal(this.leaderboardModalCurrentPage || 1);
            }

            this.showResourceShareToast('Leaderboard updated');
        } catch (error) {
            console.error('Leaderboard refresh failed:', error);
            this.showResourceShareToast('Could not refresh leaderboard', true);
        } finally {
            const elapsedMs = Date.now() - loadingStartedAt;
            if (elapsedMs < 600) {
                await new Promise(resolve => setTimeout(resolve, 600 - elapsedMs));
            }
            this.leaderboardRefreshBtn.classList.remove('loading');
            this.leaderboardRefreshBtn.disabled = false;
            this.leaderboardRefreshBtn.setAttribute('aria-busy', 'false');
        }
    }

    async refreshPremiumFromServer() {
        try {
            if (!window.Clerk || !window.Clerk.user) return;
            const userId = window.Clerk.user.id;
            const userEmail = (window.Clerk.user.primaryEmailAddress?.emailAddress || window.Clerk.user.emailAddresses?.[0]?.emailAddress || '') + '';
            const resp = await fetch('/api/refresh-premium', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-clerk-userid': userId,
                    'x-clerk-user-email': userEmail,
                },
            });
            if (!resp.ok) return;
            const data = await resp.json();
            // Actualiza UI si cambi√≥
            this.updatePremiumUI();
            return data;
        } catch (_) {
            // silencioso
        }
    }

    async handleStripeCheckoutReturn(retryCount = 0) {
        try {
            const url = new URL(window.location.href);
            const sessionId = url.searchParams.get('session_id');
            if (!sessionId) return;

            // Force check Clerk session if not authenticated
            if (!this.isAuthenticated || !this.user) {
                console.log('‚ö†Ô∏è User not authenticated, checking Clerk session...');
                
                // Try to get Clerk session directly
                if (window.Clerk) {
                    try {
                        // Don't reload if already initialized, just check user
                        if (!window.__clerkInitialized) {
                            console.log('‚è≥ Clerk not yet initialized, waiting...');
                            let attempts = 0;
                            while (!window.__clerkInitialized && attempts < 30) {
                                await new Promise(resolve => setTimeout(resolve, 200));
                                attempts++;
                            }
                        }
                        
                        // Check if we have a user now
                        if (window.Clerk.user) {
                            console.log('‚úÖ Clerk session restored');
                            this.isAuthenticated = true;
                            this.user = window.Clerk.user;
                            this.updateAuthState();
                        } else if (retryCount < 10) {
                            console.log(`Retrying... (${retryCount + 1}/10)`);
                            setTimeout(() => this.handleStripeCheckoutReturn(retryCount + 1), 800);
                            return;
                        } else {
                            console.error('‚ùå Could not restore Clerk session after 10 attempts');
                            return;
                        }
                    } catch (error) {
                        console.error('Error reloading Clerk session:', error);
                        if (retryCount < 10) {
                            setTimeout(() => this.handleStripeCheckoutReturn(retryCount + 1), 800);
                        }
                        return;
                    }
                } else if (retryCount < 10) {
                    console.log('Clerk not loaded yet, retrying...');
                    setTimeout(() => this.handleStripeCheckoutReturn(retryCount + 1), 800);
                    return;
                } else {
                    console.error('‚ùå Clerk not available after 10 attempts');
                    return;
                }
            }

            if (this.confirmedCheckoutSessionId === sessionId) {
                return;
            }

            this.confirmedCheckoutSessionId = sessionId;
            const userEmail = this.user.primaryEmailAddress?.emailAddress || this.user.emailAddresses?.[0]?.emailAddress || '';

            console.log('üîÑ Confirming Stripe checkout session:', sessionId);
            const response = await fetch('/api/confirm-premium', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-clerk-userid': this.user.id,
                    'x-clerk-user-email': userEmail,
                },
                body: JSON.stringify({ sessionId }),
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('‚ùå Failed to confirm checkout session:', errorData);
                this.confirmedCheckoutSessionId = null;
                return;
            }

            const confirmData = await response.json().catch(() => ({}));
            console.log('‚úÖ Checkout session confirmed with backend:', confirmData);
            
            // Track Premium Success to Mixpanel
            const paymentType = confirmData.paymentType || 'monthly';
            if (window.mixpanelTracker) {
                window.mixpanelTracker.trackCustomEvent('Premium Success', {
                    plan_type: paymentType,
                    value: paymentType === 'lifetime' ? 24.0 : 3.99,
                    source: 'stripe_checkout',
                    timestamp: new Date().toISOString()
                });
                console.log('üìä Premium Success tracked to Mixpanel:', paymentType);
            }
            
            // Track Google Ads conversion for Monthly or Lifetime
            // This is the actual purchase conversion (different from Checkout Session Created)
            try {
                if (typeof window.gtag === 'function') {
                    let conversionLabel, conversionValue;
                    
                    if (paymentType === 'lifetime') {
                        // Lifetime: $24.0 with label unsECLnWiewbENjym89B
                        conversionLabel = 'AW-17614436696/unsECLnWiewbENjym89B';
                        conversionValue = 24.0;
                    } else {
                        // Monthly: $3.99 with label wlmKCI_fiuwbENjym89B
                        conversionLabel = 'AW-17614436696/wlmKCI_fiuwbENjym89B';
                        conversionValue = 3.99;
                    }
                    
                    // Set Enhanced Conversions user data BEFORE the conversion event
                    if (userEmail && typeof window.hashEmail === 'function') {
                        try {
                            const hashedEmail = await window.hashEmail(userEmail);
                            if (hashedEmail) {
                                window.gtag('set', 'user_data', {
                                    'sha256_email_address': hashedEmail
                                });
                                console.log('‚úÖ Enhanced Conversions: User data set for', paymentType);
                            }
                        } catch (hashError) {
                            console.log('‚ö†Ô∏è Enhanced Conversions: Email hashing failed');
                        }
                    }
                    
                    window.gtag('event', 'conversion', {
                        'send_to': conversionLabel,
                        'value': conversionValue,
                        'currency': 'USD',
                        'transaction_id': sessionId
                    });
                    console.log(`üìä Google Ads ${paymentType.toUpperCase()} conversion tracked: $${conversionValue}`);
                }
            } catch (gtagError) {
                console.error('‚ö†Ô∏è Google Ads conversion tracking failed:', gtagError);
            }
            
            await this.refreshPremiumFromServer();
            this.removeUrlParams(['session_id']);
        } catch (error) {
            console.error('Error handling checkout confirmation:', error);
            if (retryCount < 10) {
                setTimeout(() => this.handleStripeCheckoutReturn(retryCount + 1), 1000);
            }
        }
    }


    toggleTaskList() {
        // üéØ Track Sidebar Panel Opened event to Mixpanel
        if (window.mixpanelTracker) {
            window.mixpanelTracker.trackSidebarPanelOpened('tasks');
            console.log('üìä Tasks panel opened event tracked to Mixpanel');
        }
        
        // Show local tasks for all users (integrations removed)
        this.showTaskListModal();
        // Don't toggle active state - keep button in normal state
    }

    handleCustomTechniqueClick(item) {
        // Check if user has a saved custom timer
        const savedCustomTimer = localStorage.getItem('customTimer');
        
        if (savedCustomTimer) {
            // User has a custom timer - select it normally
            this.selectTechnique(item);
        } else {
            // User doesn't have a custom timer - show the modal to create one
            this.showCustomTimerModal();
        }
    }
    
    toggleTimer() {
        if (this.isRunning) {
            this.pauseTimer();
        } else {
            this.startTimer();
        }
    }
    
    resetTimer() {
        // Pause timer if running
        if (this.isRunning) {
            this.pauseTimer();
        }
        
        // Reset to first section
        this.currentSection = 1;
        
        // Reload the current section (now section 1)
        this.loadCurrentSection();
        
        // Update navigation buttons
        this.updateNavigationButtons();
        
        // Update session info display
        this.updateSessionInfo();
        
        // Update progress ring
        this.updateProgressRing();
        
        // Clear saved timer state
        this.clearTimerState();
        
        // Play UI sound for feedback
        this.playUiSound('click');
    }
    
    startTimer() {
        // Enforce daily focus limit for non‚ÄëPro users
        if (this.hasReachedDailyFocusLimit()) {
            this.pauseTimerSilent();
            this.showDailyLimitModal();
            return;
        }
        
        // Check if Tron theme is active and widget is not ready
        // Widget is visible and ready, no checks needed
        
        this.isRunning = true;
        this.startPauseBtn.classList.add('running');
        this.playUiSound('play');
        
        // Show keyboard shortcut hint on first play
        this.showKeyboardHint();
        
        // üéØ Track Timer Started event to Google Analytics
        if (typeof gtag !== 'undefined') {
            gtag('event', 'timer_started', {
                event_category: 'engagement',
                event_label: 'User started focus timer',
                value: 1
            });
            
            console.log('üìä Timer started event tracked to Analytics');
        }
        
        // üéØ Track Timer Started event to Mixpanel
        if (window.mixpanelTracker) {
            const currentSectionInfo = this.cycleSections[this.currentSection - 1];
            const sessionType = currentSectionInfo.type === 'work' ? 'work' : 
                               currentSectionInfo.type === 'long-break' ? 'long_break' : 'short_break';
            
            window.mixpanelTracker.trackTimerStart(
                sessionType, 
                currentSectionInfo.duration, 
                this.currentTaskName
            );
            
            console.log('üìä Timer started event tracked to Mixpanel');
        }
        
        // Close all open modals to focus on timer
        this.closeAllModals();
        
        // Resume background music if enabled
        if (this.lofiEnabled) {
            const hasProgress = this.backgroundAudio && !isNaN(this.backgroundAudio.currentTime) && this.backgroundAudio.currentTime > 0;
            if (hasProgress && /\/audio\/Lofi\//.test(this.backgroundAudio.currentSrc || '')) {
                this.resumeLofiPlaylist();
            } else {
                this.playLofiPlaylist();
            }
        }
        
        
        this.interval = setInterval(() => {
            this.timeLeft--;
            this.updateDisplay();
            this.updateProgress();
            this.updateSections();
            this.updateSessionInfo();
            
            // Save timer state every second (uses sessionStorage - persists on reload but not on tab close)
            this.saveTimerState();
            
            // Music ducking: fade out 2s before end of section to prioritize alerts
            // Accumulate focus seconds for day streak when on a focus session and not cheating
            if (this.isWorkSession && !this.isLongBreak) {
                // If user skipped sections, we mark cheatedDuringFocusInCycle elsewhere; here we only count naturally ticking time
                this.focusSecondsToday = (this.focusSecondsToday || 0) + 1;
                this.saveFocusSecondsToday(this.focusSecondsToday);
                // Once we pass 60s and haven't counted a streak yet today, award it
                if ((this.focusSecondsToday >= 60) && !this.hasCompletedFocusToday) {
                    this.updateStreak();
                }
            }
            if (this.timeLeft === 2) {
                this.fadeMusicOut(2000);
                this.isDucked = true;
            }
            
            // Realtime tracking: focus-only for total focus time
            if (this.currentSection % 2 === 1) {
                this.addFocusTime(1);
                // If user crosses the 120-minute threshold now, start cooldown
                if (!this.isPremiumUser() && (this.focusSecondsToday || 0) >= this.DAILY_FOCUS_LIMIT_SECONDS && !this.focusLimitCooldownUntil) {
                    this.focusLimitCooldownUntil = Date.now() + this.FOCUS_LIMIT_COOLDOWN_MS;
                    const cooldownExpiresAt = new Date(this.focusLimitCooldownUntil);
                    console.log('üö´ Daily focus limit reached! Cooldown activated:', {
                        focusSecondsToday: this.focusSecondsToday,
                        cooldownDurationHours: this.FOCUS_LIMIT_COOLDOWN_MS / (60 * 60 * 1000),
                        cooldownExpiresAt: cooldownExpiresAt.toLocaleString(),
                        cooldownTimestamp: this.focusLimitCooldownUntil
                    });
                    try { localStorage.setItem('focusLimitCooldownUntil', String(this.focusLimitCooldownUntil)); } catch (_) {}
                }
                if (this.hasReachedDailyFocusLimit()) {
                    this.pauseTimer();
                    this.showDailyLimitModal();
                    return; // stop ticking further
                }
            }
            // Realtime tracking: technique time (focus + breaks) for Most Used Technique
            this.addTechniqueTime(1);
            
            if (this.timeLeft <= 0) {
                this.completeSession();
            }
        }, 1000);
    }
    
    pauseTimer() {
        this.isRunning = false;
        this.startPauseBtn.classList.remove('running');
        
        clearInterval(this.interval);
        this.playUiSound('pause');
        
        // üéØ Track Timer Paused event to Mixpanel
        if (window.mixpanelTracker) {
            window.mixpanelTracker.trackTimerPause();
            console.log('üìä Timer paused event tracked to Mixpanel');
        }
        
        // Close all open modals to focus on timer
        this.closeAllModals();
        
        // Pause background music if playing
        if (this.lofiPlaying) {
            this.pauseLofiPlaylist();
        }
        
        
        // Update session info to potentially show "Ready to focus?"
        this.updateSessionInfo();
        
        // Update title to show paused state
        const minutes = Math.floor(this.timeLeft / 60);
        const seconds = this.timeLeft % 60;
        const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        // Use current task content for title
        let titleText;
        if (this.currentTaskName) {
            titleText = this.currentTaskName;
        } else {
            // Fallback to session type if no current task
            if (this.isWorkSession) {
                titleText = 'Focus';
            } else {
                titleText = this.isLongBreak ? 'Long Break' : 'Short Break';
            }
        }
        document.title = `${timeString} - ${titleText} (Paused)`;
    }
    
    pauseTimerSilent() {
        this.isRunning = false;
        this.startPauseBtn.classList.remove('running');
        
        clearInterval(this.interval);
        
        // Close all open modals to focus on timer
        this.closeAllModals();
        
        // Pause background music if playing
        if (this.ambientPlaying || this.buryTheLightPlaying || this.rainPlaying || this.naturePlaying) {
            if (this.naturePlaying) {
                this.pauseNatureSound();
            } else {
                this.pausePlaylist();
            }
        }
        
        // Pause Lofi music if playing
        if (this.lofiPlaying) {
            this.pauseLofiPlaylist();
        }
        
        // Pause Tron music if Tron theme is active
        if (this.currentImmersiveTheme === 'tron') {
            this.pauseTronMusic();
        }
        
        // No sound - silent pause
        
        // Update title to show paused state
        const minutes = Math.floor(this.timeLeft / 60);
        const seconds = this.timeLeft % 60;
        const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        // Use current task content for title
        let titleText;
        if (this.currentTaskName) {
            titleText = this.currentTaskName;
        } else {
            // Fallback to session type if no current task
            if (this.isWorkSession) {
                titleText = 'Focus';
            } else {
                titleText = this.isLongBreak ? 'Long Break' : 'Short Break';
            }
        }
        document.title = `${timeString} - ${titleText} (Paused)`;
    }
    
    goToPreviousSection() {
        if (this.currentSection > 1) {
            this.pauseTimerSilent(); // Pause without sound
            
            // üéØ Track Timer Skipped event to Mixpanel
            if (window.mixpanelTracker) {
                const currentSectionInfo = this.cycleSections[this.currentSection - 1];
                const sessionType = currentSectionInfo.type === 'work' ? 'work' : 
                                   currentSectionInfo.type === 'long-break' ? 'long_break' : 'short_break';
                
                window.mixpanelTracker.trackTimerSkip(sessionType, 'navigation');
                console.log('üìä Timer skipped (previous) event tracked to Mixpanel');
            }
            
            // Track time completed in current focus session before jumping
            if (this.currentSection % 2 === 1 && this.isWorkSession) { // if currently in a focus session
                const timeCompleted = this.cycleSections[this.currentSection - 1].duration - this.timeLeft;
                this.actualFocusTimeCompleted += timeCompleted;
            }
            this.currentSection--;
            this.loadCurrentSection();
            this.updateNavigationButtons();
        }
    }
    
    goToNextSection() {
        if (this.currentSection < this.cycleSections.length) {
            this.pauseTimerSilent(); // Pause without sound
            
            // üéØ Track Timer Skipped event to Mixpanel
            if (window.mixpanelTracker) {
                const currentSectionInfo = this.cycleSections[this.currentSection - 1];
                const sessionType = currentSectionInfo.type === 'work' ? 'work' : 
                                   currentSectionInfo.type === 'long-break' ? 'long_break' : 'short_break';
                
                window.mixpanelTracker.trackTimerSkip(sessionType, 'navigation');
                console.log('üìä Timer skipped (next) event tracked to Mixpanel');
            }
            
            // Track time completed in current focus session before jumping
            if (this.currentSection % 2 === 1 && this.isWorkSession) { // if currently in a focus session
                const timeCompleted = this.cycleSections[this.currentSection - 1].duration - this.timeLeft;
                this.actualFocusTimeCompleted += timeCompleted;
            }
            this.currentSection++;
            this.loadCurrentSection();
            this.updateNavigationButtons();
        }
    }
    
    loadCurrentSection() {
        const currentSectionInfo = this.cycleSections[this.currentSection - 1];
        this.timeLeft = currentSectionInfo.duration;
        
        // Update session type flags
        this.isWorkSession = currentSectionInfo.type === 'work';
        this.isLongBreak = currentSectionInfo.type === 'long-break';
        
        // Update current session task
        this.updateCurrentSessionTask();
        
        // Keep task label in sync with completed sessions (only for work sessions)
        if (this.isWorkSession) {
            try {
                // Calculate how many task slots have been completed so far
                const selected = this.getSelectedTasks();
                let slotsCompleted = 0;
                selected.forEach(task => {
                    const cfg = this.getTaskConfig(task.id);
                    const total = Math.max(1, cfg.sessions || 1);
                    const done = Math.min(cfg.completedSessions || 0, total);
                    slotsCompleted += done;
                });
                if (Array.isArray(this.taskQueue) && this.taskQueue.length > 0) {
                    if (slotsCompleted >= this.taskQueue.length) {
                        this.currentTaskIndex = this.taskQueue.length; // beyond queue ‚Üí Focus label
                        this.currentTask = null;
                    } else {
                        this.currentTaskIndex = slotsCompleted;
                        this.currentTask = this.taskQueue[this.currentTaskIndex];
                    }
                }
            } catch (_) {}
        } else {
            // For breaks, set current task based on break type
            if (this.isLongBreak) {
                this.currentTask = { content: "Long Break", source: 'break' };
            } else {
                this.currentTask = { content: "Short Break", source: 'break' };
            }
            this.currentTaskName = this.currentTask.content;
        }
        
        this.updateCurrentTaskFromQueue();
        this.updateDisplay();
        this.updateProgress();
        this.updateSections();
        this.updateSessionInfo();
    }
    
    updateNavigationButtons() {
        // Update previous button
        if (this.prevSectionBtn) {
            this.prevSectionBtn.disabled = this.currentSection <= 1;
        }
        
        // Update next button
        if (this.nextSectionBtn) {
            this.nextSectionBtn.disabled = this.currentSection >= this.cycleSections.length;
        }
    }
    
    handleKeydown(e) {
        // Command+K or Ctrl+K to open shortcuts modal (handle before input check)
        if ((e.metaKey || e.ctrlKey) && e.code === 'KeyK') {
            e.preventDefault();
            this.showShortcutsModal();
            return;
        }
        
        // Only handle other shortcuts if no input/textarea is focused
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            return;
        }
        
        // Space or Enter to toggle timer
        if (e.code === 'Space' || e.code === 'Enter') {
            e.preventDefault(); // Prevent page scroll on space
            this.toggleTimer();
        }
        
        // R to reset timer (with confirmation)
        if (e.code === 'KeyR') {
            e.preventDefault();
            this.showResetConfirmationModal();
        }
        
        
        // A or ArrowLeft for previous section
        if (e.code === 'KeyA' || e.code === 'ArrowLeft') {
            e.preventDefault();
            this.goToPreviousSection();
        }
        
        // D or ArrowRight for next section
        if (e.code === 'KeyD' || e.code === 'ArrowRight') {
            e.preventDefault();
            this.goToNextSection();
        }
    }
    completeSession() {
        // Always stop ticking immediately
        this.pauseTimer();
        
        // Play notification sound
        this.playNotification();
        
        // üéØ Track Timer Completed event to Mixpanel
        if (window.mixpanelTracker) {
            const currentSectionInfo = this.cycleSections[this.currentSection - 1];
            const sessionType = currentSectionInfo.type === 'work' ? 'work' : 
                               currentSectionInfo.type === 'long-break' ? 'long_break' : 'short_break';
            
            window.mixpanelTracker.trackTimerComplete(sessionType, true);
            console.log('üìä Timer completed event tracked to Mixpanel');
        }
        
        // Track break completion if this was a break session
        if (!this.isWorkSession && this.isAuthenticated) {
            this.addBreakTime();
        }
        
        // Track work session completion if this was a work session
        if (this.isWorkSession && this.isAuthenticated) {
            this.addWorkSession();
        }
        
        // Advance section pointer
        const finishedWasFocus = this.isWorkSession === true;
        this.currentSection++;
        
        // Did we just finish the last section of the cycle?
        let cycleCompleted = false;
        let lastCycleWasLegitimate = false;
        if (this.currentSection > this.cycleSections.length) {
            cycleCompleted = true;
            this.currentSection = 1; // reset to first section of next cycle
            
            // Add time from the last completed focus session
            if (finishedWasFocus) {
                const timeCompleted = this.cycleSections[this.currentSection - 2].duration; // Previous section (just finished)
                this.actualFocusTimeCompleted += timeCompleted;
            }
            
            // Check if enough focus time was actually completed
            lastCycleWasLegitimate = (this.actualFocusTimeCompleted >= this.requiredFocusTimeForCycle);
            if (lastCycleWasLegitimate) {
                this.updateCycleCounter();
                
                // üéØ Track Cycle Completed event to Mixpanel
                if (window.mixpanelTracker) {
                    const currentTechnique = this.getCurrentTechniqueName();
                    const cycleDuration = this.cycleSections.reduce((total, section) => total + section.duration, 0);
                    const workSessions = this.cycleSections.filter(section => section.type === 'work').length;
                    const shortBreaks = this.cycleSections.filter(section => section.type === 'break').length;
                    const longBreaks = this.cycleSections.filter(section => section.type === 'long-break').length;
                    
                    window.mixpanelTracker.trackCycleComplete(currentTechnique, cycleDuration, workSessions, shortBreaks, longBreaks);
                    console.log('üìä Cycle completed event tracked to Mixpanel');
                    
                    // Save current task name before it gets reset
                    this._lastTaskName = this.currentTaskName;
                    
                    // Show cycle completion stats modal
                    this.showCycleStatsModal({
                        cycleDuration: cycleDuration,
                        workSessions: workSessions
                    });
                }
            }
            // Reset focus time tracker for next cycle
            this.actualFocusTimeCompleted = 0;
        }
        
        // Count time from naturally finished focus session (when not using Next/Back)
        if (finishedWasFocus) {
            const timeCompleted = this.cycleSections[this.currentSection - 2].duration; // Previous section (just finished)
            this.actualFocusTimeCompleted += timeCompleted;
            // Advance queue BEFORE loading next section so the label updates immediately
            this.advanceTaskQueueAfterFocus();
            
            // Refresh task panel if it's open to show real-time updates
            this.refreshTaskModalIfOpen();
            
            // Update day streak only if no cheating occurred during focus session
            if (!this.cheatedDuringFocusInCycle) {
                this.updateStreak();
            }
        }

        // Load current section data
        const currentSectionInfo = this.cycleSections[this.currentSection - 1];
        this.timeLeft = currentSectionInfo.duration;
        this.isWorkSession = currentSectionInfo.type === 'work';
        this.isLongBreak = currentSectionInfo.type === 'long-break';
        
        // Update UI to reflect the next section
        this.updateCurrentTaskFromQueue();
        this.updateDisplay();
        this.updateProgress();
        this.updateSections();
        this.updateSessionInfo();
        this.updateCurrentSessionTask();

        if (cycleCompleted) {
            // Ensure fully paused state and correct button/title
            this.pauseTimerSilent();
            this.startPauseBtn.classList.remove('running');
            this.isRunning = false;
            // Clear saved timer state when cycle completes
            this.clearTimerState();
            // No modal, just stop at end of cycle
            return;
        }
        
        // Not end of cycle ‚Üí auto-start next section after brief delay
        setTimeout(() => {
            this.startTimer();
            // After new section starts, restore music after 2s
            setTimeout(() => {
                if (this.isDucked) {
                    this.fadeMusicIn(2000);
                    this.isDucked = false;
                }
            }, 2000);
        }, 600);
    }
    
    updateDisplay() {
        const minutes = Math.floor(this.timeLeft / 60);
        const seconds = this.timeLeft % 60;
        const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // Update main display
        this.timeElement.textContent = timeString;
        
        // Update task name display
        this.updateTaskNameDisplay();
        
        // Update browser tab title with current task content
        let titleText;
        if (this.currentTaskName) {
            titleText = this.currentTaskName;
        } else {
            // Fallback to session type if no current task
            if (this.isWorkSession) {
                titleText = 'Focus';
            } else {
                titleText = this.isLongBreak ? 'Long Break' : 'Short Break';
            }
        }
        document.title = `${timeString} - ${titleText}`;
    }
    
    updateTaskNameDisplay() {
        if (this.taskNameDisplay) {
            let displayText;
            if (this.isLongBreak) {
                displayText = 'Long Break';
            } else if (!this.isWorkSession) {
                displayText = 'Short Break';
            } else {
                // Focus session
                displayText = this.currentTaskName || 'Focus';
            }
            this.taskNameDisplay.textContent = displayText;
        }
    }
    
    
    updateSessionDots() {
        if (!this.sessionDots) return;
        
        // Clear existing dots
        this.sessionDots.innerHTML = '';
        
        // Get total sessions for current technique
        const totalSessions = this.cycleSections.filter(s => s.type === 'work').length;
        
        // Calculate completed sessions
        let completedSessions = 0;
        for (let i = 0; i < this.currentSection; i++) {
            if (this.cycleSections[i] && this.cycleSections[i].type === 'work') {
                completedSessions++;
            }
        }
        
        // Create dots for each session
        for (let i = 0; i < totalSessions; i++) {
            const dot = document.createElement('div');
            dot.className = 'session-dot';
            if (i < completedSessions) {
                dot.classList.add('completed');
            }
            this.sessionDots.appendChild(dot);
        }
    }
    
    updateProgress() {
        const currentSectionInfo = this.cycleSections[this.currentSection - 1];
        const totalTime = currentSectionInfo.duration;
        
        // Elapsed within current section (in seconds)
        const elapsedInSection = currentSectionInfo.duration - this.timeLeft;
        const sectionProgress = Math.max(0, Math.min(1, elapsedInSection / totalTime));
        
        // SIMPLIFIED: Only show current section progress (Tesla style)
        // Show a simple circular progress for the current session only
        const CIRCUMFERENCE = 2 * Math.PI * 45; // 283
        const progressLength = CIRCUMFERENCE * sectionProgress;
        
        // Hide all overlays except the first one (we'll use it for current progress)
        this.progressOverlays.forEach((ol, i) => {
            if (i === 0) {
                // Show only the current section progress
                ol.style.display = 'inline';
                ol.style.stroke = '#ffffff';
                ol.setAttribute('stroke-dasharray', `${progressLength} ${CIRCUMFERENCE}`);
                ol.setAttribute('stroke-dashoffset', '0');
            } else {
                // Hide all other overlays
                ol.style.display = 'none';
            }
        });
    }
    
    updateSegmentedProgress(totalProgress) {
        const { CIRCUMFERENCE, GAP, scaledLengths } = this._segmentMeta;
        
        // Update each overlay to match its own segment completion
        let cursor = 0;
        this.progressOverlays.forEach((ol, i) => {
            if (i < scaledLengths.length) {
                const segLen = scaledLengths[i];
                let fillLen = 0;

                // Set overlay color based on section type
                // Color-coded indicators per segment type
                const section = this.cycleSections[i];
                if (section) {
                    switch (section.type) {
                        case 'work':
                            ol.style.stroke = '#ffffff'; // White for work
                            break;
                        case 'break':
                            ol.style.stroke = '#ffffff'; // White for short breaks
                            break;
                        case 'long-break':
                            ol.style.stroke = '#ffffff'; // White for long breaks
                            break;
                        default:
                            ol.style.stroke = '#ffffff';
                    }
                }
                
                // Check if this segment should be visible
                if (totalProgress > cursor) {
                    // This segment has started
                    if (totalProgress >= cursor + segLen) {
                        // Segment is fully filled
                        fillLen = segLen;
                    } else {
                        // Segment is partially filled
                        const progressInSegment = totalProgress - cursor;
                        if (progressInSegment > 0) {
                            fillLen = Math.min(progressInSegment, segLen);
                        }
                    }
                }

                if (fillLen > 0) {
                    ol.style.display = 'inline';
                    ol.setAttribute('stroke-dasharray', `${fillLen} ${CIRCUMFERENCE}`);
                    ol.setAttribute('stroke-dashoffset', `${-cursor}`);
                } else {
                    // Hide completely to avoid small round-cap dots at segment start
                    ol.style.display = 'none';
                }

                // Move cursor to next segment position (including gap)
                cursor += segLen + GAP;
            } else {
                // Hide extra overlays if current technique has fewer sections
                ol.style.display = 'none';
            }
        });
    }
    
    updateSections() {
        // No highlight: segments remain uniform per type
        this.updateSessionDots();
    }
    

    // Get total number of focus sessions for current technique
    getTotalFocusSessions() {
        return this.sessionsPerCycle || 4; // Default to 4 if not set
    }

    // Build an execution queue from selected tasks and their configured sessions
    rebuildTaskQueue() {
        console.log('üîÑ rebuildTaskQueue called');
        
        // Only include tasks that are explicitly selected
        const selected = this.getSelectedTasks();
        console.log('üîÑ Selected tasks:', selected.map(t => ({ 
            id: t.id, 
            content: t.content,
            config: this.getTaskConfig(t.id)
        })));
        
        const queue = [];
        
        // Calculate total sessions needed
        const totalSessions = this.getTotalFocusSessions();
        console.log('üîÑ Total focus sessions in technique:', totalSessions);
        
        selected.forEach(task => {
            const config = this.getTaskConfig(task.id);
            const taskTotalSessions = Math.max(1, config.sessions || 1);
            const completedSessions = config.completedSessions || 0;
            const remainingSessions = Math.max(0, taskTotalSessions - completedSessions);
            
            console.log(`üîÑ Task ${task.content}: total=${taskTotalSessions}, completed=${completedSessions}, remaining=${remainingSessions}`);
            
            for (let i = 0; i < remainingSessions; i++) {
                queue.push({ id: task.id, content: task.content, source: task.source || 'local' });
            }
        });
        
        // If we have more focus sessions than tasks, add empty slots for the extra sessions
        const totalTaskSlots = queue.length;
        if (totalSessions > totalTaskSlots) {
            const extraSessions = totalSessions - totalTaskSlots;
            console.log(`üîÑ Adding ${extraSessions} empty slots`);
            for (let i = 0; i < extraSessions; i++) {
                queue.push({ id: null, content: '', source: 'empty' });
            }
        }
        
        this.taskQueue = queue;
        this.currentTaskIndex = 0;
        this.currentTask = this.taskQueue.length > 0 ? this.taskQueue[0] : null;
        
        console.log('üîÑ Final taskQueue:', queue.map(t => ({ id: t.id, content: t.content })));
        console.log('üîÑ Final taskQueue.length:', queue.length);

        // Keep sessionTasks in sync with taskQueue
        this.updateSessionTasksFromSelected();

    }

    getCurrentTaskLabel() {
        // Show session type instead of "Add Task"
        if (this.isWorkSession) {
            return 'Pomodoro';
        } else if (this.isLongBreak) {
            return 'Long Break';
        } else {
            return 'Short Break';
        }
    }

    // Advance to next task slot after finishing a focus session
    advanceTaskQueueAfterFocus() {
        console.log('üöÄ advanceTaskQueueAfterFocus called', {
            taskQueueLength: this.taskQueue?.length,
            currentTask: this.currentTask,
            currentTaskIndex: this.currentTaskIndex
        });
        
        if (!this.taskQueue || this.taskQueue.length === 0) return;
        
        // Increment completed sessions for current task (only if it's a real task, not empty slot)
        const finishedTaskId = this.currentTask && this.currentTask.id ? this.currentTask.id : null;
        console.log('üöÄ finishedTaskId:', finishedTaskId);
        
        if (finishedTaskId) {
            this.incrementTaskCompletedSessions(finishedTaskId);
            // If the task reached its planned sessions, mark completed and rebuild queue
            const cfg = this.getTaskConfig(finishedTaskId);
            const planned = Math.max(1, cfg.sessions || 1);
            const done = cfg.completedSessions || 0;
            const taskFinished = done >= planned;
            console.log('üöÄ Task completion check:', { planned, done, taskFinished });
            
            if (taskFinished) {
                console.log('üöÄ Task finished! Marking as completed and rebuilding queue');
                try { this.markLocalTaskAsCompleted(finishedTaskId); } catch (_) {}
                // Queue rebuilt from remaining selected tasks
                console.log('üöÄ After rebuild, taskQueue.length:', this.taskQueue?.length);
                if (this.taskQueue && this.taskQueue.length > 0) {
                    this.currentTaskIndex = 0;
                    this.currentTask = this.taskQueue[0];
                } else {
                    this.currentTaskIndex = 0;
                    this.currentTask = null; // Will show Focus
                }
                return;
            }
        }
        
        // Advance to next slot in queue
        if (this.currentTaskIndex < this.taskQueue.length - 1) {
            this.currentTaskIndex += 1;
            this.currentTask = this.taskQueue[this.currentTaskIndex];
        } else {
            // End of queue, fallback to Focus
            this.currentTask = null;
        }
    }

    openTasksCompletedModal() {}

    markLocalTaskAsCompleted(taskId) {
        if (!taskId) return;
        const tasks = this.getLocalTasks();
        const idx = tasks.findIndex(t => t.id === taskId);
        if (idx !== -1) {
            tasks[idx].completed = true;
            tasks[idx].completedAt = new Date().toISOString();
            
            // Track actual focus time completed for this task
            // Get current session's actual focus time from actualFocusTimeCompleted
            const taskConfig = this.getTaskConfig(taskId);
            const completedFocusTime = taskConfig.completedFocusTime || 0;
            const newFocusTime = completedFocusTime + this.actualFocusTimeCompleted;
            
            this.setTaskConfig(taskId, { 
                completedFocusTime: newFocusTime,
                selected: false 
            });
            
            this.setLocalTasks(tasks);
            
            // Re-render task panel to show in history immediately
            if (document.getElementById('taskSidePanel')?.classList.contains('open')) {
                this.renderTasksInSidePanel();
            }
        }
        // Deselect the completed task so it doesn't show the blue accent
        this.setTaskConfig(taskId, { selected: false });
        this.updateCurrentTaskBanner();
        this.rebuildTaskQueue();
    }

    showTaskCompletedModal() {}
    
    updateSessionInfo() {
        // Tesla-style: Combined label "Pomodoro 1/4" OR "Ready to focus?"
        if (this.sessionLabelElement) {
            // Show "Ready to focus?" ONLY for Pomodoro/Focus sessions when:
            // 1. Timer hasn't been started (!isRunning)
            // 2. Timer is at initial time (fresh state)
            // 3. Currently in a work session (not break)
            const isAtInitialTime = this.timeLeft === this.cycleSections[this.currentSection - 1]?.duration;
            const shouldShowReadyToFocus = !this.isRunning && isAtInitialTime && this.isWorkSession;
            
            // Helper function to add chevron icon to session label
            const createSessionLabelHTML = (text) => {
                return `<span>${text}</span><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="session-label-icon"><path d="m9 18 6-6-6-6"/></svg>`;
            };
            
            if (shouldShowReadyToFocus) {
                this.sessionLabelElement.innerHTML = createSessionLabelHTML('Ready to focus?');
            } else {
                // Show session info: "Pomodoro 1/4", "Short Break", etc.
                const workSessions = this.cycleSections.filter(s => s.type === 'work');
                const totalWorkSessions = workSessions.length;
                
                // Calculate current work session number
                let currentWorkSession = 0;
                for (let i = 0; i < this.currentSection; i++) {
                    if (this.cycleSections[i] && this.cycleSections[i].type === 'work') {
                        currentWorkSession++;
                    }
                }
                
                // Get session type
                const sessionLabel = this.getCurrentTaskLabel();
                
                // Helper function to truncate text to max 20 characters
                const truncateText = (text, maxLength = 20) => {
                    if (!text) return text;
                    // Count actual characters including emojis, spaces, etc.
                    const chars = Array.from(text);
                    if (chars.length <= maxLength) return text;
                    return chars.slice(0, maxLength).join('') + '...';
                };
                
                // Combine: "Task Name 1/4" or "Pomodoro 1/4", "Short Break", "Long Break"
                if (this.isWorkSession) {
                    // Use task name if available, otherwise use session label (Pomodoro)
                    const displayName = this.currentTaskName ? truncateText(this.currentTaskName) : sessionLabel;
                    this.sessionLabelElement.innerHTML = createSessionLabelHTML(`${displayName} ${currentWorkSession}/${totalWorkSessions}`);
                } else {
                    this.sessionLabelElement.innerHTML = createSessionLabelHTML(sessionLabel);
                }
            }
        }
        
        // Keep for backward compatibility (hidden via CSS)
        if (this.sessionInfoElement) {
            const workSessions = this.cycleSections.filter(s => s.type === 'work');
            const totalWorkSessions = workSessions.length;
            let currentWorkSession = 0;
            for (let i = 0; i < this.currentSection; i++) {
                if (this.cycleSections[i] && this.cycleSections[i].type === 'work') {
                    currentWorkSession++;
                }
            }
            this.sessionInfoElement.textContent = `${currentWorkSession}/${totalWorkSessions}`;
        }
        
        // Update current task display (hidden via CSS)
        this.updateCurrentTaskDisplay();
    }
    
    setCurrentTask(taskName) {
        this.currentTaskName = taskName;
        this.updateCurrentTaskDisplay();
        this.updateTaskNameDisplay();
    }
    
    clearCurrentTask() {
        this.currentTaskName = null;
        this.updateCurrentTaskDisplay();
        this.updateTaskNameDisplay();
    }
    
    updateCurrentTaskDisplay() {
        if (this.currentTaskElement) {
            // Show session type: Pomodoro, Short Break, or Long Break
            const sessionLabel = this.getCurrentTaskLabel();
            this.currentTaskElement.textContent = sessionLabel;
                this.currentTaskElement.style.display = 'block';
        }
    }

    updateCurrentTaskFromQueue() {
        const selected = this.getSelectedTasks();
        console.log('üéØ updateCurrentTaskFromQueue called', {
            isWorkSession: this.isWorkSession,
            currentSection: this.currentSection,
            taskQueueLength: this.taskQueue?.length,
            taskQueue: this.taskQueue?.map(t => ({ content: t.content, id: t.id })),
            selectedTasks: selected.map(t => ({ 
                content: t.content, 
                id: t.id,
                config: this.getTaskConfig(t.id)
            }))
        });
        
        // Update current task based on task queue and current session
        if (this.isWorkSession && this.taskQueue && this.taskQueue.length > 0) {
            // Calculate how many task slots have been completed so far
            
            let slotsCompleted = 0;
            selected.forEach(task => {
                const cfg = this.getTaskConfig(task.id);
                const total = Math.max(1, cfg.sessions || 1);
                const done = Math.min(cfg.completedSessions || 0, total);
                console.log(`üéØ Task ${task.content}: total=${total}, done=${done}`);
                slotsCompleted += done;
            });
            
            console.log('üéØ slotsCompleted:', slotsCompleted, 'taskQueue.length:', this.taskQueue.length);
            
            if (slotsCompleted >= this.taskQueue.length) {
                this.currentTaskIndex = this.taskQueue.length; // beyond queue ‚Üí Focus label
                this.currentTask = null;
                this.currentTaskName = null;
                console.log('üéØ All tasks completed, setting currentTaskName to null');
            } else {
                this.currentTaskIndex = slotsCompleted;
                this.currentTask = this.taskQueue[this.currentTaskIndex];
                this.currentTaskName = this.currentTask ? this.currentTask.content : null;
                console.log('üéØ Setting currentTaskName to:', this.currentTaskName, 'at index', this.currentTaskIndex);
            }
        } else {
            // Not in work session (Short Break or Long Break) OR no tasks selected
            // Always clear current task display for breaks
            this.currentTask = null;
            this.currentTaskName = null;
            console.log('üéØ Not in work session or no tasks, setting currentTaskName to null');
        }
        
        console.log('üéØ Final currentTaskName:', this.currentTaskName);
        this.updateCurrentTaskDisplay();
        this.updateTaskNameDisplay();
    }
    
    // Initialize tasks for each focus session from selected tasks
    initializeSessionTasks() {
        this.updateSessionTasksFromSelected();
        this.updateCurrentSessionTask();
    }
    
    // Update session tasks from selected tasks in modal
    updateSessionTasksFromSelected() {
        const selectedTasks = this.getSelectedTasks();
        
        // Only reset sessionTasks if we have selected tasks (user actively selected tasks)
        // Don't reset when changing techniques if no tasks are selected
        if (selectedTasks.length > 0) {
            this.sessionTasks = [];
            
            // Build task queue from selected tasks
            selectedTasks.forEach(task => {
                const config = this.getTaskConfig(task.id);
                const totalSessions = Math.max(1, config.sessions || 1);
                const completedSessions = config.completedSessions || 0;
                const remainingSessions = Math.max(0, totalSessions - completedSessions);
                
                for (let i = 0; i < remainingSessions; i++) {
                    this.sessionTasks.push(task.content);
                }
            });
        }
        // If no tasks selected, keep existing sessionTasks (don't reset them)
        
        // Calculate total sessions needed
        const totalSessions = this.getTotalFocusSessions();
        
        // If we have more focus sessions than tasks, add empty slots for the extra sessions
        const totalTaskSlots = this.sessionTasks.length;
        if (totalSessions > totalTaskSlots) {
            const extraSessions = totalSessions - totalTaskSlots;
            for (let i = 0; i < extraSessions; i++) {
                this.sessionTasks.push(''); // Empty string for sessions without tasks
            }
        }
        
        // If no tasks are selected, use default tasks
        if (this.sessionTasks.length === 0) {
            this.sessionTasks = [
                "Aplicando a Jobs",
                "Making Interviews", 
                "Studying React",
                "Writing Documentation",
                "Code Review",
                "Planning Sprint",
                "Learning TypeScript",
                "Designing UI"
            ];
        }
    }
    
    // Update current session task based on current section
    updateCurrentSessionTask() {
        if (this.isWorkSession && this.sessionTasks.length > 0) {
            // Calculate which focus session this is (1, 3, 5, 7 for a 4-session cycle)
            const focusSessionNumber = Math.floor((this.currentSection + 1) / 2);
            const taskIndex = focusSessionNumber - 1;
            
            // If we have a task for this session and it's not empty, use it
            if (taskIndex < this.sessionTasks.length && this.sessionTasks[taskIndex] && this.sessionTasks[taskIndex] !== '') {
                this.setCurrentTask(this.sessionTasks[taskIndex]);
            } else {
                // If no task for this session (empty slot), clear the task to show just "Focus"
                this.clearCurrentTask();
            }
        } else if (this.isLongBreak) {
            // Show long break information
            this.setCurrentTask("Long Break");
        } else {
            // Show short break information
            this.setCurrentTask("Short Break");
        }
    }
    
    // Example tasks for demonstration
    getExampleTasks() {
        return [
            "Aplicando a Jobs",
            "Making Interviews", 
            "Studying React",
            "Writing Documentation",
            "Code Review",
            "Planning Sprint",
            "Learning TypeScript",
            "Designing UI"
        ];
    }
    
    // Method to cycle through tasks for current session
    cycleToNextTask() {
        if (this.isWorkSession && this.sessionTasks.length > 0) {
            const focusSessionNumber = Math.floor((this.currentSection + 1) / 2);
            const taskIndex = Math.min(focusSessionNumber - 1, this.sessionTasks.length - 1);
            
            // Get all available tasks (from selected tasks or default)
            const selectedTasks = this.getSelectedTasks();
            let allTasks = [];
            
            if (selectedTasks.length > 0) {
                allTasks = selectedTasks.map(task => task.content);
            } else {
                allTasks = this.getExampleTasks();
            }
            
            const currentIndex = allTasks.indexOf(this.sessionTasks[taskIndex]);
            const nextIndex = (currentIndex + 1) % allTasks.length;
            
            // Update the task for this session
            this.sessionTasks[taskIndex] = allTasks[nextIndex];
            this.setCurrentTask(this.sessionTasks[taskIndex]);
        }
    }
    
    playNotification() {
        // Create a simple beep sound using Web Audio API
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        } catch (error) {
            console.log('Audio notification not supported');
        }
    }
    
    // checkWelcomeModal() - REMOVED
    
    // checkPomodoroIntro() - REMOVED
    // showPomodoroIntro() - REMOVED  
    // closePomodoroIntro() - REMOVED

    showLofiLoginModal() {
        // Create login required modal using upgrade modal styling (same as techniques)
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'upgrade-modal-overlay signup-reminder';
        
        const modal = document.createElement('div');
        modal.className = 'upgrade-modal';
        
        modal.innerHTML = `
            <button class="close-upgrade-x" id="closeLofiLoginModal">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <div class="upgrade-content">
                <div class="upgrade-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 18V5l12-2v13"/>
                        <circle cx="6" cy="18" r="3"/>
                        <circle cx="18" cy="16" r="3"/>
                    </svg>
                </div>
                <h3>Lofi Music</h3>
                <p>Curated beats for deep focus. Create a free account to unlock this premium background music.</p>
                <div class="upgrade-features">
                    <div class="upgrade-feature">
                        <span class="upgrade-feature-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 6 9 17l-5-5"/>
                            </svg>
                        </span>
                        <span class="upgrade-feature-text">Curated lofi beats for optimal focus</span>
                    </div>
                    <div class="upgrade-feature">
                        <span class="upgrade-feature-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 6 9 17l-5-5"/>
                            </svg>
                        </span>
                        <span class="upgrade-feature-text">Multiple playlists to match your mood</span>
                    </div>
                    <div class="upgrade-feature">
                        <span class="upgrade-feature-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 6 9 17l-5-5"/>
                            </svg>
                        </span>
                        <span class="upgrade-feature-text">High-quality audio for immersive experience</span>
                    </div>
                    <div class="upgrade-feature">
                        <span class="upgrade-feature-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 6 9 17l-5-5"/>
                            </svg>
                        </span>
                        <span class="upgrade-feature-text">Seamless integration with all focus techniques</span>
                </div>
                </div>
                <div class="upgrade-required-buttons">
                    <button class="upgrade-btn" id="lofiSignupBtn">Sign up for free</button>
                    <button class="cancel-btn" id="lofiMaybeLaterBtn">Maybe later</button>
                </div>
            </div>
        `;
        
        modalOverlay.appendChild(modal);
        document.body.appendChild(modalOverlay);
        
        // Event listeners
        const closeBtn = modal.querySelector('#closeLofiLoginModal');
        closeBtn.addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
        });
        
        const signupBtn = modal.querySelector('#lofiSignupBtn');
        signupBtn.addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
            window.location.href = 'https://accounts.superfocus.live/sign-up?redirect_url=' + encodeURIComponent(window.location.href);
        });
        
        const cancelBtn = modal.querySelector('#lofiMaybeLaterBtn');
        cancelBtn.addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
        });
        
        // Close on overlay click
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                document.body.removeChild(modalOverlay);
            }
        });
    }

    showLoginRequiredModal(technique) {
        // Modal removed - redirect to pricing or show signup
        if (this.isAuthenticated) {
            // Authenticated user - redirect to pricing
            window.location.href = '/pricing';
        } else {
            // Guest user - show signup
            if (this.signupButton) {
                this.signupButton.click();
            }
        }
    }

    showLoadingScreen() {
        if (this.loadingScreen && !this.isLoading) {
            this.loadingScreen.style.display = 'flex';
            this.isLoading = true;
            this.loadingStartTime = Date.now();
        }
    }

    hideLoadingScreen() {
        if (this.loadingScreen && this.isLoading) {
            const elapsed = Date.now() - (this.loadingStartTime || 0);
            
            // Only hide if we've shown it for minimum time or if it's been too long
            if (elapsed >= this.minLoadingTime || elapsed > 5000) {
                this.loadingScreen.style.display = 'none';
                this.isLoading = false;
                // Remove from DOM immediately - no transition
                if (this.loadingScreen && this.loadingScreen.parentNode) {
                    this.loadingScreen.parentNode.removeChild(this.loadingScreen);
                }
            } else {
                // Wait for minimum time
                setTimeout(() => this.hideLoadingScreen(), this.minLoadingTime - elapsed);
            }
        }
    }

    checkConnectionSpeed() {
        // Prefer explicit network information when available
        try {
            if ('connection' in navigator && navigator.connection) {
                const { effectiveType, downlink, rtt } = navigator.connection;
                // Consider slow only on 2G/3G or very poor 4G
                if (effectiveType === 'slow-2g' || effectiveType === '2g' || effectiveType === '3g') {
                    return true;
                }
                if (effectiveType === '4g') {
                    // Treat as slow 4G only if bandwidth is clearly low or RTT very high
                    if ((typeof downlink === 'number' && downlink < 0.8) || (typeof rtt === 'number' && rtt > 400)) {
                        return true;
                    }
                }
                // 5g typically reports as 4g in many browsers; above thresholds avoid false positives
            }
        } catch (_) {}
        
        // Fallback: do NOT infer slowness from generic timers to avoid false positives on fast networks
        return false;
    }

    checkIfStillLoading() {
        // Determine readiness based on essential UI presence only (avoid auth timing noise)
        const essentialElements = [
            document.getElementById('timerDisplay'),
            document.getElementById('startBtn'),
            document.getElementById('techniqueDropdown')
        ];
        if (essentialElements.some(el => !el)) {
            return true;
        }
        return false;
    }

    // hideWelcomeModal() - REMOVED
    // showSignupReminderModal() - REMOVED

    loadCassetteSounds() {
        try {
            this.cassetteSounds = new Audio('audio/ui/cassette-player-button-1.mp3');
            this.cassetteSounds.volume = 0.75; // Set volume to 75%
            this.cassetteSounds.preload = 'auto';
            
            // Create audio context for pitch and speed control
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.audioBuffer = null;
            this.loadAudioBuffer();
        } catch (error) {
            console.log('Could not load cassette sounds:', error);
            this.cassetteSounds = null;
        }
    }
    
    async loadAudioBuffer() {
        try {
            const response = await fetch('audio/ui/cassette-player-button-1.mp3');
            const arrayBuffer = await response.arrayBuffer();
            this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
        } catch (error) {
            console.log('Could not load audio buffer:', error);
        }
    }
    playUiSound(type) {
        // Try to use real cassette sounds with pitch/speed control first
        if (this.audioBuffer && this.audioContext) {
            try {
                this.playProcessedCassetteSound(type);
                return;
            } catch (error) {
                console.log('Processed cassette sound error:', error);
            }
        }
        
        // Fallback to regular audio element
        if (this.cassetteSounds) {
            try {
                this.cassetteSounds.currentTime = 0; // Reset to beginning
                this.cassetteSounds.play().catch(e => {
                    console.log('Cassette sound play failed:', e);
                    this.playSyntheticSound(type); // Fallback to synthetic
                });
                return;
            } catch (error) {
                console.log('Cassette sound error:', error);
            }
        }
        
        // Fallback to synthetic sounds
        this.playSyntheticSound(type);
    }
    
    // Minimal implementation: play decoded buffer with slight rate differences
    playProcessedCassetteSound(type) {
        if (!this.audioContext || !this.audioBuffer) throw new Error('No audio buffer');
        const source = this.audioContext.createBufferSource();
        source.buffer = this.audioBuffer;
        
        // Create gain node for volume control
        const gainNode = this.audioContext.createGain();
        gainNode.gain.value = 0.75; // 75% volume
        
        // Original speed for play, slower for pause
        try {
            source.playbackRate.value = type === 'play' ? 1.0 : 0.75;
        } catch (_) {}
        
        source.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        try { if (this.audioContext.state === 'suspended') this.audioContext.resume(); } catch (_) {}
        source.start(0);
        // Full duration for original sound
        try { source.stop(this.audioContext.currentTime + 0.5); } catch (_) {}
    }
    
    // Synthetic short beep as last-resort feedback
    playSyntheticSound(type) {
        try {
            if (!this.audioContext) {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            const ctx = this.audioContext;
            const oscillator = ctx.createOscillator();
            const gain = ctx.createGain();
            
            // Subtle click sound
            oscillator.type = 'sine';
            oscillator.frequency.value = type === 'play' ? 1200 : 800;
            
            // Very short, quick envelope for a subtle click
            const now = ctx.currentTime;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.05, now + 0.005);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
            
            oscillator.connect(gain);
            gain.connect(ctx.destination);
            if (ctx.state === 'suspended') ctx.resume().catch(() => {});
            oscillator.start(now);
            oscillator.stop(now + 0.1);
        } catch (_) {
            // As a final fallback, do nothing silently
        }
    }
    
    loadAudio() {
        // Simple audio loading - no complex audio options for now
        const savedAudio = localStorage.getItem('selectedAudio') || 'none';
        if (savedAudio !== 'none') {
            this.startAudio(savedAudio);
        }
    }
    
    startAudio(type) {
        if (type === 'none') return;
        
        // Simple audio implementation
        const audioUrls = {
            'rain-light': 'https://www.soundjay.com/misc/sounds/rain-light.mp3',
            'rain-heavy': 'https://www.soundjay.com/misc/sounds/rain-heavy.mp3',
            'forest-birds': 'https://www.soundjay.com/misc/sounds/forest-birds.mp3',
            'cafe-morning': 'https://www.soundjay.com/misc/sounds/cafe-morning.mp3'
        };
        
        if (audioUrls[type]) {
            this.backgroundAudio.src = audioUrls[type];
            this.backgroundAudio.loop = true;
            this.backgroundAudio.volume = 0.3;
            this.backgroundAudio.play().catch(e => console.log('Audio play failed:', e));
            this.currentAudio = this.backgroundAudio;
        }
    }
    
    stopAudio() {
        if (this.currentAudio) {
            if (this.currentAudio.pause) {
                this.currentAudio.pause();
                this.currentAudio.currentTime = 0;
            }
            this.currentAudio = null;
        }
    }
    
    updateDropdownState() {
        const body = document.body;
        
        if (this.isAuthenticated) {
            // Add authenticated class to body to hide all badges
            body.classList.add('authenticated-user');
        } else {
            // Remove authenticated class to show badges
            body.classList.remove('authenticated-user');
        }
    }

    initializeDropdownItemsState() {
        // Initialize dropdown items state immediately to prevent flash of enabled state
        const proTechniques = ['custom'];
        
        this.dropdownItems.forEach(item => {
            const technique = item.getAttribute('data-technique');
            const requiresPro = proTechniques.includes(technique);
            
            if (requiresPro) {
                // Check if user is already authenticated (for immediate login scenarios)
                if (this.isPremiumUser()) {
                    // Enable item for Pro users
                    item.classList.remove('disabled');
                    const loginBtn = item.querySelector('.login-btn');
                    if (loginBtn) {
                        loginBtn.style.display = 'none';
                    }
                } else {
                    // Start with disabled state for non-Pro users (will be updated when auth state is known)
                    item.classList.add('disabled');
                    const loginBtn = item.querySelector('.login-btn');
                    if (loginBtn) {
                        loginBtn.style.display = 'block';
                    }
                }
            }
        });
    }

    // Update technique presets visibility based on user type
    // Disable presets that require signup/subscribe and show appropriate text
    updateTechniquePresetsVisibility() {
        const techniquePresets = document.querySelectorAll('.technique-preset');
        const proTechniques = ['flow', 'marathon', 'deepwork'];
        const freeTechniques = ['sprint', 'focus'];
        
        techniquePresets.forEach(preset => {
            const technique = preset.dataset.technique;
            if (!technique) return;
            
            const signupText = preset.querySelector('.signup-required-text');
            const subscribeText = preset.querySelector('.subscribe-required-text');
            
            // Hide both texts initially
            if (signupText) signupText.classList.add('hidden');
            if (subscribeText) subscribeText.classList.remove('hidden');
            
            // Reset preset state
            preset.style.opacity = '1';
            preset.style.pointerEvents = 'auto';
            preset.style.cursor = 'pointer';
            
            // Guest users: disable all except Pomodoro
            if (!this.isAuthenticated) {
                if (technique !== 'pomodoro') {
                    preset.style.opacity = '0.5';
                    preset.style.pointerEvents = 'none';
                    preset.style.cursor = 'not-allowed';
                    if (signupText) signupText.classList.remove('hidden');
                    if (subscribeText) subscribeText.classList.add('hidden');
                }
            }
            // Free users: can use Flow, Marathon, Deep Work (no Premium required)
            else if (this.isAuthenticated && !this.isPremiumUser()) {
                // Flow, Marathon, Deep Work are now available for free users
                if (proTechniques.includes(technique)) {
                    // Enable preset for free users
                    preset.style.opacity = '1';
                    preset.style.pointerEvents = 'auto';
                    preset.style.cursor = 'pointer';
                    if (subscribeText) subscribeText.classList.add('hidden');
                } else {
                    if (subscribeText) subscribeText.classList.add('hidden');
                }
            } else if (this.isPremiumUser()) {
                // Premium users: hide all requirement texts
                if (signupText) signupText.classList.add('hidden');
                if (subscribeText) subscribeText.classList.add('hidden');
            }
        });
    }

    updateDropdownItemsState() {
        const proTechniques = ['custom'];
        
        this.dropdownItems.forEach(item => {
            const technique = item.getAttribute('data-technique');
            const requiresPro = proTechniques.includes(technique);
            
            if (requiresPro) {
                // If auth readiness isn't known yet, keep items disabled to avoid flicker
                if (!this.authReady) {
                    item.classList.add('disabled');
                    const loginBtn = item.querySelector('.login-btn');
                    if (loginBtn) loginBtn.style.display = 'block';
                    return;
                }
                if (this.isPremiumUser()) {
                    // Enable item for Pro users
                    item.classList.remove('disabled');
                    const loginBtn = item.querySelector('.login-btn');
                    if (loginBtn) {
                        loginBtn.style.display = 'none';
                    }
                } else {
                    // Disable item for non-Pro users
                    item.classList.add('disabled');
                    const loginBtn = item.querySelector('.login-btn');
                    if (loginBtn) {
                        loginBtn.style.display = 'block';
                    }
                }
            }
        });
    }

    setupLoginButtons() {
        // Setup login buttons for advanced techniques
        const loginButtons = [
            { id: 'loginCustomBtn', technique: 'custom' }
        ];
        
        loginButtons.forEach(({ id, technique }) => {
            const button = document.getElementById(id);
            if (button) {
                button.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.showLoginRequiredModal(technique);
                });
            }
        });
    }

    showCycleCompletedCelebration(wasLegitimate) {}

    // =========================
    // Todoist Integration (Free Beta)
    // =========================
    showTodoistModal() {
        // Build modal
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';

        const tokenValue = this.todoistToken || '';

        const modal = document.createElement('div');
        modal.className = 'focus-stats-modal';
        modal.innerHTML = `
            <button class="close-focus-stats-x">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <h3>Integrations</h3>
            <p>Connect your productivity tools to enhance your focus sessions.</p>
            
            <!-- Todoist Integration -->
            <div class="integration-section">
                <div class="integration-header">
                    <div class="integration-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M9 12l2 2 4-4"/>
                            <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/>
                        </svg>
                    </div>
                    <div class="integration-title">
                        <h4>Todoist</h4>
                        <p>Connect your Todoist account to sync tasks</p>
                    </div>
                </div>
                
                <div class="integration-content">
                    <div class="connection-section">
                        <div class="integration-status">
                            <span id="todoistStatusText" class="status-text">Disconnected</span>
                        </div>
                        <div class="integration-actions">
                            <button id="connectTodoistBtn" class="btn-primary">Connect to Todoist</button>
                            <button id="disconnectTodoistBtn" class="btn-secondary" style="display:none;">Disconnect</button>
                        </div>
                    </div>
                    
                    <div class="tasks-section">
                        <div class="tasks-header">
                            <h5>Your Tasks</h5>
                            <span class="tasks-subtitle">Select a task to focus on</span>
                        </div>
                        <div id="todoistTasksList" class="tasks-list"></div>
                    </div>
                </div>
            </div>
        `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        const close = () => {
            try { document.body.removeChild(overlay); } catch (_) {}
        };

        modal.querySelector('.close-focus-stats-x').addEventListener('click', close);
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) close();
        });

        const connectBtn = modal.querySelector('#connectTodoistBtn');
        const disconnectBtn = modal.querySelector('#disconnectTodoistBtn');
        const fetchBtn = modal.querySelector('#fetchTodoistTasksBtn');
        const listEl = modal.querySelector('#todoistTasksList');
        const statusText = modal.querySelector('#todoistStatusText');

        const renderTasks = () => {
            listEl.innerHTML = '';
            if (!this.todoistTasks || this.todoistTasks.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'empty-state';
                empty.innerHTML = `
                    <div class="empty-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                            <polyline points="14,2 14,8 20,8"/>
                            <line x1="16" y1="13" x2="8" y2="13"/>
                            <line x1="16" y1="17" x2="8" y2="17"/>
                            <polyline points="10,9 9,9 8,9"/>
                        </svg>
                    </div>
                    <div class="empty-text">No tasks loaded yet</div>
                    <div class="empty-subtext">Click "Fetch Tasks" to load your Todoist tasks</div>
                `;
                listEl.appendChild(empty);
                return;
            }
            
            this.todoistTasks.forEach(task => {
                const item = document.createElement('div');
                item.className = 'task-item';
                
                const taskContent = document.createElement('div');
                taskContent.className = 'task-content';
                
                const taskTitle = document.createElement('div');
                taskTitle.className = 'task-title';
                taskTitle.textContent = task.content || '(untitled)';
                
                const taskProject = document.createElement('div');
                taskProject.className = 'task-project';
                const pj = this.todoistProjectsById[task.project_id];
                taskProject.textContent = pj ? pj.name : 'Inbox';
                
                taskContent.appendChild(taskTitle);
                taskContent.appendChild(taskProject);
                
                const taskActions = document.createElement('div');
                taskActions.className = 'task-actions';
                
                const focusBtn = document.createElement('button');
                focusBtn.className = 'btn-focus';
                focusBtn.textContent = 'Focus This';
                focusBtn.addEventListener('click', () => {
                    this.currentTask = { id: task.id, content: task.content, project_id: task.project_id };
                    this.updateCurrentTaskBanner();
                    close();
                });
                
                const completeBtn = document.createElement('button');
                completeBtn.className = 'btn-secondary';
                completeBtn.textContent = '‚úì';
                completeBtn.title = 'Mark as completed';
                completeBtn.addEventListener('click', async () => {
                    try {
                        // Check if Developer Mode is active
                        const viewMode = localStorage.getItem('viewMode');
                        const devModeParam = viewMode === 'pro' ? '&devMode=pro' : '';
                        
                        await fetch(`/api/todoist-complete?id=${encodeURIComponent(task.id)}${devModeParam}`, { method: 'POST' });
                    } catch (_) {}
                    await this.fetchTodoistData();
                    renderTasks();
                });

                taskActions.appendChild(completeBtn);
                taskActions.appendChild(focusBtn);
                
                item.appendChild(taskContent);
                item.appendChild(taskActions);
                listEl.appendChild(item);
            });
        };

        connectBtn.addEventListener('click', () => {
            this.trackEvent('Todoist Connect Clicked', {
                button_type: 'todoist_connect',
                source: 'tasks_modal',
                user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                conversion_funnel: 'integration_interest'
            });
            window.location.href = '/api/todoist-auth-start';
        });

        disconnectBtn.addEventListener('click', async () => {
            try {
                await fetch('/api/todoist-disconnect', { method: 'POST' });
            } catch (_) {}
            statusText.textContent = 'Disconnected';
            fetchBtn.style.display = 'none';
            disconnectBtn.style.display = 'none';
            connectBtn.style.display = '';
            this.todoistTasks = [];
            this.todoistProjectsById = {};
            renderTasks();
        });

        fetchBtn.addEventListener('click', async () => {
            await this.fetchTodoistData();
            renderTasks();
        });

        // Check connection status and update UI
        (async () => {
            try {
                const resp = await fetch('/api/todoist-status');
                const json = await resp.json();
                const connected = !!json.connected;
                if (connected) {
                    statusText.textContent = 'Connected to Todoist';
                    connectBtn.style.display = 'none';
                    disconnectBtn.style.display = '';
                    fetchBtn.style.display = '';
                    this.fetchTodoistData().then(renderTasks).catch(() => renderTasks());
                } else {
                    statusText.textContent = 'Not connected';
                    connectBtn.style.display = '';
                    disconnectBtn.style.display = 'none';
                    fetchBtn.style.display = 'none';
                    renderTasks();
                }
            } catch (_) {
                statusText.textContent = 'Not connected';
                connectBtn.style.display = '';
                disconnectBtn.style.display = 'none';
                fetchBtn.style.display = 'none';
                renderTasks();
            }
        })();
    }
    showTaskListModal() {
        // Build modal for task list only (no integration controls)
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';

        // Check if user is authenticated and not Pro
        const isFreeUser = this.isAuthenticated && this.user && !this.isPremiumUser();
        const isGuest = !this.isAuthenticated || !this.user;

        const modal = document.createElement('div');
        modal.className = 'focus-stats-modal';
        modal.innerHTML = `
            <button class="close-focus-stats-x">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <div class="tasks-header">
                <h3>Tasks</h3>
                <p class="tasks-subtitle">Manage your focus tasks</p>
            </div>
            ${this.isAuthenticated && this.user && this.isPremiumUser() ? `
            <div class="add-task-section" style="margin-bottom: 12px;">
                <button class="import-task-btn" id="importTodoistMainBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/>
                        <polyline points="3.27 6.96 12 12.01 20.73 6.96"/>
                        <line x1="12" y1="22.08" x2="12" y2="12"/>
                    </svg>
                    Import from Todoist
                </button>
            </div>
            ` : ''}
            
            <!-- Task Tabs -->
            <div class="task-tabs">
                <div class="task-tabs-left">
                    <button class="task-tab active" data-tab="todo">To-do</button>
                    <button class="task-tab" data-tab="done">Done</button>
                </div>
                <div class="task-tabs-right">
                    <button class="task-options-btn" id="taskOptionsBtn" title="Task options">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="1"/>
                            <circle cx="19" cy="12" r="1"/>
                            <circle cx="5" cy="12" r="1"/>
                        </svg>
                    </button>
                    
                    <!-- Task Options Dropdown -->
                    <div class="task-options-dropdown" id="taskOptionsDropdown" style="display: none;">
                        <div class="task-options-menu">
                            <button class="task-option-item" id="clearAllTasksBtn">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"/>
                                    <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
                                    <line x1="10" y1="11" x2="10" y2="17"/>
                                    <line x1="14" y1="11" x2="14" y2="17"/>
                                </svg>
                                Clear All Tasks
                            </button>
                            <button class="task-option-item" id="clearDoneTasksBtn">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="9 11 12 14 22 4"/>
                                    <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
                                </svg>
                                Clear Done Tasks
                            </button>
                            
                        </div>
                    </div>
                </div>
            </div>
            
            ${isGuest ? `
                <div style="background: var(--onyx-dark, #064e3b); border-radius: 12px; padding: 16px; margin-bottom: 16px; display: flex; align-items: center; gap: 12px;">
                    <div style="flex-shrink: 0;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 8h1a4 4 0 1 1 0 8h-1"/>
                            <path d="M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4Z"/>
                            <line x1="6" x2="6" y1="2" y2="4"/>
                            <line x1="10" x2="10" y1="2" y2="4"/>
                            <line x1="14" x2="14" y1="2" y2="4"/>
                        </svg>
                    </div>
                    <div style="flex: 1;">
                        <div style="color: white; font-weight: 600; font-size: 14px; margin-bottom: 4px;">Save your progress</div>
                        <div style="color: white; font-size: 13px; opacity: 0.95;">Sync your tasks and stats across all your devices</div>
                    </div>
                    <button id="guestTaskSignupBtn" style="background: white; color: var(--onyx-dark, #064e3b); border: none; padding: 8px 16px; border-radius: 6px; font-weight: 600; cursor: pointer; white-space: nowrap; font-size: 13px;">Sign up</button>
                </div>
            ` : ''}
            <div id="todoistTasksList" class="tasks-list"></div>
            
            <!-- Add Task Form (initially hidden) -->
            <div id="addTaskForm" class="add-task-form" style="display: none;">
                <div class="form-group">
                    <label>What are you working on?</label>
                    <input type="text" id="taskDescription" placeholder="Enter task description" maxlength="100">
                </div>
                <div class="form-group">
                    <label>Sessions</label>
                    <div class="pomodoros-control">
                        <button class="pomodoros-btn" id="decreasePomodoros">-</button>
                        <input type="number" id="pomodorosCount" value="1" min="1" max="10">
                        <button class="pomodoros-btn" id="increasePomodoros">+</button>
                    </div>
                </div>
                <div class="form-actions">
                    <button id="deleteTask" title="Delete task" style="display:none; margin-right: auto; background: none; border: none; padding: 8px; color: rgba(255,255,255,0.6);">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="3 6 5 6 21 6"/>
                            <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
                            <path d="M10 11v6"/>
                            <path d="M14 11v6"/>
                            <path d="M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2"/>
                        </svg>
                    </button>
                    <button class="btn-secondary" id="cancelAddTask">Cancel</button>
                    <button class="btn-primary" id="saveTask">Save</button>
                </div>
            </div>
            
            <div class="add-task-section">
                <button class="add-task-btn" id="showAddTaskForm">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 5v14"/>
                        <path d="M5 12h14"/>
                    </svg>
                    Add Task
                </button>
            </div>
        `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        const close = () => {
            try { document.body.removeChild(overlay); } catch (_) {}
            // Update task distribution when modal is closed
            this.rebuildTaskQueue();
            this.updateCurrentTaskBanner();
            this.updateTaskButtonState();
            // Update current task display in timer
            this.updateCurrentTaskFromQueue();
        };

        modal.querySelector('.close-focus-stats-x').addEventListener('click', close);
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) close();
        });

        // Guest signup button from Todoist banner
        if (isGuest) {
            const guestTaskSignupBtn = modal.querySelector('#guestTaskSignupBtn');
            if (guestTaskSignupBtn) {
                guestTaskSignupBtn.addEventListener('click', () => {
                    close();
                    window.location.href = '/pricing';
                });
            }
        }

        const listEl = modal.querySelector('#todoistTasksList');
        let currentTab = 'todo'; // Default to todo tab

        const renderTasks = () => {
            listEl.innerHTML = '';
            const allTasks = this.getAllTasks();
            
            // Filter tasks based on current tab
            let filteredTasks = allTasks;
            if (currentTab === 'todo') {
                filteredTasks = allTasks.filter(task => !task.completed);
            } else if (currentTab === 'done') {
                filteredTasks = allTasks.filter(task => task.completed);
            }
            
            if (filteredTasks.length === 0) {
                // Show appropriate message based on current tab
                if (currentTab === 'done') {
                    listEl.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M9 12l2 2 4-4"/>
                                    <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/>
                                </svg>
                            </div>
                            <div class="empty-text">No completed tasks yet</div>
                            <div class="empty-subtext">Complete some tasks to see them here</div>
                        </div>
                    `;
                } else {
                    // For todo tab, show empty list without message
                    listEl.innerHTML = '';
                }
                return;
            }
            
            // Apply saved task order
            const savedOrder = this.getTaskOrder();
            let orderedTasks = filteredTasks;
            
            if (savedOrder.length > 0) {
                // Create a map for quick lookup
                const taskMap = new Map(filteredTasks.map(task => [task.id, task]));
                
                // Sort by saved order
                orderedTasks = [];
                savedOrder.forEach(orderItem => {
                    if (taskMap.has(orderItem.id)) {
                        orderedTasks.push(taskMap.get(orderItem.id));
                        taskMap.delete(orderItem.id);
                    }
                });
                
                // Add any remaining tasks that weren't in the saved order
                taskMap.forEach(task => orderedTasks.push(task));
            }
            
            orderedTasks.forEach((task, index) => {
                const item = document.createElement('div');
                item.className = 'task-item';
                item.draggable = true;
                item.dataset.taskId = task.id;
                item.dataset.index = index;
                
                // Get task session config from localStorage
                const taskConfig = this.getTaskConfig(task.id);
                const sessions = taskConfig.sessions || 1;
                
                const completedSessions = taskConfig.completedSessions || 0;
                const totalSessions = taskConfig.sessions || 1;
                const isCompleted = task.completed || (completedSessions >= totalSessions);
                
                // Check if task should be disabled for Guest users
                const isGuest = !this.isAuthenticated || !this.user;
                const shouldDisableForGuest = isGuest && index >= 1; // Disable tasks 2+ for guests
                
                const itemContent = `
                    <div class="task-checkbox">
                        <input type="checkbox" id="task-${task.id}" ${isCompleted ? 'checked' : ''} ${shouldDisableForGuest ? 'disabled' : ''}>
                        <label for="task-${task.id}"></label>
                    </div>
                    <div class="task-content">
                        <div class="task-title" style="${shouldDisableForGuest ? 'opacity: 0.5;' : ''}">
                            ${task.content || '(untitled)'}
                            ${shouldDisableForGuest ? '<span style="font-size: 12px; margin-left: 8px;">(Sign up required)</span>' : ''}
                        </div>
                    </div>
                    <div class="task-progress">
                        <span class="progress-text" style="${shouldDisableForGuest ? 'opacity: 0.5;' : ''}">${completedSessions}/${totalSessions}</span>
                    </div>
                    ${!shouldDisableForGuest ? `
                    <div class="task-menu" data-task-id="${task.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="1"/>
                            <circle cx="19" cy="12" r="1"/>
                            <circle cx="5" cy="12" r="1"/>
                        </svg>
                    </div>
                    ` : ''}
                `;
                
                item.innerHTML = itemContent;
                
                // Add disabled class for guest users
                if (shouldDisableForGuest) {
                    item.classList.add('disabled-for-guest');
                }
                
                // Set initial selected state
                if (taskConfig.selected) {
                    item.classList.add('selected');
                }
                
                listEl.appendChild(item);
            });
            
            // Add event listeners for checkboxes and session controls
            this.setupTaskEventListeners(modal);
            
            // Add drag and drop functionality
            this.setupDragAndDrop(modal);
        };

        // Setup menu event listener
        const menuBtn = modal.querySelector('.tasks-menu');
        if (menuBtn) {
            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.showTaskMenu(modal);
            });
        }

        // Setup add task button
        const addTaskBtn = modal.querySelector('#showAddTaskForm');
        const addTaskForm = modal.querySelector('#addTaskForm');
        if (addTaskBtn && addTaskForm) {
            addTaskBtn.addEventListener('click', () => {
                this.trackEvent('Add Task Button Clicked', {
                    button_type: 'add_task',
                    source: 'tasks_modal',
                    user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                    task_count: this.getLocalTasks().length
                });
                // Check task limit BEFORE showing the form
                // Guest users cannot create tasks at all - must sign up
                if (!this.isAuthenticated) {
                    this.showTaskLimitModal();
                    return;
                }
                
                // Refresh tasks from storage to ensure we have latest data
                const allLocalTasks = this.getLocalTasks();
                
                // Only count tasks in To-do (not completed), not tasks in Done
                const currentTasks = allLocalTasks.filter(task => !task.completed);
                
                // Define limits based on user type
                let taskLimit;
                if (!this.isAuthenticated) {
                    // Guest users: 1 task
                    taskLimit = 1;
                } else if (this.isAuthenticated && !this.isPro) {
                    // Free users: 2 tasks
                    taskLimit = 2;
                } else {
                    // Pro users: unlimited
                    taskLimit = Infinity;
                }
                
                if (currentTasks.length >= taskLimit) {
                    this.showTaskLimitModal();
                    return;
                }
                
                // Enter add mode
                this.editingTaskId = null;
                addTaskForm.style.display = 'block';
                addTaskBtn.disabled = true;
                // Reset fields for add mode
                const taskInput = addTaskForm.querySelector('#taskDescription');
                const pomodorosInput = addTaskForm.querySelector('#pomodorosCount');
                const deleteBtn = addTaskForm.querySelector('#deleteTask');
                const cancelBtn = addTaskForm.querySelector('#cancelAddTask');
                const saveBtn = addTaskForm.querySelector('#saveTask');
                if (taskInput) taskInput.value = '';
                if (pomodorosInput) pomodorosInput.value = '1';
                if (deleteBtn) deleteBtn.style.display = 'none';
                // First task UX: hide cancel if no tasks exist; also disable save until text
                try {
                    const count = (this.getAllTasks() || []).length;
                    if (cancelBtn) cancelBtn.style.display = count === 0 ? 'none' : '';
                    if (saveBtn) saveBtn.disabled = !taskInput || !taskInput.value.trim();
                } catch (_) {}
                if (taskInput) taskInput.focus();
            });
        }

        // Initial UI state: if no tasks, show form and disable button
        if (addTaskBtn && addTaskForm) {
            try {
                const initialTasks = this.getAllTasks();
                if (Array.isArray(initialTasks) && initialTasks.length === 0) {
                    addTaskForm.style.display = 'block';
                    addTaskBtn.disabled = true;
                    // First task: hide cancel, disable save until input
                    const cancelBtn0 = addTaskForm.querySelector('#cancelAddTask');
                    const saveBtn0 = addTaskForm.querySelector('#saveTask');
                    const taskInput0 = addTaskForm.querySelector('#taskDescription');
                    if (cancelBtn0) cancelBtn0.style.display = 'none';
                    if (saveBtn0) saveBtn0.disabled = true;
                    if (taskInput0) taskInput0.focus();
                } else {
                    addTaskForm.style.display = 'none';
                    addTaskBtn.disabled = false;
                    const cancelBtn0 = addTaskForm.querySelector('#cancelAddTask');
                    if (cancelBtn0) cancelBtn0.style.display = '';
                }
            } catch (_) {}
        }

        // Setup form controls
        this.setupAddTaskFormControls(modal, renderTasks);

        // Tab switching logic
        const setupTabs = () => {
            const tabs = modal.querySelectorAll('.task-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    this.trackEvent('Task Tab Clicked', {
                        button_type: 'task_tab',
                        tab_name: tab.dataset.tab,
                        source: 'tasks_modal'
                    });
                    // Remove active class from all tabs
                    tabs.forEach(t => t.classList.remove('active'));
                    // Add active class to clicked tab
                    tab.classList.add('active');
                    // Update current tab
                    currentTab = tab.dataset.tab;
                    
                    // Show/hide add task elements based on current tab
                    const addTaskForm = modal.querySelector('#addTaskForm');
                    const addTaskBtn = modal.querySelector('#showAddTaskForm');
                    const addTaskSection = modal.querySelector('.add-task-section');
                    
                    if (currentTab === 'done') {
                        // Hide add task elements in Done tab
                        if (addTaskForm) addTaskForm.style.display = 'none';
                        if (addTaskSection) addTaskSection.style.display = 'none';
                    } else {
                        // Show add task elements in To-do tab
                        if (addTaskSection) addTaskSection.style.display = 'block';
                        
                        // Restore addTaskForm to its proper state based on whether there are tasks
                        if (addTaskForm && addTaskBtn) {
                            const tasks = this.getAllTasks();
                            if (Array.isArray(tasks) && tasks.length === 0) {
                                // No tasks: show form and disable button
                                addTaskForm.style.display = 'block';
                                addTaskBtn.disabled = true;
                            } else {
                                // Has tasks: hide form and enable button
                                addTaskForm.style.display = 'none';
                                addTaskBtn.disabled = false;
                            }
                        }
                    }
                    
                    // Re-render tasks
                    renderTasks();
                });
            });
        };

        // Load tasks (local + Todoist if authenticated)
        this.loadAllTasks();
        renderTasks();
        setupTabs();
        
        // Setup task options dropdown
        this.setupTaskOptions(modal, renderTasks);
        
        // Setup Import button (main button above tabs)
        const mainImportBtn = modal.querySelector('#importTodoistMainBtn');
        if (mainImportBtn) {
            mainImportBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Track Todoist import button click
                this.trackEvent('Todoist Import Clicked', {
                    button_type: 'todoist_import',
                    source: 'tasks_panel',
                    user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                    conversion_funnel: 'integration_interest'
                });
                
                try {
                    // Check if Todoist is connected first
                    const isConnected = await this.checkTodoistConnection();
                    if (!isConnected) {
                        // Show connection prompt and redirect to auth
                        this.showTodoistConnectionPrompt();
                        return;
                    }
                    // Show Todoist projects selection modal
                    await this.showTodoistProjectsModal();
                } catch (error) {
                    console.error('Error opening Todoist projects modal:', error);
                    alert('Error loading Todoist projects. Please try again.');
                }
            });
        }
    }

    setupAddTaskFormControls(modal, renderTasks) {
        const addTaskForm = modal.querySelector('#addTaskForm');
        const addTaskBtn = modal.querySelector('#showAddTaskForm');
        const cancelBtn = modal.querySelector('#cancelAddTask');
        const saveBtn = modal.querySelector('#saveTask');
        const deleteBtn = modal.querySelector('#deleteTask');
        const taskInput = modal.querySelector('#taskDescription');
        const pomodorosInput = modal.querySelector('#pomodorosCount');
        const decreaseBtn = modal.querySelector('#decreasePomodoros');
        const increaseBtn = modal.querySelector('#increasePomodoros');

        // Cancel button - hide form and show add button; exit edit mode if any
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                // If there are no tasks, keep the form open and button disabled
                const tasks = this.getAllTasks();
                if (!tasks || tasks.length === 0) {
                    addTaskForm.style.display = 'block';
                    addTaskBtn.disabled = true;
                } else {
                    addTaskForm.style.display = 'none';
                    addTaskBtn.disabled = false;
                }
                // Clear form
                if (taskInput) taskInput.value = '';
                if (pomodorosInput) pomodorosInput.value = '1';
                // Exit edit mode
                this.editingTaskId = null;
                // Restore list and add-section
                const listEl = modal.querySelector('#todoistTasksList');
                const addSection = modal.querySelector('.add-task-section');
                if (listEl) listEl.style.display = '';
                if (addSection) addSection.style.display = '';
            });
        }

        // Delete button - only in edit mode
        if (deleteBtn) {
            deleteBtn.addEventListener('click', () => {
                if (!this.editingTaskId) return;
                // Remove from local tasks
                const tasks = this.getLocalTasks().filter(t => t.id !== this.editingTaskId);
                this.setLocalTasks(tasks);
                // Remove any config for the task
                const configs = JSON.parse(localStorage.getItem('taskConfigs') || '{}');
                delete configs[this.editingTaskId];
                localStorage.setItem('taskConfigs', JSON.stringify(configs));
                // Reset state and UI
                this.editingTaskId = null;
                taskInput.value = '';
                pomodorosInput.value = '1';
                addTaskForm.style.display = 'none';
                addTaskBtn.disabled = false;
                // Restore list and add-section
                const listEl = modal.querySelector('#todoistTasksList');
                const addSection = modal.querySelector('.add-task-section');
                if (listEl) listEl.style.display = '';
                if (addSection) addSection.style.display = '';
                // Refresh list/banner/queue
                this.loadAllTasks();
                if (typeof renderTasks === 'function') renderTasks();
                this.updateCurrentTaskBanner();
                this.rebuildTaskQueue();
                this.updateCurrentTaskFromQueue();
                this.updateDisplay();
                
                // After deletion, check if user has 0 tasks and is below limit
                const allLocalTasks = this.getLocalTasks();
                const currentTasks = allLocalTasks.filter(task => !task.completed);
                
                // Only show form if there are NO tasks remaining and user can add tasks
                if (currentTasks.length === 0) {
                    let taskLimit;
                    if (!this.isAuthenticated) {
                        taskLimit = 1;
                    } else if (this.isAuthenticated && !this.isPro) {
                        taskLimit = 2;
                    } else {
                        taskLimit = Infinity;
                    }
                    
                    // If we can add tasks, show form
                    if (taskLimit > 0) {
                        // Reset to "add" mode (not edit mode)
                        this.editingTaskId = null;
                        
                        // Hide delete button (only for edit mode)
                        const deleteButton = modal.querySelector('#deleteTask');
                        if (deleteButton) deleteButton.style.display = 'none';
                        
                        // Clear input fields - get fresh references
                        const freshTaskInput = modal.querySelector('#taskDescription');
                        const freshPomodorosInput = modal.querySelector('#pomodorosCount');
                        if (freshTaskInput) {
                            freshTaskInput.value = '';
                            freshTaskInput.setAttribute('value', '');
                        }
                        if (freshPomodorosInput) {
                            freshPomodorosInput.value = '1';
                        }
                        
                        // Show form and disable add button
                        addTaskForm.style.display = 'block';
                        addTaskBtn.disabled = true;
                        
                        // Focus on input after a brief delay to ensure it's cleared
                        setTimeout(() => {
                            if (freshTaskInput) {
                                freshTaskInput.value = '';
                                freshTaskInput.focus();
                            }
                        }, 50);
                    }
                }
            });
        }

        // Save button - add or update task and hide form
        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                const description = taskInput ? taskInput.value.trim() : '';
                const pomodoros = pomodorosInput ? parseInt(pomodorosInput.value) : 1;
                
                if (description) {
                    if (this.editingTaskId) {
                        // Update existing task
                        const tasks = this.getLocalTasks();
                        const idx = tasks.findIndex(t => t.id === this.editingTaskId);
                        if (idx !== -1) {
                            tasks[idx].content = description;
                            this.setLocalTasks(tasks);
                            this.setTaskConfig(this.editingTaskId, { sessions: pomodoros });
                        }
                        this.editingTaskId = null;
                        // Restore list and add-section
                        const listEl = modal.querySelector('#todoistTasksList');
                        const addSection = modal.querySelector('.add-task-section');
                        if (listEl) listEl.style.display = '';
                        if (addSection) addSection.style.display = '';
                    } else {
                        // Create new task
                        this.addLocalTask(description, pomodoros);
                    }
                    // Clear form
                    taskInput.value = '';
                    pomodorosInput.value = '1';
                    // Refresh task list
                    this.loadAllTasks();
                    if (typeof renderTasks === 'function') renderTasks();
                    // Update header to reflect changes immediately
                    this.updateCurrentTaskFromQueue();
                    this.updateSessionInfo();
                    // Enable button now that there is at least one task, and hide form
                    addTaskForm.style.display = 'none';
                    addTaskBtn.disabled = false;
                }
            });
        }

        // Pomodoros controls
        if (decreaseBtn && pomodorosInput) {
            decreaseBtn.addEventListener('click', () => {
                const current = parseInt(pomodorosInput.value);
                if (current > 1) {
                    pomodorosInput.value = current - 1;
                }
            });
        }

        if (increaseBtn && pomodorosInput) {
            increaseBtn.addEventListener('click', () => {
                const current = parseInt(pomodorosInput.value);
                if (current < 10) {
                    pomodorosInput.value = current + 1;
                }
            });
        }

        // Enter key to save
        if (taskInput) {
            taskInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && saveBtn) {
                    saveBtn.click();
                }
            });
            // Enable/disable save based on input text
            taskInput.addEventListener('input', () => {
                if (saveBtn) {
                    saveBtn.disabled = !taskInput.value.trim();
                }
            });
        }
    }

    setupAddTaskFormControlsForPanel(panel, renderTasks) {
        const addTaskForm = panel.querySelector('#addTaskForm');
        const addTaskBtn = panel.querySelector('#showAddTaskForm');
        const cancelBtn = panel.querySelector('#cancelAddTask');
        const saveBtn = panel.querySelector('#saveTask');
        const deleteBtn = panel.querySelector('#deleteTask');
        const taskInput = panel.querySelector('#taskDescription');
        const pomodorosInput = panel.querySelector('#pomodorosCount');
        const decreaseBtn = panel.querySelector('#decreasePomodoros');
        const increaseBtn = panel.querySelector('#increasePomodoros');

        // Remove old event listeners by cloning
        if (cancelBtn) {
            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.replaceWith(newCancelBtn);
            newCancelBtn.addEventListener('click', () => {
                // Show back the hidden task item if we were editing
                if (this.editingTaskId) {
                    const hiddenTaskItem = panel.querySelector(`[data-task-id="${this.editingTaskId}"]`);
                    if (hiddenTaskItem) {
                        hiddenTaskItem.style.display = '';
                    }
                }
                
                const tasks = this.getAllTasks();
                if (!tasks || tasks.length === 0) {
                    addTaskForm.style.display = 'block';
                    addTaskBtn.disabled = true;
                } else {
                    addTaskForm.style.display = 'none';
                    addTaskBtn.disabled = false;
                }
                if (taskInput) taskInput.value = '';
                if (pomodorosInput) pomodorosInput.value = '1';
                this.editingTaskId = null;
                const listEl = panel.querySelector('#todoistTasksList');
                const addSection = panel.querySelector('.add-task-section');
                if (listEl) listEl.style.display = '';
                if (addSection) addSection.style.display = '';
            });
        }

        if (deleteBtn) {
            const newDeleteBtn = deleteBtn.cloneNode(true);
            deleteBtn.replaceWith(newDeleteBtn);
            newDeleteBtn.addEventListener('click', () => {
                if (!this.editingTaskId) return;
                const tasks = this.getLocalTasks().filter(t => t.id !== this.editingTaskId);
                this.setLocalTasks(tasks);
                const configs = JSON.parse(localStorage.getItem('taskConfigs') || '{}');
                delete configs[this.editingTaskId];
                localStorage.setItem('taskConfigs', JSON.stringify(configs));
                this.editingTaskId = null;
                if (taskInput) taskInput.value = '';
                if (pomodorosInput) pomodorosInput.value = '1';
                addTaskForm.style.display = 'none';
                addTaskBtn.disabled = false;
                const listEl = panel.querySelector('#todoistTasksList');
                const addSection = panel.querySelector('.add-task-section');
                if (listEl) listEl.style.display = '';
                if (addSection) addSection.style.display = '';
                this.loadAllTasks();
                if (typeof renderTasks === 'function') renderTasks();
                this.updateCurrentTaskBanner();
                this.rebuildTaskQueue();
                this.updateCurrentTaskFromQueue();
                this.updateDisplay();
                
                // After deletion, check if user has 0 tasks and is below limit
                const allLocalTasks = this.getLocalTasks();
                const currentTasks = allLocalTasks.filter(task => !task.completed);
                
                // Only show form if there are NO tasks remaining and user can add tasks
                if (currentTasks.length === 0) {
                    let taskLimit;
                    if (!this.isAuthenticated) {
                        taskLimit = 1;
                    } else if (this.isAuthenticated && !this.isPro) {
                        taskLimit = 2;
                    } else {
                        taskLimit = Infinity;
                    }
                    
                    // If we can add tasks, show form
                    if (taskLimit > 0) {
                        // Reset to "add" mode (not edit mode)
                        this.editingTaskId = null;
                        
                        // Hide delete button (only for edit mode)
                        const deleteButton = panel.querySelector('#deleteTask');
                        if (deleteButton) deleteButton.style.display = 'none';
                        
                        // Clear input fields - get fresh references
                        const freshTaskInput = panel.querySelector('#taskDescription');
                        const freshPomodorosInput = panel.querySelector('#pomodorosCount');
                        if (freshTaskInput) {
                            freshTaskInput.value = '';
                            freshTaskInput.setAttribute('value', '');
                        }
                        if (freshPomodorosInput) {
                            freshPomodorosInput.value = '1';
                        }
                        
                        // Show form and disable add button
                        addTaskForm.style.display = 'block';
                        addTaskBtn.disabled = true;
                        
                        // Focus on input after a brief delay to ensure it's cleared
                        setTimeout(() => {
                            if (freshTaskInput) {
                                freshTaskInput.value = '';
                                freshTaskInput.focus();
                            }
                        }, 50);
                    }
                }
            });
        }

        if (saveBtn) {
            const newSaveBtn = saveBtn.cloneNode(true);
            saveBtn.replaceWith(newSaveBtn);
            newSaveBtn.addEventListener('click', () => {
                console.log('üíæ Save button clicked');
                const finalTaskInput = panel.querySelector('#taskDescription');
                const finalPomodorosInput = panel.querySelector('#pomodorosCount');
                const description = finalTaskInput ? finalTaskInput.value.trim() : '';
                const pomodoros = finalPomodorosInput ? parseInt(finalPomodorosInput.value) : 1;
                
                console.log('üíæ Task description:', description, 'Pomodoros:', pomodoros);
                
                if (description) {
                    if (this.editingTaskId) {
                        console.log('üíæ Editing task:', this.editingTaskId);
                        const tasks = this.getLocalTasks();
                        const idx = tasks.findIndex(t => t.id === this.editingTaskId);
                        if (idx !== -1) {
                            tasks[idx].content = description;
                            this.setLocalTasks(tasks);
                            this.setTaskConfig(this.editingTaskId, { sessions: pomodoros });
                        }
                        this.editingTaskId = null;
                    } else {
                        console.log('üíæ Adding new task');
                        // Create new task
                        this.addLocalTask(description, pomodoros);
                    }
                    if (finalTaskInput) finalTaskInput.value = '';
                    if (finalPomodorosInput) finalPomodorosInput.value = '1';
                    this.loadAllTasks();
                    if (typeof renderTasks === 'function') {
                        console.log('üíæ Calling renderTasks');
                        renderTasks();
                    }
                    this.updateCurrentTaskFromQueue();
                    this.updateSessionInfo();
                    addTaskForm.style.display = 'none';
                    addTaskBtn.disabled = false;
                    console.log('üíæ Task saved successfully');
                } else {
                    console.warn('‚ö†Ô∏è No description provided');
                }
            });
        }

        if (decreaseBtn && pomodorosInput) {
            const newDecreaseBtn = decreaseBtn.cloneNode(true);
            decreaseBtn.replaceWith(newDecreaseBtn);
            newDecreaseBtn.addEventListener('click', () => {
                const current = parseInt(pomodorosInput.value);
                if (current > 1) {
                    pomodorosInput.value = current - 1;
                }
            });
        }

        if (increaseBtn && pomodorosInput) {
            const newIncreaseBtn = increaseBtn.cloneNode(true);
            increaseBtn.replaceWith(newIncreaseBtn);
            newIncreaseBtn.addEventListener('click', () => {
                const current = parseInt(pomodorosInput.value);
                if (current < 10) {
                    pomodorosInput.value = current + 1;
                }
            });
        }

        if (taskInput) {
            const newTaskInput = taskInput.cloneNode(true);
            taskInput.replaceWith(newTaskInput);
            
            // Get fresh references after all replacements
            const finalTaskInput = panel.querySelector('#taskDescription');
            const finalSaveBtn = panel.querySelector('#saveTask');
            
            if (finalTaskInput && finalSaveBtn) {
                finalTaskInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        finalSaveBtn.click();
                    }
                });
                
                finalTaskInput.addEventListener('input', () => {
                    finalSaveBtn.disabled = !finalTaskInput.value.trim();
                });
                
                // Set initial state
                finalSaveBtn.disabled = !finalTaskInput.value.trim();
            }
        }
    }

    setupTaskOptions(modal, renderTasks) {
        const optionsBtn = modal.querySelector('#taskOptionsBtn');
        const optionsDropdown = modal.querySelector('#taskOptionsDropdown');
        const clearAllBtn = modal.querySelector('#clearAllTasksBtn');
        const clearDoneBtn = modal.querySelector('#clearDoneTasksBtn');
        const importBtn = null; // removed menu import button

        if (!optionsBtn || !optionsDropdown) return;

        // Toggle dropdown visibility
        optionsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isVisible = optionsDropdown.style.display !== 'none';
            optionsDropdown.style.display = isVisible ? 'none' : 'block';
        });

        // Close dropdown when clicking anywhere in the modal (except on button/dropdown)
        const closeDropdownOnClick = (e) => {
            // Don't close if clicking on the options button or dropdown
            if (optionsBtn.contains(e.target) || optionsDropdown.contains(e.target)) {
                return;
            }
            // Close if clicking anywhere in the modal
            if (modal.contains(e.target)) {
                optionsDropdown.style.display = 'none';
            }
        };
        
        modal.addEventListener('click', closeDropdownOnClick);

        // Clear all tasks
        if (clearAllBtn) {
            clearAllBtn.addEventListener('click', () => {
                this.trackEvent('Clear All Tasks Clicked', {
                    button_type: 'clear_all_tasks',
                    source: 'tasks_modal'
                });
                if (confirm('Are you sure you want to clear all tasks? This action cannot be undone.')) {
                    // Remove from local tasks - EXACT COPY from Delete Task but filter ALL tasks
                    const tasks = this.getLocalTasks().filter(t => false); // This removes ALL tasks
                    this.setLocalTasks(tasks);
                    // Remove any config for ALL tasks - EXACT COPY from Delete Task but clear all
                    localStorage.removeItem('taskConfigs');
                    // Reset state and UI - EXACT COPY from Delete Task
                    this.editingTaskId = null;
                    // Restore list and add-section - EXACT COPY from Delete Task
                    const listEl = modal.querySelector('#todoistTasksList');
                    const addSection = modal.querySelector('.add-task-section');
                    if (listEl) listEl.style.display = '';
                    if (addSection) addSection.style.display = '';
                    // Refresh list/banner/queue - EXACT COPY from Delete Task
                    this.loadAllTasks();
                    if (typeof renderTasks === 'function') renderTasks();
                    this.updateCurrentTaskBanner();
                    this.rebuildTaskQueue();
                    this.updateCurrentTaskFromQueue();
                    this.updateDisplay();
                    
                    // Force a small delay to ensure DOM updates
                    setTimeout(() => {
                        this.updateCurrentTaskBanner();
                        this.updateCurrentTaskFromQueue();
                        this.updateDisplay(); // Update window title again
                    }, 100);
                    
                    // Additional delay to ensure title updates even if timer is paused
                    setTimeout(() => {
                        this.updateDisplay(); // Force title update
                    }, 200);
                    
                    // Close dropdown
                    optionsDropdown.style.display = 'none';
                }
            });
        }

        // Clear done tasks
        if (clearDoneBtn) {
            clearDoneBtn.addEventListener('click', () => {
                this.trackEvent('Clear Done Tasks Clicked', {
                    button_type: 'clear_done_tasks',
                    source: 'tasks_modal'
                });
                if (confirm('Are you sure you want to clear all completed tasks?')) {
                    const allTasks = this.getAllTasks();
                    const activeTasks = allTasks.filter(task => !task.completed);
                    this.setLocalTasks(activeTasks);
                    // Refresh UI
                    this.loadAllTasks();
                    renderTasks();
                    this.updateCurrentTaskBanner();
                    this.rebuildTaskQueue();
                    // Close dropdown
                    optionsDropdown.style.display = 'none';
                }
            });
        }

        // Import from Todoist
        // no import item in dropdown anymore
    }

    async checkTodoistConnection() {
        try {
            const resp = await fetch('/api/todoist-status');
            const json = await resp.json();
            return !!json.connected;
        } catch (error) {
            console.error('Error checking Todoist connection:', error);
            return false;
        }
    }


    async showTodoistProjectsModal() {
        // Create overlay (ensure on top of Tasks modal)
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';
        overlay.style.zIndex = '100001';

        // Create modal
        const modal = document.createElement('div');
        modal.className = 'focus-stats-modal';
        modal.style.maxWidth = '600px';
        modal.innerHTML = `
            <button class="close-focus-stats-x" id="closeTodoistProjectsModal">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <div class="tasks-header">
                <h3>Import Tasks from Todoist</h3>
                <p class="tasks-subtitle">Select tasks to import from your Todoist projects</p>
            </div>
            
            <div class="todoist-projects-container">
                <div class="loading-state" id="todoistImportLoadingState">
                    <div class="loading-spinner"></div>
                    <p>Loading your Todoist tasks...</p>
                </div>
                <div class="todoist-tasks-list" id="todoistImportTasksList" style="display: none;">
                    <!-- Tasks will be loaded here -->
                </div>
            </div>
            
            <div class="todoist-import-actions" id="todoistImportActions" style="display: none;">
                <button class="btn-secondary" id="clearTodoistSelection">Clear Selection</button>
                <button class="btn-primary" id="importSelectedTasks">Import Selected</button>
            </div>
        `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        // Close modal function
        const closeModal = () => {
            try {
                document.body.removeChild(overlay);
            } catch (_) {}
        };

        // Event listeners
        const closeBtn = modal.querySelector('#closeTodoistProjectsModal');
        if (closeBtn) {
            closeBtn.addEventListener('click', closeModal);
        }

        // Close on overlay click (but not when clicking inside modal)
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                closeModal();
            }
        });

        // Load Todoist tasks
        try {
            await this.loadTodoistTasks(modal);
        } catch (error) {
            console.error('Error loading Todoist tasks:', error);
            // Show error state
            const tasksList = modal.querySelector('#todoistTasksList');
            const loadingState = modal.querySelector('#todoistLoadingState');
            if (loadingState) loadingState.style.display = 'none';
            if (tasksList) {
                tasksList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="15" y1="9" x2="9" y2="15"/>
                                <line x1="9" y1="9" x2="15" y2="15"/>
                            </svg>
                        </div>
                        <div class="empty-text">Error loading tasks</div>
                        <div class="empty-subtext">Please check your Todoist connection and try again</div>
                    </div>
                `;
                tasksList.style.display = 'block';
            }
        }
    }
    async loadTodoistTasks(modal) {
        const loadingState = modal.querySelector('#todoistImportLoadingState');
        const tasksList = modal.querySelector('#todoistImportTasksList');
        const importActions = modal.querySelector('#todoistImportActions');
        
        try {
            // Build query params (Developer Mode + uid) just like other flows
            const viewMode = localStorage.getItem('viewMode');
            const userId = window.Clerk?.user?.id || '';
            const params = new URLSearchParams();
            if (viewMode === 'pro') {
                params.append('devMode', 'pro');
                params.append('bypass', 'true');
            }
            if (userId) params.append('uid', userId);
            const qs = params.toString() ? `?${params.toString()}` : '';

            // Fetch both tasks and projects
            const [tasksResponse, projectsResponse] = await Promise.all([
                fetch(`/api/todoist-tasks${qs}`),
                fetch(`/api/todoist-projects${qs}`)
            ]);

            if (!tasksResponse.ok || !projectsResponse.ok) {
                throw new Error('Failed to fetch data');
            }

            const tasks = await tasksResponse.json();
            const projects = await projectsResponse.json();
            
            // Create project ID to name mapping
            const projectMap = {};
            projects.forEach(project => {
                projectMap[project.id] = project.name;
            });
            
            // Add project_name to each task
            tasks.forEach(task => {
                task.project_name = projectMap[task.project_id] || 'Inbox';
            });
            
            // Hide loading state
            if (loadingState) loadingState.style.display = 'none';
            
            if (tasks.length === 0) {
                // Show empty state
                tasksList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 3h18v18H3zM9 9h6v6H9z"/>
                            </svg>
                        </div>
                        <div class="empty-text">No tasks found</div>
                        <div class="empty-subtext">Create some tasks in Todoist to import them</div>
                    </div>
                `;
            } else {
                // Group tasks by project
                const tasksByProject = this.groupTasksByProject(tasks);
                
                // Render tasks grouped by project
                    const projectEntries = Object.entries(tasksByProject);
                    
                    // Sort projects: Inbox first, then others alphabetically
                    const sortedProjects = projectEntries.sort(([nameA], [nameB]) => {
                        if (nameA === 'Inbox') return -1;
                        if (nameB === 'Inbox') return 1;
                        return nameA.localeCompare(nameB);
                    });
                    
                    tasksList.innerHTML = sortedProjects.map(([projectName, projectTasks]) => {
                        const isInbox = projectName === 'Inbox';
                        return `
                            <div class="todoist-project-section ${isInbox ? 'inbox-section' : ''}">
                                <div class="project-header">
                                    <h4 class="project-title">${isInbox ? 'üì• Inbox' : projectName}</h4>
                                    <span class="project-task-count">${projectTasks.length} task${projectTasks.length > 1 ? 's' : ''}</span>
                                </div>
                                <div class="project-tasks">
                                    ${projectTasks.map(task => `
                                        <div class="todoist-task-item" data-task-id="${task.id}">
                                            <div class="task-checkbox">
                                                <input type="checkbox" id="task-${task.id}" class="task-checkbox-input">
                                                <label for="task-${task.id}" class="task-checkbox-label"></label>
                                            </div>
                                            <div class="task-info">
                                                <div class="task-content">${task.content}</div>
                                                ${task.due ? `<div class="task-due">Due: ${new Date(task.due.date).toLocaleDateString()}</div>` : ''}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                    }).join('');
            }
            
            tasksList.style.display = 'block';
            importActions.style.display = 'flex';
            
            // Setup task selection handlers
            this.setupTodoistTaskSelection(modal);
            
        } catch (error) {
            console.error('Error loading Todoist tasks:', error);
            throw error;
        }
    }

    groupTasksByProject(tasks) {
        const grouped = {};
        
        tasks.forEach(task => {
            // Use project_name if available, otherwise use 'Inbox'
            const projectName = task.project_name || 'Inbox';
            
            if (!grouped[projectName]) {
                grouped[projectName] = [];
            }
            grouped[projectName].push(task);
        });
        
        return grouped;
    }

    setupTodoistTaskSelection(modal) {
        const taskItems = modal.querySelectorAll('.todoist-task-item');
        const clearSelectionBtn = modal.querySelector('#clearTodoistSelection');
        const importBtn = modal.querySelector('#importSelectedTasks');
        
        // Handle task selection
        taskItems.forEach(item => {
            const checkbox = item.querySelector('.task-checkbox-input');
            if (checkbox) {
                // Toggle checkbox when clicking anywhere on the task item
                item.addEventListener('click', (e) => {
                    // Don't toggle if clicking directly on the checkbox or label (let native behavior handle it)
                    if (e.target === checkbox || e.target.classList.contains('task-checkbox-label')) {
                        return;
                    }
                    checkbox.checked = !checkbox.checked;
                    item.classList.toggle('selected', checkbox.checked);
                    this.updateTodoistImportButton(modal);
                });
                
                // Also handle native checkbox change
                checkbox.addEventListener('change', () => {
                    item.classList.toggle('selected', checkbox.checked);
                    this.updateTodoistImportButton(modal);
                });
            }
        });

        // Clear selection
        if (clearSelectionBtn) {
            clearSelectionBtn.addEventListener('click', () => {
                taskItems.forEach(item => {
                    const checkbox = item.querySelector('.task-checkbox-input');
                    if (checkbox) {
                        checkbox.checked = false;
                        item.classList.remove('selected');
                    }
                });
                this.updateTodoistImportButton(modal);
            });
        }

        // Import selected tasks
        if (importBtn) {
            importBtn.addEventListener('click', async () => {
                const selectedTasks = Array.from(taskItems)
                    .filter(item => item.classList.contains('selected'))
                    .map(item => ({
                        id: item.dataset.taskId,
                        content: item.querySelector('.task-content').textContent
                    }));

                if (selectedTasks.length === 0) {
                    alert('Please select at least one task to import.');
                    return;
                }

                try {
                    await this.importTodoistTasks(selectedTasks);
                    // Close modal
                    const overlay = modal.closest('.focus-stats-overlay');
                    if (overlay) {
                        document.body.removeChild(overlay);
                    }
                } catch (error) {
                    console.error('Error importing tasks:', error);
                    alert('Error importing tasks. Please try again.');
                }
            });
        }
    }

    updateTodoistImportButton(modal) {
        const importBtn = modal.querySelector('#importSelectedTasks');
        const selectedCount = modal.querySelectorAll('.todoist-task-item.selected').length;
        
        if (importBtn) {
            if (selectedCount > 0) {
                importBtn.textContent = `Import ${selectedCount} Task${selectedCount > 1 ? 's' : ''}`;
                importBtn.disabled = false;
            } else {
                importBtn.textContent = 'Import Selected';
                importBtn.disabled = true;
            }
        }
    }

    async importTodoistTasks(selectedTasks) {
        try {
            // Add selected tasks to local tasks
            const localTasks = this.getLocalTasks();
            const newTasks = selectedTasks.map(task => ({
                id: `todoist_${task.id}`,
                content: task.content,
                completed: false,
                source: 'todoist'
            }));
            
            // Add new tasks to existing local tasks
            this.setLocalTasks([...localTasks, ...newTasks]);
            
            // Set task config for each new task (selected by default)
            newTasks.forEach(task => {
                this.setTaskConfig(task.id, { 
                    sessions: 1, 
                    selected: true, 
                    completedSessions: 0 
                });
            });
            
            // Refresh the task list
            this.loadAllTasks();
            this.updateCurrentTaskBanner();
            this.rebuildTaskQueue();
            
            // Refresh task modal if it's open
            this.refreshTaskModalIfOpen();
            
        } catch (error) {
            console.error('Error importing Todoist tasks:', error);
            throw error;
        }
    }

    // Show integration upgrade modal for Guest and Free users - Dynamic modal like showTaskListModal
    showIntegrationUpgradeModal(integrationType) {
        const integrationData = {
            todoist: {
                title: 'Todoist Integration',
                subtitle: 'Sync your tasks seamlessly',
                icon: '/images/todoist.svg',
                benefits: [
                    'Import tasks from Todoist projects',
                    'Two-way sync keeps everything updated',
                    'Focus on tasks with Pomodoro timer',
                    'Track productivity across platforms'
                ]
            },
            notion: {
                title: 'Notion Integration',
                subtitle: 'Connect your workspace',
                icon: '/images/notion.svg',
                benefits: [
                    'Import tasks from Notion databases',
                    'Keep your workflow centralized',
                    'Sync task progress automatically',
                    'Boost productivity with seamless integration'
                ]
            },
        };
        
        const data = integrationData[integrationType];
        if (!data) return;
        
        // Determine user type and message
        const isGuest = !this.isAuthenticated || !this.user;
        const isFree = this.isAuthenticated && this.user && !this.isPro;
        
        let upgradeMessage, buttonText;
        if (isGuest) {
            upgradeMessage = 'Sign up to unlock integrations and sync your tasks seamlessly!';
            buttonText = 'Sign up';
        } else if (isFree) {
            upgradeMessage = 'Your tasks live in Todoist or Notion. Why keep switching between apps? Connect them here and focus on what matters‚Äînot on managing tools.';
            buttonText = 'Connect Your Tools';
        } else {
            upgradeMessage = 'Your tasks live in Todoist or Notion. Why keep switching between apps? Connect them here and focus on what matters‚Äînot on managing tools.';
            buttonText = 'Connect Your Tools';
        }
        
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';
        
        // Create modal
        const modal = document.createElement('div');
        modal.className = 'focus-stats-modal';
        modal.style.maxWidth = '500px';
        modal.innerHTML = `
            <button class="close-focus-stats-x">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            
            <div style="text-align: center; margin-bottom: 24px;">
                <div style="margin-bottom: 16px; display: flex; justify-content: center;">
                    <div style="background: white; border-radius: 12px; padding: 12px; display: inline-flex; align-items: center; justify-content: center;">
                        <img src="${data.icon}" alt="${data.title}" style="width: 64px; height: 64px; display: block;">
                    </div>
                </div>
                <h3 style="font-size: 24px; font-weight: 600; margin-bottom: 8px; color: white;">${data.title}</h3>
                <p style="color: rgba(255,255,255,0.7); font-size: 14px;">${data.subtitle}</p>
            </div>
            
            <div style="margin-bottom: 24px;">
                ${data.benefits.map(benefit => `
                    <div style="display: flex; align-items: start; gap: 12px; margin-bottom: 12px;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink: 0; margin-top: 2px;">
                            <polyline points="20 6 9 17 4 12"/>
                        </svg>
                        <span style="color: rgba(255,255,255,0.9); font-size: 14px;">${benefit}</span>
                    </div>
                `).join('')}
            </div>
            
            <div style="text-align: center; margin-bottom: 24px;">
                <p style="color: rgba(255,255,255,0.8); font-size: 14px; line-height: 1.5;">${upgradeMessage}</p>
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 12px;">
                <button class="btn-primary" id="integrationSignupBtn" style="width: 100%;">${buttonText}</button>
                <button class="btn-secondary" id="integrationCancelBtn" style="width: 100%;">Cancel</button>
            </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        const close = () => {
            try { document.body.removeChild(overlay); } catch (_) {}
        };
        
        // Close handlers
        modal.querySelector('.close-focus-stats-x').addEventListener('click', close);
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) close();
        });
        
        // Button handlers
        modal.querySelector('#integrationCancelBtn').addEventListener('click', close);
        modal.querySelector('#integrationSignupBtn').addEventListener('click', () => {
            // Track which integration modal was clicked
            const eventProperties = {
                button_type: 'subscribe',
                source: 'integration_modal',
                location: `${integrationType}_integration_modal`,
                user_type: isGuest ? 'guest' : 'free',
                modal_type: `${integrationType}_integration`,
                integration_type: integrationType
            };
            this.trackEvent('Subscribe Clicked', eventProperties);
            
            if (isGuest) {
                // Guest user - show signup
                this.handleSignup();
            } else {
                // Free user - redirect to pricing page
                window.location.href = '/pricing';
            }
        });
    }

    // Wrapper functions for integration buttons
    async showTodoistProjects() {
        console.log('üîç Todoist click - Auth state:', {
            isAuthenticated: this.isAuthenticated,
            hasUser: !!this.user,
            isPro: this.isPro,
            isPremiumUser: this.isPremiumUser()
        });
        
        // Check if user is Pro (double check with isPremiumUser)
        const isProUser = this.isAuthenticated && this.user && (this.isPro || this.isPremiumUser());
        
        if (isProUser) {
            // Pro users can access integrations
            try {
                // Check if Todoist is connected first
                const isConnected = await this.checkTodoistConnection();
                console.log('üîç Todoist connection status:', isConnected);
                
                if (!isConnected) {
                    // Pro user not connected ‚Üí redirect to auth (same as Settings Connect button)
                    console.log('üîó Redirecting to Todoist auth...');
                    window.location.href = '/api/todoist-auth-start';
                    return;
                }
                // Pro user connected ‚Üí show projects modal
                console.log('üìã Showing Todoist projects modal...');
                await this.showTodoistProjectsModal();
            } catch (error) {
                console.error('Error opening Todoist projects modal:', error);
                alert('Error loading Todoist projects. Please try again.');
            }
        } else {
            // Guest and Free users show integration modal
            console.log('üí∞ Showing integration modal for non-Pro user');
            this.showIntegrationModal('todoist');
        }
    }
    
    showNotionIntegration() {
        // Check if user is Pro
        if (this.isAuthenticated && this.user && this.isPro) {
            // Pro users can access integrations
            // Check if already connected
            fetch('/api/notion-status')
                .then(res => res.json())
                .then(data => {
                if (data.connected) {
                    // Already connected, show import modal
                    this.showNotionPagesModal();
                } else {
                    // Not connected, initiate connection
                    const userId = window.Clerk?.user?.id || '';
                    const viewMode = localStorage.getItem('viewMode');
                    const devModeParam = viewMode === 'pro' ? '&devMode=pro' : '';
                    window.location.href = `/api/notion-auth-start?uid=${encodeURIComponent(userId)}${devModeParam}`;
                }
            })
            .catch(() => {
                alert('Error checking Notion connection. Please try again.');
            });
        } else {
            // Guest and Free users show integration modal
            this.showIntegrationModal('notion');
        }
    }
    
    async showNotionPagesModal() {
        // Create overlay (ensure on top of Tasks modal)
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';
        overlay.style.zIndex = '100001';

        // Create modal
        const modal = document.createElement('div');
        modal.className = 'focus-stats-modal';
        modal.style.maxWidth = '600px';
        modal.innerHTML = `
            <button class="close-focus-stats-x" id="closeNotionPagesModal">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <div class="tasks-header">
                <h3>Import Tasks from Notion</h3>
                <p class="tasks-subtitle">Select pages to import as tasks</p>
            </div>
            
            <div class="todoist-projects-container">
                <div class="loading-state" id="notionImportLoadingState">
                    <div class="loading-spinner"></div>
                    <p>Loading your Notion pages...</p>
                </div>
                <div class="todoist-tasks-list" id="notionImportPagesList" style="display: none;">
                    <!-- Pages will be loaded here -->
                </div>
            </div>
            
            <div class="todoist-import-actions" id="notionImportActions" style="display: none;">
                <button class="btn-secondary" id="clearNotionSelection">Clear Selection</button>
                <button class="btn-primary" id="importSelectedPages">Import Selected</button>
            </div>
        `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        // Close modal function
        const closeModal = () => {
            try {
                document.body.removeChild(overlay);
            } catch (_) {}
        };

        // Event listeners
        const closeBtn = modal.querySelector('#closeNotionPagesModal');
        if (closeBtn) {
            closeBtn.addEventListener('click', closeModal);
        }

        // Close on overlay click (but not when clicking inside modal)
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                closeModal();
            }
        });

        // Load Notion pages
        try {
            await this.loadNotionPages(modal);
        } catch (error) {
            console.error('Error loading Notion pages:', error);
            // Show error state
            const pagesList = modal.querySelector('#notionImportPagesList');
            const loadingState = modal.querySelector('#notionImportLoadingState');
            if (loadingState) loadingState.style.display = 'none';
            if (pagesList) {
                pagesList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="15" y1="9" x2="9" y2="15"/>
                                <line x1="9" y1="9" x2="15" y2="15"/>
                            </svg>
                        </div>
                        <div class="empty-text">Error loading pages</div>
                        <div class="empty-subtext">Please check your Notion connection and try again</div>
                    </div>
                `;
                pagesList.style.display = 'block';
            }
        }
    }
    
    async loadNotionPages(modal) {
        const loadingState = modal.querySelector('#notionImportLoadingState');
        const pagesList = modal.querySelector('#notionImportPagesList');
        const importActions = modal.querySelector('#notionImportActions');
        
        try {
            // Build query params (Developer Mode + uid) - define qs at the beginning
            const viewMode = localStorage.getItem('viewMode');
            const userId = window.Clerk?.user?.id || '';
            const params = new URLSearchParams();
            if (viewMode === 'pro') {
                params.append('devMode', 'pro');
                params.append('bypass', 'true');
            }
            if (userId) params.append('uid', userId);
            const qs = params.toString() ? `?${params.toString()}` : '';

            // Check if we have cached databases
            const cacheKey = 'notion_databases_cache';
            const cachedData = localStorage.getItem(cacheKey);
            const cacheTime = localStorage.getItem(cacheKey + '_time');
            const now = Date.now();
            const CACHE_DURATION = 2 * 60 * 1000; // 2 minutes cache
            
            let databases;
            
            // Use cache if it's fresh (less than 2 minutes old)
            if (cachedData && cacheTime && (now - parseInt(cacheTime)) < CACHE_DURATION) {
                databases = JSON.parse(cachedData);
                console.log('Using cached Notion databases');
                // Skip loading state for cached data
                if (loadingState) loadingState.style.display = 'none';
            } else {
                // Fetch databases from Notion
                const response = await fetch(`/api/notion-pages${qs}`);
                
                if (!response.ok) {
                    throw new Error('Failed to fetch Notion databases');
                }

                databases = await response.json();
                
                // Cache the results
                localStorage.setItem(cacheKey, JSON.stringify(databases));
                localStorage.setItem(cacheKey + '_time', now.toString());
            }
            
            // Hide loading state
            if (loadingState) loadingState.style.display = 'none';
        
            if (databases.length === 0) {
                // Show empty state
                pagesList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 3h18v18H3zM9 9h6v6H9z"/>
                            </svg>
                        </div>
                        <div class="empty-text">No databases found</div>
                        <div class="empty-subtext">Create a database in Notion to import tasks</div>
                    </div>
                `;
            } else {
                // Render databases as clickable items
                pagesList.innerHTML = `
                    <div class="notion-database-list">
                        <div class="notion-instruction">Select a database to view its tasks:</div>
                        ${databases.map(db => `
                            <div class="notion-database-item" data-database-id="${db.id}">
                                <div class="database-info">
                                    <div class="database-name">${db.name}</div>
                                    <div class="database-meta">
                                        ${db.hasCheckbox ? '<span class="db-feature">‚úì Checkbox</span>' : ''}
                                        ${db.hasStatus ? '<span class="db-feature">üìä Status</span>' : ''}
                                    </div>
                                </div>
                                <svg class="chevron-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <polyline points="9 18 15 12 9 6"></polyline>
                                </svg>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                // Setup database selection
                this.setupNotionDatabaseSelection(modal, databases, qs);
            }
        
            pagesList.style.display = 'block';
        
        } catch (error) {
            console.error('Error in loadNotionPages:', error);
            throw error;
        }
    }
    
    setupNotionDatabaseSelection(modal, databases, qs) {
        const databaseItems = modal.querySelectorAll('.notion-database-item');
        
        databaseItems.forEach(item => {
            item.addEventListener('click', async () => {
                const databaseId = item.dataset.databaseId;
                const database = databases.find(db => db.id === databaseId);
                
                if (!database) return;
                
                // Load tasks from this database
                await this.loadNotionDatabaseItems(modal, database, qs);
            });
        });
    }
    
    async loadNotionDatabaseItems(modal, database, qs) {
        const pagesList = modal.querySelector('#notionImportPagesList');
        const importActions = modal.querySelector('#notionImportActions');
        
        try {
            // Show loading
            pagesList.innerHTML = `
                <div class="loading-state">
                    <div class="loading-spinner"></div>
                    <div class="loading-text">Loading tasks...</div>
                </div>
            `;
            
            // Fetch items from the database
            const response = await fetch(`/api/notion-database-items?databaseId=${database.id}&${qs}`);
            
            if (!response.ok) {
                throw new Error('Failed to fetch database items');
            }
            
            const items = await response.json();
            
            // Filter out completed items (only show incomplete tasks)
            const incompleteTasks = items.filter(item => !item.completed);
            
            if (incompleteTasks.length === 0) {
                pagesList.innerHTML = `
                    <div class="empty-state">
                        <div class="back-button" onclick="window.pomodoroTimer.loadNotionPages(this.closest('.focus-stats-modal'))">
                            ‚Üê Back to Databases
                        </div>
                        <div class="empty-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 3h18v18H3zM9 9h6v6H9z"/>
                            </svg>
                        </div>
                        <div class="empty-text">No incomplete tasks</div>
                        <div class="empty-subtext">All tasks in this database are completed</div>
                    </div>
                `;
                importActions.style.display = 'none';
            } else {
                // Render tasks
                pagesList.innerHTML = `
                    <div class="back-button" onclick="window.pomodoroTimer.loadNotionPages(this.closest('.focus-stats-modal'))">
                        ‚Üê Back to Databases
                    </div>
                    <div class="todoist-project-section">
                        <div class="project-header">
                            <h4 class="project-title">${database.name}</h4>
                            <span class="project-task-count">${incompleteTasks.length} task${incompleteTasks.length > 1 ? 's' : ''}</span>
                        </div>
                        <div class="project-tasks">
                            ${incompleteTasks.map(task => `
                                <div class="todoist-task-item" data-task-id="${task.id}" data-checkbox-property="${task.checkboxPropertyName || ''}" data-status-property="${task.statusPropertyName || ''}">
                                    <div class="task-checkbox">
                                        <input type="checkbox" id="notion-${task.id}" class="task-checkbox-input">
                                        <label for="notion-${task.id}" class="task-checkbox-label"></label>
                                    </div>
                                    <div class="task-info">
                                        <div class="task-content">${task.content}</div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                
                importActions.style.display = 'flex';
                
                // Setup task selection
                this.setupNotionTaskSelection(modal);
            }
            
        } catch (error) {
            console.error('Error loading database items:', error);
            pagesList.innerHTML = `
                <div class="empty-state">
                    <div class="back-button" onclick="window.pomodoroTimer.loadNotionPages(this.closest('.focus-stats-modal'))">
                        ‚Üê Back to Databases
                    </div>
                    <div class="empty-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="15" y1="9" x2="9" y2="15"/>
                            <line x1="9" y1="9" x2="15" y2="15"/>
                        </svg>
                    </div>
                    <div class="empty-text">Error loading tasks</div>
                    <div class="empty-subtext">${error.message}</div>
                </div>
            `;
        }
    }
    
    setupNotionTaskSelection(modal) {
        const taskItems = modal.querySelectorAll('.todoist-task-item');
        const clearSelectionBtn = modal.querySelector('#clearNotionSelection');
        const importBtn = modal.querySelector('#importSelectedPages');
        
        // Handle task selection
        taskItems.forEach(item => {
            const checkbox = item.querySelector('.task-checkbox-input');
            if (checkbox) {
                // Only checkbox changes selection
                checkbox.addEventListener('change', () => {
                    item.classList.toggle('selected', checkbox.checked);
                    this.updateNotionImportButton(modal);
                });
            }
        });

        // Clear selection
        if (clearSelectionBtn) {
            clearSelectionBtn.addEventListener('click', () => {
                taskItems.forEach(item => {
                    const checkbox = item.querySelector('.task-checkbox-input');
                    if (checkbox) {
                        checkbox.checked = false;
                        item.classList.remove('selected');
                    }
                });
                this.updateNotionImportButton(modal);
            });
        }

        // Import selected tasks
        if (importBtn) {
            importBtn.addEventListener('click', async () => {
                const selectedTasks = Array.from(taskItems)
                    .filter(item => item.querySelector('.task-checkbox-input')?.checked)
                    .map(item => {
                        const taskId = item.dataset.taskId;
                        const taskContent = item.querySelector('.task-content')?.textContent || '';
                        const checkboxProperty = item.dataset.checkboxProperty;
                        const statusProperty = item.dataset.statusProperty;
                        return { 
                            id: taskId, 
                            content: taskContent,
                            checkboxPropertyName: checkboxProperty,
                            statusPropertyName: statusProperty
                        };
                    });

                if (selectedTasks.length === 0) return;

                // Import tasks as local tasks with notion source
                const localTasks = this.getLocalTasks();
                const newTasks = selectedTasks.map(task => ({
                    id: `notion_${task.id}`,
                    content: task.content,
                    completed: false,
                    source: 'notion',
                    notionPageId: task.id,
                    checkboxPropertyName: task.checkboxPropertyName,
                    statusPropertyName: task.statusPropertyName
                }));
                
                this.setLocalTasks([...localTasks, ...newTasks]);

                // Close modal and refresh task list
                modal.style.display = 'none';
                this.refreshTaskModalIfOpen();

                // Show success message
                this.showNotification(`Imported ${selectedTasks.length} task${selectedTasks.length > 1 ? 's' : ''} from Notion`);
            });
        }

        this.updateNotionImportButton(modal);
    }

    updateNotionImportButton(modal) {
        const importBtn = modal.querySelector('#importSelectedPages');
        const selectedCount = modal.querySelectorAll('.todoist-task-item.selected').length;
        
        if (importBtn) {
            if (selectedCount > 0) {
                importBtn.textContent = `Import ${selectedCount} Page${selectedCount > 1 ? 's' : ''}`;
                importBtn.disabled = false;
            } else {
                importBtn.textContent = 'Import Selected';
                importBtn.disabled = true;
            }
        }
    }

    async completeNotionTask(task, isCompleted) {
        try {
            // Build query params for Pro check
            const viewMode = localStorage.getItem('viewMode');
            const userId = window.Clerk?.user?.id || '';
            const params = new URLSearchParams();
            if (viewMode === 'pro') {
                params.append('devMode', 'pro');
                params.append('bypass', 'true');
            }
            if (userId) params.append('uid', userId);
            const qs = params.toString() ? `?${params.toString()}` : '';
            
            // Call the API to update the task in Notion
            const response = await fetch(`/api/notion-complete-task${qs}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    pageId: task.notionPageId,
                    checkboxPropertyName: task.checkboxPropertyName,
                    statusPropertyName: task.statusPropertyName,
                    completed: isCompleted
                })
            });
            
            if (!response.ok) {
                console.error('Failed to update Notion task');
            }
        } catch (error) {
            console.error('Error completing Notion task:', error);
        }
    }
    
    refreshTaskModalIfOpen() {
        // Check if task sidebar panel is open
        const taskSidePanel = document.getElementById('taskSidePanel');
        if (taskSidePanel && taskSidePanel.classList.contains('open')) {
            console.log('üîÑ Refreshing Task sidebar panel');
            // Get the tasks list element
            const listEl = taskSidePanel.querySelector('#todoistTasksList');
            if (listEl) {
                // Get current active tab
                const activeTabEl = taskSidePanel.querySelector('.task-tab.active');
                const currentTab = activeTabEl ? activeTabEl.dataset.tab : 'todo';
                
                // Clear only task items and headers, preserve the form
                const taskItems = listEl.querySelectorAll('.task-item, .empty-state, .task-source-header');
                taskItems.forEach(item => item.remove());
                
                const allTasks = this.getAllTasks();
                
                // Filter tasks based on current tab
                let filteredTasks = allTasks;
                if (currentTab === 'todo') {
                    filteredTasks = allTasks.filter(task => !task.completed);
                } else if (currentTab === 'done') {
                    filteredTasks = allTasks.filter(task => task.completed);
                }
                
                if (filteredTasks.length === 0) {
                    if (currentTab === 'done') {
                        const emptyState = document.createElement('div');
                        emptyState.className = 'empty-state';
                        emptyState.innerHTML = `
                            <div class="empty-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M9 12l2 2 4-4"/>
                                    <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/>
                                </svg>
                            </div>
                            <div class="empty-text">No completed tasks yet</div>
                            <div class="empty-subtext">Complete some tasks to see them here</div>
                        `;
                        listEl.appendChild(emptyState);
                    }
                } else {
                    // Group tasks by source
                    const tasksBySource = {
                        'local': [],
                        'todoist': [],
                        'notion': []
                    };
                    
                    filteredTasks.forEach(task => {
                        const source = task.source || 'local';
                        if (tasksBySource[source]) {
                            tasksBySource[source].push(task);
                        } else {
                            tasksBySource['local'].push(task);
                        }
                    });
                    
                    // Apply saved task order within each source
                    const savedOrder = this.getTaskOrder();
                    Object.keys(tasksBySource).forEach(source => {
                        const tasks = tasksBySource[source];
                        if (savedOrder.length > 0 && tasks.length > 0) {
                            const taskMap = new Map(tasks.map(task => [task.id, task]));
                            const orderedTasks = [];
                            savedOrder.forEach(orderItem => {
                                if (taskMap.has(orderItem.id)) {
                                    orderedTasks.push(taskMap.get(orderItem.id));
                                    taskMap.delete(orderItem.id);
                                }
                            });
                            taskMap.forEach(task => orderedTasks.push(task));
                            tasksBySource[source] = orderedTasks;
                        }
                    });
                    
                    // Get the form element to insert before it (if it exists)
                    const addTaskFormEl = listEl.querySelector('#addTaskForm');
                    
                    // Source labels
                    const sourceConfig = {
                        'local': { label: 'My Tasks' },
                        'todoist': { label: 'From Todoist' },
                        'notion': { label: 'From Notion' }
                    };
                    
                    // Check how many sources have tasks
                    const sourcesWithTasks = Object.keys(tasksBySource).filter(source => tasksBySource[source].length > 0);
                    const showHeaders = sourcesWithTasks.length > 1 || (sourcesWithTasks.length === 1 && sourcesWithTasks[0] !== 'local');
                    
                    // Render tasks grouped by source
                    let globalIndex = 0;
                    ['local', 'todoist', 'notion'].forEach(source => {
                        const tasks = tasksBySource[source];
                        if (tasks.length === 0) return;
                        
                        // Create source header (only if needed)
                        if (showHeaders) {
                            const sourceHeader = document.createElement('div');
                            sourceHeader.className = 'task-source-header';
                            const config = sourceConfig[source];
                            sourceHeader.innerHTML = `
                                <span class="source-label">${config.label}</span>
                                <span class="source-count">${tasks.length}</span>
                            `;
                            
                            // Insert before the form if it exists, otherwise append
                            if (addTaskFormEl) {
                                listEl.insertBefore(sourceHeader, addTaskFormEl);
                            } else {
                                listEl.appendChild(sourceHeader);
                            }
                        }
                        
                        // Render tasks for this source
                        tasks.forEach((task) => {
                            const item = document.createElement('div');
                            item.className = 'task-item';
                            item.draggable = true;
                            item.dataset.taskId = task.id;
                            item.dataset.index = globalIndex++;
                            item.dataset.source = source;
                            
                            const taskConfig = this.getTaskConfig(task.id);
                            const completedSessions = taskConfig.completedSessions || 0;
                            const totalSessions = taskConfig.sessions || 1;
                            const isCompleted = task.completed || (completedSessions >= totalSessions);
                            
                            const itemContent = `
                                <div class="task-checkbox">
                                    <input type="checkbox" id="task-${task.id}" ${isCompleted ? 'checked' : ''}>
                                    <label for="task-${task.id}"></label>
                                </div>
                                <div class="task-content">
                                    <div class="task-title">
                                        ${task.content || '(untitled)'}
                                    </div>
                                </div>
                                <div class="task-progress">
                                    <span class="progress-text">${completedSessions}/${totalSessions}</span>
                                </div>
                                ${!isCompleted ? `
                                <div class="task-menu" data-task-id="${task.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="1"/>
                                        <circle cx="19" cy="12" r="1"/>
                                        <circle cx="5" cy="12" r="1"/>
                                    </svg>
                                </div>
                                ` : ''}
                            `;
                            
                            item.innerHTML = itemContent;
                            
                            // Add completed class if task is completed
                            if (isCompleted) {
                                item.classList.add('completed');
                            }
                            
                            // Only apply 'selected' class if task is NOT completed
                            if (taskConfig.selected && !isCompleted) {
                                item.classList.add('selected');
                            }
                            
                            // Insert before the form if it exists, otherwise append
                            if (addTaskFormEl) {
                                listEl.insertBefore(item, addTaskFormEl);
                            } else {
                                listEl.appendChild(item);
                            }
                        });
                    });
                    
                    // Re-setup event listeners after rendering
                    this.setupTaskEventListeners(taskSidePanel);
                    this.setupDragAndDrop(taskSidePanel);
                }
            }
            return;
        }
        
        // Check if task modal is currently open
        const taskModal = document.querySelector('.focus-stats-overlay');
        if (taskModal) {
            // Find the tasks list element
            const tasksList = taskModal.querySelector('#todoistTasksList');
            if (tasksList) {
                // Get current tab
                const activeTab = taskModal.querySelector('.task-tab.active');
                const currentTab = activeTab ? activeTab.dataset.tab : 'todo';
                
                // Re-render tasks for the current tab
                const allTasks = this.getAllTasks();
                let filteredTasks = allTasks;
                if (currentTab === 'todo') {
                    filteredTasks = allTasks.filter(task => !task.completed);
                } else if (currentTab === 'done') {
                    filteredTasks = allTasks.filter(task => task.completed);
                }
                
                if (filteredTasks.length === 0) {
                    if (currentTab === 'done') {
                        tasksList.innerHTML = `
                            <div class="empty-state">
                                <div class="empty-icon">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M9 12l2 2 4-4"/>
                                        <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/>
                                    </svg>
                                </div>
                                <div class="empty-text">No completed tasks yet</div>
                                <div class="empty-subtext">Complete some tasks to see them here</div>
                            </div>
                        `;
                    } else {
                        tasksList.innerHTML = '';
                    }
                } else {
                    // Apply saved task order
                    const savedOrder = this.getTaskOrder();
                    let orderedTasks = filteredTasks;
                    
                    if (savedOrder.length > 0) {
                        const taskMap = new Map(filteredTasks.map(task => [task.id, task]));
                        orderedTasks = [];
                        savedOrder.forEach(orderItem => {
                            if (taskMap.has(orderItem.id)) {
                                orderedTasks.push(taskMap.get(orderItem.id));
                                taskMap.delete(orderItem.id);
                            }
                        });
                        taskMap.forEach(task => orderedTasks.push(task));
                    }
                    
                    // Render tasks
                    tasksList.innerHTML = orderedTasks.map(task => {
                        const config = this.getTaskConfig(task.id);
                        const isSelected = config.selected;
                        const sessions = config.sessions || 1;
                        const completedSessions = config.completedSessions || 0;
                        
                        return `
                            <div class="task-item ${isSelected ? 'selected' : ''}" data-task-id="${task.id}">
                                <div class="task-content">
                                    <div class="task-title">${task.content}</div>
                                    ${task.source === 'todoist' ? '<div class="task-project">Todoist</div>' : ''}
                                </div>
                                <div class="task-actions">
                                    <div class="task-sessions">
                                        <span class="sessions-text">${completedSessions}/${sessions}</span>
                                    </div>
                                    <button class="task-toggle-btn ${isSelected ? 'active' : ''}" data-task-id="${task.id}">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M9 12l2 2 4-4"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        `;
                    }).join('');
                    
                    // Re-setup event listeners for the new tasks
                    this.setupTaskItemListeners(tasksList);
                }
            }
        }
    }

    setupTaskItemListeners(container) {
        // Setup toggle buttons
        const toggleBtns = container.querySelectorAll('.task-toggle-btn');
        toggleBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const taskId = btn.dataset.taskId;
                const taskItem = btn.closest('.task-item');
                const config = this.getTaskConfig(taskId);
                
                // Toggle selection
                const newSelected = !config.selected;
                this.setTaskConfig(taskId, { ...config, selected: newSelected });
                
                // Update UI
                taskItem.classList.toggle('selected', newSelected);
                btn.classList.toggle('active', newSelected);
                
                // Update task button state and header
                this.updateTaskButtonState();
                this.updateCurrentTaskFromQueue();
                this.updateSessionInfo();
            });
        });
    }

    // Task configuration management
    getTaskConfig(taskId) {
        const configs = JSON.parse(localStorage.getItem('taskConfigs') || '{}');
        return configs[taskId] || { sessions: 1, selected: false };
    }

    setTaskConfig(taskId, config) {
        const configs = JSON.parse(localStorage.getItem('taskConfigs') || '{}');
        configs[taskId] = { ...configs[taskId], ...config };
        localStorage.setItem('taskConfigs', JSON.stringify(configs));
    }

    incrementTaskCompletedSessions(taskId) {
        const config = this.getTaskConfig(taskId);
        const currentCompleted = config.completedSessions || 0;
        const newCompleted = currentCompleted + 1;
        
        // Don't exceed the total sessions planned
        const totalSessions = config.sessions || 1;
        const finalCompleted = Math.min(newCompleted, totalSessions);
        
        this.setTaskConfig(taskId, { 
            ...config, 
            completedSessions: finalCompleted 
        });
    }

    setupTaskEventListeners(modal) {
        // Task checkbox click listeners - manual completion toggle
        const taskCheckboxes = modal.querySelectorAll('.task-checkbox input[type="checkbox"]');
        taskCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                e.stopPropagation();
                
                // Prevent action if checkbox is disabled (Done tab - read-only)
                if (checkbox.disabled) {
                    return;
                }
                
                const taskId = checkbox.id.replace('task-', '');
                const isChecked = checkbox.checked;
                
                // Update task completion status
                this.toggleTaskCompletion(taskId, isChecked);
                
                // Update visual state
                this.updateTaskCompletionVisual(modal, taskId, isChecked);
                
                // Update window title immediately
                this.updateDisplay();

                // If we're on To-do and the task just got completed, remove it immediately
                // If we're on Done and the task was unchecked, remove it immediately
                const activeTab = modal.querySelector('.task-tab.active');
                const currentTab = activeTab ? activeTab.dataset.tab : 'todo';
                const taskItem = modal.querySelector(`[data-task-id="${taskId}"]`);
                if (taskItem) {
                    const shouldRemoveFromCurrentView = (currentTab === 'todo' && isChecked) || (currentTab === 'done' && !isChecked);
                    if (shouldRemoveFromCurrentView) {
                        try { taskItem.remove(); } catch (_) {}
                    }
                }

                // Ensure counts/empty state reflect the change
                this.rerenderTaskList();
            });
        });

        // Task menu (3 dots) click listeners - use bottom form in edit mode
        const taskMenus = modal.querySelectorAll('.task-menu');
        taskMenus.forEach(menu => {
            menu.addEventListener('click', (e) => {
                e.stopPropagation();
                const taskId = menu.dataset.taskId;
                const addTaskForm = modal.querySelector('#addTaskForm');
                const addTaskBtn = modal.querySelector('#showAddTaskForm');
                if (!addTaskForm || !addTaskBtn) return;
                
                // Enter edit mode, prefill fields
                const task = this.getLocalTasks().find(t => t.id === taskId);
                if (!task) {
                    // Only local tasks can be edited inline
                    return;
                }
                const config = this.getTaskConfig(taskId);
                this.editingTaskId = taskId;
                addTaskForm.style.display = 'block';
                addTaskBtn.disabled = true;
                // Hide list and add-section while editing
                const listEl = modal.querySelector('#todoistTasksList');
                const addSection = modal.querySelector('.add-task-section');
                if (listEl) listEl.style.display = 'none';
                if (addSection) addSection.style.display = 'none';
                const taskInput = addTaskForm.querySelector('#taskDescription');
                const pomodorosInput = addTaskForm.querySelector('#pomodorosCount');
                const deleteBtn = addTaskForm.querySelector('#deleteTask');
                if (taskInput) taskInput.value = task ? (task.content || '') : '';
                if (pomodorosInput) pomodorosInput.value = String(config.sessions || 1);
                if (deleteBtn) deleteBtn.style.display = '';
                if (taskInput) taskInput.focus();
                
                // Scroll form into view
                try { addTaskForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } catch (_) {}
            });
        });
    }

    updateTaskSelectionVisual(modal, taskId, selected) {
        const taskItem = modal.querySelector(`[data-task-id="${taskId}"]`);
        if (taskItem) {
            if (selected) {
                taskItem.classList.add('selected');
            } else {
                taskItem.classList.remove('selected');
            }
        }
    }

    toggleTaskCompletion(taskId, isCompleted) {
        // Get all tasks to determine the source
        const allTasks = this.getAllTasks();
        const task = allTasks.find(t => t.id === taskId);
        
        if (task) {
            if (task.source === 'local') {
                // Update local task completion status
                const localTasks = this.getLocalTasks();
                const taskIndex = localTasks.findIndex(t => t.id === taskId);
                if (taskIndex !== -1) {
                    localTasks[taskIndex].completed = isCompleted;
                    if (isCompleted) {
                        localTasks[taskIndex].completedAt = new Date().toISOString();
                    } else {
                        delete localTasks[taskIndex].completedAt;
                    }
                    this.setLocalTasks(localTasks);
                }
            } else if (task.source === 'todoist') {
                // For Todoist tasks imported to local storage, update them there
                const localTasks = this.getLocalTasks();
                const taskIndex = localTasks.findIndex(t => t.id === taskId);
                if (taskIndex !== -1) {
                    localTasks[taskIndex].completed = isCompleted;
                    if (isCompleted) {
                        localTasks[taskIndex].completedAt = new Date().toISOString();
                    } else {
                        delete localTasks[taskIndex].completedAt;
                    }
                    this.setLocalTasks(localTasks);
                }
                
                // Also track completion state for live Todoist tasks
                this.updateTodoistTaskCompletionState(taskId, isCompleted);
                
                // If completing, also call the API
                if (isCompleted) {
                    this.completeTodoistTaskInTodoist(taskId);
                }
            } else if (task.source === 'notion') {
                // For Notion tasks, update in local tasks
                const localTasks = this.getLocalTasks();
                const taskIndex = localTasks.findIndex(t => t.id === taskId);
                if (taskIndex !== -1) {
                    localTasks[taskIndex].completed = isCompleted;
                    if (isCompleted) {
                        localTasks[taskIndex].completedAt = new Date().toISOString();
                    } else {
                        delete localTasks[taskIndex].completedAt;
                    }
                    this.setLocalTasks(localTasks);
                }
                
                // Update task in Notion
                this.completeNotionTask(task, isCompleted);
            }
        }
        
        // Update task config to reflect completion
        const taskConfig = this.getTaskConfig(taskId);
        if (isCompleted) {
            // Mark as completed by setting completed sessions to total sessions
            this.setTaskConfig(taskId, { 
                ...taskConfig, 
                completedSessions: taskConfig.sessions || 1 
            });
        } else {
            // Reset completion by setting completed sessions to 0
            this.setTaskConfig(taskId, { 
                ...taskConfig, 
                completedSessions: 0 
            });
        }
        
        // Update the main timer banner
        this.updateCurrentTaskBanner();
        this.rebuildTaskQueue();
        this.updateCurrentTaskFromQueue();
        this.updateDisplay();
        
        // Re-render tasks to move between tabs
        this.rerenderTaskList();
    }

    updateTaskCompletionVisual(modal, taskId, isCompleted) {
        const taskItem = modal.querySelector(`[data-task-id="${taskId}"]`);
        if (taskItem) {
            if (isCompleted) {
                taskItem.classList.add('completed');
            } else {
                taskItem.classList.remove('completed');
            }
        }
    }

    rerenderTaskList() {
        // Update the task sidebar panel if it's open
        const taskSidePanel = document.getElementById('taskSidePanel');
        if (taskSidePanel && taskSidePanel.classList.contains('open')) {
            this.refreshTaskModalIfOpen();
        }
        
        // Find the tasks modal and re-render the task list
        // The modal uses the class 'focus-stats-overlay'/'focus-stats-modal' for the tasks UI
        const modal = document.querySelector('.focus-stats-modal');
        if (modal) {
            const listEl = modal.querySelector('#todoistTasksList');
            if (listEl) {
                // Get current tab
                const activeTab = modal.querySelector('.task-tab.active');
                const currentTab = activeTab ? activeTab.dataset.tab : 'todo';
                
                // Re-render tasks with current tab filter
                this.renderTasksInModal(modal, currentTab);
            }
        }
    }

    renderTasksInModal(modal, currentTab) {
        const listEl = modal.querySelector('#todoistTasksList');
        if (!listEl) return;
        
        listEl.innerHTML = '';
        const allTasks = this.getAllTasks();
        
        // Filter tasks based on current tab
        let filteredTasks = allTasks;
        if (currentTab === 'todo') {
            filteredTasks = allTasks.filter(task => !task.completed);
        } else if (currentTab === 'done') {
            filteredTasks = allTasks.filter(task => task.completed);
        }
        
        if (filteredTasks.length === 0) {
            // Show appropriate message based on current tab
            if (currentTab === 'done') {
                listEl.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 12l2 2 4-4"/>
                                <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/>
                            </svg>
                        </div>
                        <div class="empty-text">No completed tasks yet</div>
                        <div class="empty-subtext">Complete some tasks to see them here</div>
                    </div>
                `;
            } else {
                // For todo tab, show empty list without message
                listEl.innerHTML = '';
            }
            return;
        }
        
        // Apply saved task order
        const savedOrder = this.getTaskOrder();
        let orderedTasks = filteredTasks;
        
        if (savedOrder.length > 0) {
            orderedTasks = filteredTasks.sort((a, b) => {
                const aIndex = savedOrder.indexOf(a.id);
                const bIndex = savedOrder.indexOf(b.id);
                if (aIndex === -1 && bIndex === -1) return 0;
                if (aIndex === -1) return 1;
                if (bIndex === -1) return -1;
                return aIndex - bIndex;
            });
        }
        
        orderedTasks.forEach((task, index) => {
            const item = document.createElement('div');
            item.className = 'task-item';
            // Disable drag & drop in Done tab (read-only)
            item.draggable = currentTab !== 'done';
            item.dataset.taskId = task.id;
            item.dataset.index = index;
            
            const taskConfig = this.getTaskConfig(task.id);
            const completedSessions = taskConfig.completedSessions || 0;
            const totalSessions = taskConfig.sessions || 1;
            const isCompleted = task.completed || (completedSessions >= totalSessions);
            
            // Disable checkbox in Done tab (read-only)
            const checkboxDisabled = currentTab === 'done' ? 'disabled' : '';
            
            const itemContent = `
                <div class="task-checkbox ${currentTab === 'done' ? 'disabled' : ''}">
                    <input type="checkbox" id="task-${task.id}" ${isCompleted ? 'checked' : ''} ${checkboxDisabled}>
                    <label for="task-${task.id}"></label>
                </div>
                <div class="task-content">
                    <div class="task-title">
                        ${task.content || '(untitled)'}
                    </div>
                </div>
                <div class="task-progress">
                    <span class="progress-text">${completedSessions}/${totalSessions}</span>
                </div>
                <div class="task-menu" data-task-id="${task.id}">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="1"/>
                        <circle cx="19" cy="12" r="1"/>
                        <circle cx="5" cy="12" r="1"/>
                    </svg>
                </div>
            `;
            
            item.innerHTML = itemContent;
            
            // Set initial selected state
            if (taskConfig.selected) {
                item.classList.add('selected');
            }
            
            // Add completed class if task is completed
            if (isCompleted) {
                item.classList.add('completed');
            }
            
            // Add read-only class in Done tab
            if (currentTab === 'done') {
                item.classList.add('read-only');
            }
            
            listEl.appendChild(item);
        });
        
        // Re-setup event listeners for the new elements
        this.setupTaskEventListeners(modal);
    }
    showEditTaskInline(taskId, modal) {
        const task = this.getLocalTasks().find(t => t.id === taskId);
        if (!task) return;

        const taskItem = modal.querySelector(`[data-task-id="${taskId}"]`);
        if (!taskItem) return;

        const taskConfig = this.getTaskConfig(taskId);
        const currentSessions = taskConfig.sessions || 1;

        // Replace task item with the same form component as Add Task
        taskItem.innerHTML = `
            <div class="add-task-form">
                <div class="form-group">
                    <label>What are you working on?</label>
                    <input type="text" id="editTaskDescription" value="${task.content}" maxlength="100">
                </div>
                <div class="form-group">
                    <label>Sessions</label>
                    <div class="pomodoros-control">
                        <button class="pomodoros-btn" id="editDecreasePomodoros">-</button>
                        <input type="number" id="editPomodorosCount" value="${currentSessions}" min="1" max="10">
                        <button class="pomodoros-btn" id="editIncreasePomodoros">+</button>
                    </div>
                </div>
                <div class="form-actions">
                    <button class="btn-secondary" id="cancelEditTask">Cancel</button>
                    <button class="btn-primary" id="saveEditTask">Save</button>
                </div>
            </div>
        `;

        // Setup form controls
        const taskInput = taskItem.querySelector('#editTaskDescription');
        const pomodorosInput = taskItem.querySelector('#editPomodorosCount');
        const decreaseBtn = taskItem.querySelector('#editDecreasePomodoros');
        const increaseBtn = taskItem.querySelector('#editIncreasePomodoros');
        const saveBtn = taskItem.querySelector('#saveEditTask');
        const cancelBtn = taskItem.querySelector('#cancelEditTask');

        // Pomodoros controls
        if (decreaseBtn && pomodorosInput) {
            decreaseBtn.addEventListener('click', () => {
                const current = parseInt(pomodorosInput.value);
                if (current > 1) {
                    pomodorosInput.value = current - 1;
                }
            });
        }

        if (increaseBtn && pomodorosInput) {
            increaseBtn.addEventListener('click', () => {
                const current = parseInt(pomodorosInput.value);
                if (current < 10) {
                    pomodorosInput.value = current + 1;
                }
            });
        }

        // Cancel button - restore original task item
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                // Deselect the task when canceling edit
                this.setTaskConfig(taskId, { ...taskConfig, selected: false });
                this.updateCurrentTaskBanner();
                this.rebuildTaskQueue();
                
                // Re-render the task list to restore original items
                const renderTasks = () => {
                    const listEl = modal.querySelector('#todoistTasksList');
                    if (!listEl) return;
                    
                    listEl.innerHTML = '';
                    const allTasks = this.getAllTasks();
                    
                    if (allTasks.length === 0) {
                        const addTaskForm = modal.querySelector('#addTaskForm');
                        const addTaskBtn = modal.querySelector('#showAddTaskForm');
                        if (addTaskForm) addTaskForm.style.display = 'block';
                        if (addTaskBtn) {
                            addTaskBtn.style.display = 'none';
                            addTaskBtn.disabled = true;
                        }
                        return;
                    }
                    
                    allTasks.forEach((task, index) => {
                        const item = document.createElement('div');
                        item.className = 'task-item';
                        item.draggable = true;
                        item.dataset.taskId = task.id;
                        item.dataset.index = index;
                        
                        const taskConfig = this.getTaskConfig(task.id);
                        const completedSessions = taskConfig.completedSessions || 0;
                        const totalSessions = taskConfig.sessions || 1;
                        const isCompleted = task.completed || (completedSessions >= totalSessions);
                        
                        const itemContent = `
                            <div class="task-checkbox">
                                <input type="checkbox" id="task-${task.id}" ${isCompleted ? 'checked' : ''} disabled>
                                <label for="task-${task.id}"></label>
                            </div>
                            <div class="task-content">
                                <div class="task-title">
                                    ${task.content || '(untitled)'}
                                </div>
                            </div>
                            <div class="task-progress">
                                <span class="progress-text">${completedSessions}/${totalSessions}</span>
                            </div>
                            <div class="task-menu" data-task-id="${task.id}">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="1"/>
                                    <circle cx="19" cy="12" r="1"/>
                                    <circle cx="5" cy="12" r="1"/>
                                </svg>
                            </div>
                        `;
                        
                        item.innerHTML = itemContent;
                        
                        if (taskConfig.selected) {
                            item.classList.add('selected');
                        }
                        
                        listEl.appendChild(item);
                    });
                    
                    this.setupTaskEventListeners(modal);
                };
                
                renderTasks();
            });
        }

        // Save button
        if (saveBtn) {
            saveBtn.addEventListener('click', () => {
                const description = taskInput ? taskInput.value.trim() : '';
                const pomodoros = pomodorosInput ? parseInt(pomodorosInput.value) : 1;
                
                if (description) {
                    // Update task content
                    const tasks = this.getLocalTasks();
                    const taskIndex = tasks.findIndex(t => t.id === taskId);
                    if (taskIndex !== -1) {
                        tasks[taskIndex].content = description;
                        this.setLocalTasks(tasks);
                    }
                    
                    // Update task config
                    this.setTaskConfig(taskId, { sessions: pomodoros });
                    
                    // Re-render the task list
                    const renderTasks = () => {
                        const listEl = modal.querySelector('#todoistTasksList');
                        if (!listEl) return;
                        
                        listEl.innerHTML = '';
                        const allTasks = this.getAllTasks();
                        
                        if (allTasks.length === 0) {
                            const addTaskForm = modal.querySelector('#addTaskForm');
                            const addTaskBtn = modal.querySelector('#showAddTaskForm');
                            if (addTaskForm) addTaskForm.style.display = 'block';
                            if (addTaskBtn) {
                                addTaskBtn.style.display = 'none';
                                addTaskBtn.disabled = true;
                            }
                            return;
                        }
                        
                        allTasks.forEach((task, index) => {
                            const item = document.createElement('div');
                            item.className = 'task-item';
                            item.draggable = true;
                            item.dataset.taskId = task.id;
                            item.dataset.index = index;
                            
                            const taskConfig = this.getTaskConfig(task.id);
                            const completedSessions = taskConfig.completedSessions || 0;
                            const totalSessions = taskConfig.sessions || 1;
                            const isCompleted = task.completed || (completedSessions >= totalSessions);
                            
                            const itemContent = `
                                <div class="task-checkbox">
                                    <input type="checkbox" id="task-${task.id}" ${isCompleted ? 'checked' : ''} disabled>
                                    <label for="task-${task.id}"></label>
                                </div>
                                <div class="task-content">
                                    <div class="task-title">
                                        ${task.content || '(untitled)'}
                                    </div>
                                </div>
                                <div class="task-progress">
                                    <span class="progress-text">${completedSessions}/${totalSessions}</span>
                                </div>
                                <div class="task-menu" data-task-id="${task.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="1"/>
                                        <circle cx="19" cy="12" r="1"/>
                                        <circle cx="5" cy="12" r="1"/>
                                    </svg>
                                </div>
                            `;
                            
                            item.innerHTML = itemContent;
                            
                            if (taskConfig.selected) {
                                item.classList.add('selected');
                            }
                            
                            listEl.appendChild(item);
                        });
                        
                        this.setupTaskEventListeners(modal);
                    };
                    
                    renderTasks();
                    // Update header to reflect changes immediately
                    this.updateCurrentTaskFromQueue();
                    this.updateSessionInfo();
                }
            });
        }

        // Enter key to save
        if (taskInput) {
            taskInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && saveBtn) {
                    saveBtn.click();
                }
            });
        }

        // Focus on the input field
        if (taskInput) {
            taskInput.focus();
        }

        // Auto-select the task being edited
        this.setTaskConfig(taskId, { ...taskConfig, selected: true });
        this.updateCurrentTaskBanner();
        this.rebuildTaskQueue();
    }


    calculateFinishTime(totalMinutes) {
        if (totalMinutes === 0) return '--:--';
        
        const now = new Date();
        const finishTime = new Date(now.getTime() + totalMinutes * 60000);
        return finishTime.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            hour12: false 
        });
    }

    // Show selected tasks in the main timer interface
    updateCurrentTaskBanner() {
        const selectedTasks = this.getSelectedTasks();
        const taskBanner = document.getElementById('currentTaskBanner');
        
        console.log('üîÑ updateCurrentTaskBanner called', { 
            selectedTasksCount: selectedTasks.length, 
            bannerExists: !!taskBanner,
            selectedTasks: selectedTasks.map(t => ({ id: t.id, content: t.content, selected: this.getTaskConfig(t.id).selected }))
        });
        
        if (!taskBanner) {
            // Create task banner if it doesn't exist
            console.log('üîÑ Creating task banner...');
            this.createTaskBanner();
            return;
        }

        if (selectedTasks.length === 0) {
            console.log('üîÑ No selected tasks, hiding banner');
            taskBanner.style.display = 'none';
            return;
        }

        // Show current task and progress (use currentTaskIndex across queue)
        let currentTask;
        if (Array.isArray(this.taskQueue) && this.taskQueue.length > 0 && this.currentTaskIndex < this.taskQueue.length) {
            currentTask = this.taskQueue[this.currentTaskIndex];
        } else {
            currentTask = selectedTasks[0];
        }
        
        console.log('üîÑ Showing task in banner', { currentTask: currentTask?.content });
        
        const taskInfo = document.getElementById('currentTaskInfo');
        const taskProgress = document.getElementById('taskProgress');
        
        if (taskInfo) {
            taskInfo.innerHTML = `
                <div class="current-task-title">${currentTask.content}</div>
                <div class="current-task-progress">Task 1 of ${selectedTasks.length}</div>
            `;
        }
        
        if (taskProgress) {
            taskProgress.innerHTML = `
                <div class="task-sessions-info">
                    <span>${currentTask.sessions} session${currentTask.sessions > 1 ? 's' : ''}</span>
                </div>
            `;
        }

        taskBanner.style.display = 'block';
        console.log('üîÑ Banner should now be visible');
        
        // Update task button state
        this.updateTaskButtonState();
    }

    updateTaskButtonState() {
        const taskButton = document.getElementById('taskToggleBtn');
        if (!taskButton) return;

        const selectedTasks = this.getSelectedTasks();
        
        if (selectedTasks.length > 0) {
            // Has active tasks - make button blue
            taskButton.classList.add('active');
        } else {
            // No active tasks - make button white
            taskButton.classList.remove('active');
        }
    }

    createTaskBanner() {
        // Create task banner element
        const taskBanner = document.createElement('div');
        taskBanner.id = 'currentTaskBanner';
        taskBanner.className = 'current-task-banner';
        taskBanner.style.display = 'none';
        
        taskBanner.innerHTML = `
            <div class="current-task-content">
                <div class="current-task-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 12l2 2 4-4"/>
                        <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/>
                    </svg>
                </div>
                <div class="current-task-details">
                    <div id="currentTaskInfo">
                        <div class="current-task-title">No task selected</div>
                        <div class="current-task-progress">Select a task to focus on</div>
                    </div>
                    <div id="taskProgress">
                        <div class="task-sessions-info">0 sessions</div>
                    </div>
                </div>
                <button class="change-task-btn" id="changeTaskBtn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 6h18"/>
                        <path d="M3 12h18"/>
                        <path d="M3 18h18"/>
                    </svg>
                </button>
            </div>
        `;

        // Insert after the timer content
        const timerContent = document.querySelector('.timer-content');
        if (timerContent) {
            timerContent.parentNode.insertBefore(taskBanner, timerContent.nextSibling);
        }

        // Add event listener for change task button
        const changeTaskBtn = document.getElementById('changeTaskBtn');
        if (changeTaskBtn) {
            changeTaskBtn.addEventListener('click', () => {
                this.showTaskListModal();
            });
        }
    }

    getSelectedTasks() {
        const allTasks = this.getAllTasks();
        
        console.log('üîç getSelectedTasks - allTasks:', allTasks.map(t => ({ id: t.id, content: t.content, completed: t.completed })));
        
        // Get selected tasks
        const selectedTasks = allTasks.filter(task => {
            const config = this.getTaskConfig(task.id);
            const isSelected = config.selected && !task.completed;
            console.log('üîç Task filter:', { 
                id: task.id, 
                content: task.content, 
                selected: config.selected, 
                completed: task.completed, 
                isSelected 
            });
            return isSelected;
        }).map(task => {
            const config = this.getTaskConfig(task.id);
            return {
                ...task,
                sessions: config.sessions || 1
            };
        });
        
        console.log('üîç getSelectedTasks - selectedTasks COUNT:', selectedTasks.length);
        console.log('üîç getSelectedTasks - selectedTasks:', selectedTasks.map(t => ({ id: t.id, content: t.content })));
        console.log('üîç getSelectedTasks - selectedTasks FULL:', selectedTasks);
        
        // Apply saved task order
        const savedOrder = this.getTaskOrder();
        console.log('üîç savedOrder:', savedOrder);
        console.log('üîç savedOrder.length:', savedOrder.length);
        
        if (savedOrder.length > 0) {
            // Create a map for quick lookup
            const taskMap = new Map(selectedTasks.map(task => [task.id, task]));
            console.log('üîç taskMap has', taskMap.size, 'tasks');
            
            // Sort by saved order
            const orderedTasks = [];
            savedOrder.forEach(orderItem => {
                console.log('üîç Checking orderItem:', orderItem.id, 'has?', taskMap.has(orderItem.id));
                if (taskMap.has(orderItem.id)) {
                    orderedTasks.push(taskMap.get(orderItem.id));
                    taskMap.delete(orderItem.id);
                }
            });
            
            // Add any remaining tasks that weren't in the saved order
            console.log('üîç Remaining tasks in map:', taskMap.size);
            taskMap.forEach(task => {
                console.log('üîç Adding remaining task:', task.content);
                orderedTasks.push(task);
            });
            
            console.log('üîç orderedTasks final:', orderedTasks.map(t => ({ id: t.id, content: t.content })));
            return orderedTasks;
        }
        
        console.log('üîç Returning selectedTasks as-is (no savedOrder)');
        return selectedTasks;
    }

    // Local task management
    getLocalTasks() {
        return JSON.parse(localStorage.getItem('localTasks') || '[]');
    }

    setLocalTasks(tasks) {
        localStorage.setItem('localTasks', JSON.stringify(tasks));
    }

    // Todoist task completion state management
    getTodoistTaskCompletionState() {
        return JSON.parse(localStorage.getItem('todoistTaskCompletionState') || '{}');
    }

    setTodoistTaskCompletionState(state) {
        localStorage.setItem('todoistTaskCompletionState', JSON.stringify(state));
    }

    updateTodoistTaskCompletionState(taskId, isCompleted) {
        const currentState = this.getTodoistTaskCompletionState();
        currentState[taskId] = isCompleted;
        this.setTodoistTaskCompletionState(currentState);
    }

    getAllTasks() {
        const localTasks = this.getLocalTasks();
        const todoistTasks = this.isAuthenticated && this.user && this.isPro ? (this.todoistTasks || []) : [];
        
        // Get local completion state for Todoist tasks
        const todoistCompletionState = this.getTodoistTaskCompletionState();
        
        // Combine and mark source (preserve existing source if present)
        const allTasks = [
            ...localTasks.map(task => ({ ...task, source: task.source || 'local' })),
            ...todoistTasks.map(task => ({ 
                ...task, 
                source: 'todoist',
                completed: todoistCompletionState[task.id] || false
            }))
        ];
        
        return allTasks;
    }

    loadAllTasks() {
        // Load local tasks
        this.localTasks = this.getLocalTasks();
        
        // Todoist integration disabled - no longer in use
        this.todoistTasks = [];
        this.todoistProjectsById = {};
    }

    showTaskMenu(modal) {
        const menu = document.createElement('div');
        menu.className = 'task-menu-dropdown';
        menu.style.cssText = `
            position: absolute;
            top: 40px;
            right: 20px;
            background: #1a1a1a;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 8px 0;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        `;

        const menuItems = [
            { text: 'Clear finished tasks', icon: 'trash', action: () => this.clearFinishedTasks() },
            { text: 'Use Template', icon: 'template', action: () => this.showTemplatesModal() },
            { text: 'Import from Todoist', icon: 'download', action: () => this.showImportModal(), locked: !this.isAuthenticated },
            { text: 'Clear act pomodoros', icon: 'check', action: () => this.clearActPomodoros() },
            { text: 'Hide tasks', icon: 'eye', action: () => this.hideTasks(), locked: !this.isAuthenticated },
            { text: 'Clear all tasks', icon: 'trash', action: () => this.clearAllTasks() }
        ];

        menuItems.forEach(item => {
            const menuItem = document.createElement('div');
            menuItem.className = 'task-menu-item';
            menuItem.style.cssText = `
                padding: 12px 16px;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 12px;
                color: ${item.locked ? 'rgba(255, 255, 255, 0.5)' : '#ffffff'};
                transition: background-color 0.2s;
            `;
            
            if (!item.locked) {
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                });
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.backgroundColor = 'transparent';
                });
            }

            const getIconSVG = (iconName) => {
                const icons = {
                    trash: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3,6 5,6 21,6"></polyline><path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path></svg>`,
                    template: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="9"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>`,
                    download: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7,10 12,15 17,10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>`,
                    check: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20,6 9,17 4,12"></polyline></svg>`,
                    eye: `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>`
                };
                return icons[iconName] || '';
            };

            menuItem.innerHTML = `
                <span>${getIconSVG(item.icon)}</span>
                <span>${item.text}</span>
                ${item.locked ? '<span style="margin-left: auto; color: rgba(255, 255, 255, 0.3);"><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><circle cx="12" cy="16" r="1"></circle><path d="M7 11V7a5 5 0 0 1 10 0v0"></path></svg></span>' : ''}
            `;

            if (!item.locked) {
                menuItem.addEventListener('click', () => {
                    item.action();
                    // Remove menu from its parent (modal, not document.body)
                    if (menu.parentNode) {
                        menu.parentNode.removeChild(menu);
                    }
                });
            }

            menu.appendChild(menuItem);
        });

        // Position menu
        const rect = modal.getBoundingClientRect();
        menu.style.top = '40px';
        menu.style.right = '20px';

        modal.style.position = 'relative';
        modal.appendChild(menu);

        // Close menu when clicking outside
        const closeMenu = (e) => {
            if (!menu.contains(e.target)) {
                // Remove menu from its parent (modal, not document.body)
                if (menu.parentNode) {
                    menu.parentNode.removeChild(menu);
                }
                document.removeEventListener('click', closeMenu);
            }
        };
        
        setTimeout(() => {
            document.addEventListener('click', closeMenu);
        }, 100);
    }

    setupDragAndDrop(modal) {
        const listEl = modal.querySelector('#todoistTasksList');
        if (!listEl) return;
        
        let draggedElement = null;

        // Remove previous drag and drop handlers to prevent duplicates
        if (listEl._dragHandlers) {
            listEl.removeEventListener('dragstart', listEl._dragHandlers.dragstart);
            listEl.removeEventListener('dragend', listEl._dragHandlers.dragend);
            listEl.removeEventListener('dragover', listEl._dragHandlers.dragover);
            listEl.removeEventListener('drop', listEl._dragHandlers.drop);
        }

        // Define handlers
        const handlers = {
            dragstart: (e) => {
                if (e.target.classList.contains('task-item')) {
                    draggedElement = e.target;
                    e.target.style.opacity = '0.5';
                    e.target.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/html', e.target.outerHTML);
                }
            },
            dragend: (e) => {
                if (e.target.classList.contains('task-item')) {
                    e.target.style.opacity = '';
                    e.target.classList.remove('dragging');
                    draggedElement = null;
                }
            },
            dragover: (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const afterElement = this.getDragAfterElement(listEl, e.clientY);
                
                if (afterElement == null) {
                    listEl.appendChild(draggedElement);
                } else {
                    listEl.insertBefore(draggedElement, afterElement);
                }
            },
            drop: (e) => {
                e.preventDefault();
                if (draggedElement) {
                    this.updateTaskOrder(listEl);
                }
            }
        };

        // Store handlers for later removal
        listEl._dragHandlers = handlers;

        // Add event listeners
        listEl.addEventListener('dragstart', handlers.dragstart);
        listEl.addEventListener('dragend', handlers.dragend);
        listEl.addEventListener('dragover', handlers.dragover);
        listEl.addEventListener('drop', handlers.drop);
    }

    getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging)')];
        
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    updateTaskOrder(listEl) {
        const taskItems = listEl.querySelectorAll('.task-item');
        const newOrder = [];
        
        taskItems.forEach((item, index) => {
            const taskId = item.dataset.taskId;
            newOrder.push({ id: taskId, order: index });
        });
        
        // Update local storage with new order
        this.saveTaskOrder(newOrder);
        
        // Rebuild task queue with new order and update current task name
        // This ensures the browser tab title reflects the new first task
        this.rebuildTaskQueue();
        this.updateCurrentTaskFromQueue();
        this.updateCurrentTaskBanner();
        
        console.log('üìã Task order updated, rebuilt queue with new order');
    }

    saveTaskOrder(newOrder) {
        localStorage.setItem('taskOrder', JSON.stringify(newOrder));
    }

    getTaskOrder() {
        return JSON.parse(localStorage.getItem('taskOrder') || '[]');
    }

    showAddTaskModal() {
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';

        const modal = document.createElement('div');
        modal.className = 'focus-stats-modal';
        modal.innerHTML = `
            <button class="close-focus-stats-x">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <div class="add-task-modal-content">
                <h3>Add Task</h3>
                <div class="task-form">
                    <div class="form-group">
                        <label>What are you working on?</label>
                        <input type="text" id="taskDescription" placeholder="Enter task description" maxlength="100">
                    </div>
                    <div class="form-group">
                        <label>Est Pomodoros</label>
                        <div class="pomodoros-control">
                            <button class="pomodoros-btn" id="decreasePomodoros">-</button>
                            <input type="number" id="pomodorosCount" value="1" min="1" max="10">
                            <button class="pomodoros-btn" id="increasePomodoros">+</button>
                        </div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="btn-secondary" id="cancelAddTask">Cancel</button>
                    <button class="btn-primary" id="saveTask">Save</button>
                </div>
            </div>
        `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        const close = () => {
            try { document.body.removeChild(overlay); } catch (_) {}
        };

        modal.querySelector('.close-focus-stats-x').addEventListener('click', close);
        modal.querySelector('#cancelAddTask').addEventListener('click', close);
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) close();
        });

        // Pomodoros controls
        const decreaseBtn = modal.querySelector('#decreasePomodoros');
        const increaseBtn = modal.querySelector('#increasePomodoros');
        const countInput = modal.querySelector('#pomodorosCount');

        decreaseBtn.addEventListener('click', () => {
            const current = parseInt(countInput.value);
            if (current > 1) countInput.value = current - 1;
        });

        increaseBtn.addEventListener('click', () => {
            const current = parseInt(countInput.value);
            if (current < 10) countInput.value = current + 1;
        });

        // Save task
        modal.querySelector('#saveTask').addEventListener('click', () => {
            const description = modal.querySelector('#taskDescription').value.trim();
            const pomodoros = parseInt(countInput.value);
            
            if (description) {
                this.addLocalTask(description, pomodoros);
                close();
                // Refresh the task list
                this.showTaskListModal();
            }
        });
    }

    addLocalTask(description, pomodoros = 1) {
        const tasks = this.getLocalTasks();
        const newTask = {
            id: 'local_' + Date.now(),
            content: description,
            pomodoros: pomodoros,
            created: new Date().toISOString(),
            completed: false,
            source: 'local'
        };
        
        tasks.push(newTask);
        this.setLocalTasks(tasks);
        // Persist planned sessions so the card progress matches the chosen value
        this.setTaskConfig(newTask.id, { sessions: pomodoros, selected: true, completedSessions: 0 });
        
        console.log('üîÑ Task created, updating banner...', { taskId: newTask.id, description });
        
        // Update the main task banner immediately
        this.updateCurrentTaskBanner();
        this.rebuildTaskQueue();
        this.updateCurrentTaskFromQueue();
        this.updateDisplay(); // Update window title immediately
        
        // Force a small delay to ensure DOM updates
        setTimeout(() => {
            console.log('üîÑ Delayed banner update...');
            this.updateCurrentTaskBanner();
            this.updateCurrentTaskFromQueue();
            this.updateDisplay(); // Update window title again
        }, 100);
        
        // üéØ Track Task Created event to Mixpanel
        if (window.mixpanelTracker) {
            window.mixpanelTracker.trackTaskCreated(description, pomodoros);
            console.log('üìä Task created event tracked to Mixpanel');
        }
    }

    showImportModal() {
        if (!this.isAuthenticated || !this.user) return;
        
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';

        const modal = document.createElement('div');
        modal.className = 'focus-stats-modal import-modal';
        modal.innerHTML = `
            <button class="close-focus-stats-x">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <div class="import-modal-content">
                <h3>Import Tasks</h3>
                <div class="search-section">
                    <div class="search-box">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="11" cy="11" r="8"/>
                            <path d="m21 21-4.35-4.35"/>
                        </svg>
                        <input type="text" id="searchTasks" placeholder="Search Tasks">
                    </div>
                </div>
                <div class="projects-section">
                    <div class="projects-list" id="projectsList">
                        <div class="loading">Loading projects...</div>
                    </div>
                </div>
                <div class="import-actions">
                    <button class="btn-secondary" id="clearSelection">Clear Selection</button>
                    <button class="btn-primary" id="importTasks" disabled>Import</button>
                </div>
            </div>
        `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        const close = () => {
            try { document.body.removeChild(overlay); } catch (_) {}
        };

        modal.querySelector('.close-focus-stats-x').addEventListener('click', close);
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) close();
        });

        // Load projects and tasks
        this.loadImportData(modal);
    }
    async loadImportData(modal) {
        const projectsList = modal.querySelector('#projectsList');
        
        try {
            // Build query params (Developer Mode + uid) just like other flows
            const viewMode = localStorage.getItem('viewMode');
            const userId = window.Clerk?.user?.id || '';
            const params = new URLSearchParams();
            if (viewMode === 'pro') {
                params.append('devMode', 'pro');
                params.append('bypass', 'true');
            }
            if (userId) params.append('uid', userId);
            const qs = params.toString() ? `?${params.toString()}` : '';

            // Load projects
            const projectsRes = await fetch(`/api/todoist-projects${qs}`);
            const projects = projectsRes.ok ? await projectsRes.json() : [];
            
            // Load tasks
            const tasksRes = await fetch(`/api/todoist-tasks${qs}`);
            const tasks = tasksRes.ok ? await tasksRes.json() : [];
            
            // Group tasks by project
            const tasksByProject = {};
            tasks.forEach(task => {
                const projectId = task.project_id;
                if (!tasksByProject[projectId]) {
                    tasksByProject[projectId] = [];
                }
                tasksByProject[projectId].push(task);
            });
            
            // Render projects
            projectsList.innerHTML = '';
            projects.forEach(project => {
                const projectTasks = tasksByProject[project.id] || [];
                if (projectTasks.length === 0) return;
                
                const projectDiv = document.createElement('div');
                projectDiv.className = 'project-group';
                projectDiv.innerHTML = `
                    <div class="project-header">
                        <h4>${project.name}</h4>
                        <span class="task-count">${projectTasks.length} tasks</span>
                    </div>
                    <div class="project-tasks">
                        ${projectTasks.map(task => `
                            <div class="import-task-item" data-task-id="${task.id}">
                                <input type="checkbox" class="task-checkbox">
                                <span class="task-content">${task.content}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                projectsList.appendChild(projectDiv);
            });
            
            // Setup selection handlers
            this.setupImportHandlers(modal);
            
        } catch (error) {
            projectsList.innerHTML = '<div class="error">Failed to load tasks</div>';
        }
    }

    setupImportHandlers(modal) {
        const checkboxes = modal.querySelectorAll('.import-task-item input[type="checkbox"]');
        const importBtn = modal.querySelector('#importTasks');
        const clearBtn = modal.querySelector('#clearSelection');
        
        const updateImportButton = () => {
            const selected = modal.querySelectorAll('.import-task-item input[type="checkbox"]:checked');
            importBtn.disabled = selected.length === 0;
            importBtn.textContent = `Import (${selected.length})`;
        };
        
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', updateImportButton);
        });
        
        clearBtn.addEventListener('click', () => {
            checkboxes.forEach(cb => cb.checked = false);
            updateImportButton();
        });
        
        importBtn.addEventListener('click', () => {
            const selected = modal.querySelectorAll('.import-task-item input[type="checkbox"]:checked');
            selected.forEach(checkbox => {
                const taskId = checkbox.closest('.import-task-item').dataset.taskId;
                // Add to local tasks
                const task = this.todoistTasks.find(t => t.id === taskId);
                if (task) {
                    this.addLocalTask(task.content, 1);
                }
            });
            
            // Close modal and refresh
            modal.closest('.focus-stats-overlay').querySelector('.close-focus-stats-x').click();
            this.showTaskListModal();
        });
    }

    // Menu action functions
    clearFinishedTasks() {
        const tasks = this.getLocalTasks();
        const activeTasks = tasks.filter(task => !task.completed);
        this.setLocalTasks(activeTasks);
        
        // Update UI immediately
        this.updateCurrentTaskBanner();
        this.rebuildTaskQueue();
        this.updateCurrentTaskFromQueue();
        
        this.showTaskListModal();
    }

    clearCompletedTasks() {
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';
        
        // Create modal
        const modal = document.createElement('div');
        modal.className = 'logout-modal';
        modal.style.cssText = 'max-width: 440px; padding: 32px; position: relative;';
        modal.innerHTML = `
            <button class="close-modal-x" id="closeClearDoneModal" style="position: absolute; top: 16px; right: 16px; background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 8px; display: flex; align-items: center; justify-content: center;">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            
            <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 8px; color: white; line-height: 1.3; text-align: left;">
                Clear Done Tasks
            </h3>
            <p style="font-size: 14px; color: rgba(255,255,255,0.7); margin-bottom: 32px; line-height: 1.5; text-align: left;">
                Are you sure you want to clear all completed tasks? This action cannot be undone.
            </p>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="logout-modal-btn logout-modal-btn-secondary" id="cancelClearDone">Cancel</button>
                <button class="logout-modal-btn logout-modal-btn-primary" id="confirmClearDone">OK</button>
            </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        const close = () => {
            try { document.body.removeChild(overlay); } catch (_) {}
        };
        
        // Close X button
        modal.querySelector('#closeClearDoneModal').addEventListener('click', close);
        
        // Cancel button
        modal.querySelector('#cancelClearDone').addEventListener('click', close);
        
        // Confirm button
        modal.querySelector('#confirmClearDone').addEventListener('click', () => {
            const tasks = this.getLocalTasks();
            const activeTasks = tasks.filter(task => !task.completed);
            this.setLocalTasks(activeTasks);
            
            // Update UI immediately
            this.updateCurrentTaskBanner();
            this.rebuildTaskQueue();
            this.updateCurrentTaskFromQueue();
            
            // Re-render Task Sidebar immediately
            this.renderTasksInSidePanel();
            
            close();
        });
        
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) close();
        });
    }

    clearAllTasks() {
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';
        
        // Create modal
        const modal = document.createElement('div');
        modal.className = 'logout-modal';
        modal.style.cssText = 'max-width: 440px; padding: 32px; position: relative;';
        modal.innerHTML = `
            <button class="close-modal-x" id="closeClearAllModal" style="position: absolute; top: 16px; right: 16px; background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 8px; display: flex; align-items: center; justify-content: center;">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            
            <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 8px; color: white; line-height: 1.3; text-align: left;">
                Clear All Tasks
            </h3>
            <p style="font-size: 14px; color: rgba(255,255,255,0.7); margin-bottom: 32px; line-height: 1.5; text-align: left;">
                Are you sure you want to clear all tasks? This action cannot be undone.
            </p>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="logout-modal-btn logout-modal-btn-secondary" id="cancelClearAll">Cancel</button>
                <button class="logout-modal-btn logout-modal-btn-primary" id="confirmClearAll">OK</button>
            </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        const close = () => {
            try { document.body.removeChild(overlay); } catch (_) {}
        };
        
        // Close X button
        modal.querySelector('#closeClearAllModal').addEventListener('click', close);
        
        // Cancel button
        modal.querySelector('#cancelClearAll').addEventListener('click', close);
        
        // Confirm button
        modal.querySelector('#confirmClearAll').addEventListener('click', () => {
            this.setLocalTasks([]);
            // Explicit clear is OK here since the user is clearing everything
            localStorage.removeItem('taskConfigs');
            
            // Update UI immediately
            this.updateCurrentTaskBanner();
            this.rebuildTaskQueue();
            this.updateCurrentTaskFromQueue();
            
            // Re-render Task Sidebar immediately
            this.renderTasksInSidePanel();
            
            // Refresh task modal if it's open
            this.loadAllTasks();
            if (typeof renderTasks === 'function') renderTasks();
            
            close();
        });
        
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) close();
        });
    }

    clearActPomodoros() {
        // Clear current session data
        this.currentTask = null;
        this.updateCurrentTaskBanner();
    }

    showTemplatesModal() {
        // TODO: Implement templates
        alert('Templates feature coming soon!');
    }

    hideTasks() {
        // TODO: Implement task hiding
        alert('Hide tasks feature coming soon!');
    }


    async fetchTodoistData() {
        // Todoist integration disabled - no longer in use
        // This function is kept for compatibility but does nothing
        this.todoistTasks = [];
        this.todoistProjectsById = {};
        return;
    }

    updateCurrentTaskBanner() {
        // Update session tasks from selected tasks
        this.updateSessionTasksFromSelected();
        
        // Update session info line to include current task if any
        // Reuse updateSessionInfo to centralize rendering
        this.updateSessionInfo();
    }

    updateCycleCounter() {
        // Only track stats for authenticated users
        if (!this.isAuthenticated) {
            return;
        }
        
        // Increment completed cycles counter without adding hours here
        // Focus time is already tracked in real-time during sessions
        // Sessions are now tracked individually when work sessions complete
        const stats = this.getFocusStats();
        stats.completedCycles = (stats.completedCycles || 0) + 1;
        
        // Save with user-specific key
        const key = this.isAuthenticated && this.user?.id 
            ? `focusStats_${this.user.id}` 
            : 'focusStats';
        localStorage.setItem(key, JSON.stringify(stats));

        // Update achievement counter display
        this.updateFocusHoursDisplay();
    }

    addBreakTime() {
        // Only track stats for authenticated users
        if (!this.isAuthenticated) {
            return;
        }
        
        const today = new Date().toDateString();
        const stats = this.getFocusStats();
        
        // Add to today's breaks (for monthly tracking)
        if (!stats.dailyBreaks) stats.dailyBreaks = {};
        stats.dailyBreaks[today] = (stats.dailyBreaks[today] || 0) + 1;
        
        // Save with user-specific key
        const key = this.isAuthenticated && this.user?.id 
            ? `focusStats_${this.user.id}` 
            : 'focusStats';
        localStorage.setItem(key, JSON.stringify(stats));
    }

    addWorkSession() {
        // Only track stats for authenticated users
        if (!this.isAuthenticated) {
            return;
        }
        
        const today = new Date().toDateString();
        const stats = this.getFocusStats();
        
        // Add to today's sessions (for monthly tracking)
        if (!stats.dailySessions) stats.dailySessions = {};
        stats.dailySessions[today] = (stats.dailySessions[today] || 0) + 1;
        
        // Save with user-specific key
        const key = this.isAuthenticated && this.user?.id 
            ? `focusStats_${this.user.id}` 
            : 'focusStats';
        localStorage.setItem(key, JSON.stringify(stats));
    }

    calculateFocusHoursInCycle() {
        // Calculate total focus time in the completed cycle
        let totalFocusSeconds = 0;
        this.cycleSections.forEach(section => {
            if (section.type === 'work') {
                totalFocusSeconds += section.duration;
            }
        });
        return totalFocusSeconds / 3600; // Convert to hours
    }

    addFocusTime(seconds) {
        // Only track stats for authenticated users
        if (!this.isAuthenticated) {
            return;
        }
        
        const hours = seconds / 3600; // Convert seconds to hours
        const now = new Date();
        const today = now.toDateString();
        const stats = this.getFocusStats();

        // Add to total focus time
        stats.totalHours = (stats.totalHours || 0) + hours;

        // Add to today's focus time
        if (!stats.daily) stats.daily = {};
        stats.daily[today] = (stats.daily[today] || 0) + hours;

        // Update consecutive days on first activity of the day
        if (stats.lastActiveDate !== today) {
            const yesterday = new Date(now);
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = yesterday.toDateString();

            if (stats.lastActiveDate === yesterdayStr) {
                stats.consecutiveDays = (stats.consecutiveDays || 0) + 1;
            } else {
                stats.consecutiveDays = 1;
            }
            stats.lastActiveDate = today;
        }

        // Save to localStorage with user-specific key
        const key = this.isAuthenticated && this.user?.id 
            ? `focusStats_${this.user.id}` 
            : 'focusStats';
        localStorage.setItem(key, JSON.stringify(stats));

        // Sync stats to Clerk (async, don't wait)
        this.syncStatsToClerk(stats.totalHours);

        // Update display in real-time
        this.updateFocusHoursDisplay();

        // If leaderboard panel or modal is open, refresh immediately
        const leaderboardPanel = document.getElementById('leaderboardSidePanel');
        if (leaderboardPanel?.classList.contains('open')) {
            this.loadLeaderboardForPanel(this.leaderboardCurrentPage || 1);
        }
        if (this.isLeaderboardModalOpen()) {
            this.loadLeaderboardForModal(this.leaderboardModalCurrentPage || 1);
        }
    }

    addTechniqueTime(seconds) {
        // Only track stats for authenticated users
        if (!this.isAuthenticated) {
            return;
        }
        
        // Track total technique time (focus + breaks) for Most Used Technique
        const hours = seconds / 3600;
        const stats = this.getFocusStats();
        const technique = this.getCurrentTechniqueName();

        if (!stats.techniqueTime) stats.techniqueTime = {};
        stats.techniqueTime[technique] = (stats.techniqueTime[technique] || 0) + hours;

        // Save to localStorage with user-specific key
        const key = this.isAuthenticated && this.user?.id 
            ? `focusStats_${this.user.id}` 
            : 'focusStats';
        localStorage.setItem(key, JSON.stringify(stats));
    }

    addFocusHours(hours) {
        // Only track stats for authenticated users
        if (!this.isAuthenticated) {
            return;
        }
        
        const today = new Date().toDateString();
        const stats = this.getFocusStats();
        
        // Add to total
        stats.totalHours = (stats.totalHours || 0) + hours;
        
        // Add to today's hours
        if (!stats.daily) stats.daily = {};
        stats.daily[today] = (stats.daily[today] || 0) + hours;
        
        // Add to today's sessions (for monthly tracking)
        if (!stats.dailySessions) stats.dailySessions = {};
        stats.dailySessions[today] = (stats.dailySessions[today] || 0) + 1;
        
        // Track technique usage
        const currentTechnique = this.getCurrentTechniqueName();
        if (!stats.techniqueUsage) stats.techniqueUsage = {};
        stats.techniqueUsage[currentTechnique] = (stats.techniqueUsage[currentTechnique] || 0) + 1;
        
        // Increment completed cycles (only when cycle is naturally completed)
        stats.completedCycles = (stats.completedCycles || 0) + 1;
        
        // Update consecutive days
        this.updateConsecutiveDays(stats);
        
        // Save back to localStorage with user-specific key
        const key = this.isAuthenticated && this.user?.id 
            ? `focusStats_${this.user.id}` 
            : 'focusStats';
        localStorage.setItem(key, JSON.stringify(stats));

        // Sync stats to Clerk (async, don't wait)
        // Do a full sync every 5 sessions to keep backup updated
        const shouldFullSync = stats.completedCycles && stats.completedCycles % 5 === 0;
        this.syncStatsToClerk(stats.totalHours, shouldFullSync);
        
        if (shouldFullSync) {
            console.log('üì§ Periodic full backup triggered (every 5 sessions)');
        }
    }

    getFocusStats() {
        try {
            // Use user-specific key if authenticated
            const key = this.isAuthenticated && this.user?.id 
                ? `focusStats_${this.user.id}` 
                : 'focusStats';
            
            const stats = JSON.parse(localStorage.getItem(key) || '{}');
            
            // Migrate old data if user is authenticated and has old stats
            if (this.isAuthenticated && this.user?.id && key !== 'focusStats') {
                const oldStats = localStorage.getItem('focusStats');
                if (oldStats && !localStorage.getItem(key)) {
                    console.log('üì¶ Migrating focus stats to user-specific storage');
                    localStorage.setItem(key, oldStats);
                    localStorage.removeItem('focusStats');
                }
            }
            
            return stats;
        } catch {
            return {};
        }
    }
    
    // Helper function to get user-specific key for focus seconds today
    getFocusSecondsTodayKey() {
        return this.isAuthenticated && this.user?.id 
            ? `focusSecondsToday_${this.user.id}` 
            : 'focusSecondsToday';
    }
    
    // Helper function to get user-specific key for focus seconds today date
    getFocusSecondsTodayDateKey() {
        return this.isAuthenticated && this.user?.id 
            ? `focusSecondsTodayDate_${this.user.id}` 
            : 'focusSecondsTodayDate';
    }
    
    // Helper function to save focus seconds today with user-specific key
    saveFocusSecondsToday(seconds) {
        try {
            const secondsKey = this.getFocusSecondsTodayKey();
            const dateKey = this.getFocusSecondsTodayDateKey();
            localStorage.setItem(secondsKey, String(seconds));
            localStorage.setItem(dateKey, new Date().toDateString());
        } catch (_) {}
    }
    
    // Helper function to load focus seconds today with user-specific key
    loadFocusSecondsToday() {
        try {
            const secondsKey = this.getFocusSecondsTodayKey();
            const dateKey = this.getFocusSecondsTodayDateKey();
            const savedFocusDate = localStorage.getItem(dateKey);
            const savedFocusSecs = parseInt(localStorage.getItem(secondsKey) || '0', 10);
            const todayStr = new Date().toDateString();
            
            if (savedFocusDate === todayStr) {
                return Math.max(0, savedFocusSecs);
            } else {
                // New day, reset
                this.saveFocusSecondsToday(0);
                return 0;
            }
        } catch (_) {
            return 0;
        }
    }

    // Report helper functions
    calculateCurrentStreak(stats) {
        return this.streakData?.currentStreak || 0;
    }

    calculateLongestStreak(stats) {
        return this.streakData?.longestStreak || 0;
    }

    // Calculate stats for current month only
    getMonthlyStats(stats) {
        const now = new Date();
        const currentMonth = now.getMonth();
        const currentYear = now.getFullYear();
        
        let monthlyHours = 0;
        let monthlySessions = 0;
        let monthlyBreaks = 0;
        let isAllTime = false; // Flag to indicate if we're showing all-time instead of monthly
        
        // Check if we have any daily data at all
        const hasDailyData = stats.daily && Object.keys(stats.daily).length > 0;
        
        // Sum hours from daily data for current month
        if (hasDailyData) {
            Object.entries(stats.daily).forEach(([dateStr, hours]) => {
                try {
                    // Parse date string (format: "Mon Jan 01 2024" from toDateString())
                    const date = new Date(dateStr);
                    // Check if date is valid and matches current month/year
                    if (!isNaN(date.getTime()) && date.getMonth() === currentMonth && date.getFullYear() === currentYear) {
                        monthlyHours += hours || 0;
                    }
                } catch (e) {
                    console.warn('Error parsing date in getMonthlyStats:', dateStr, e);
                }
            });
        }
        
        // For sessions, we need to track monthly sessions separately
        if (stats.dailySessions) {
            Object.entries(stats.dailySessions).forEach(([dateStr, sessions]) => {
                try {
                    // Parse date string (format: "Mon Jan 01 2024" from toDateString())
                    const date = new Date(dateStr);
                    // Check if date is valid and matches current month/year
                    if (!isNaN(date.getTime()) && date.getMonth() === currentMonth && date.getFullYear() === currentYear) {
                        monthlySessions += sessions || 0;
                    }
                } catch (e) {
                    console.warn('Error parsing date in getMonthlyStats:', dateStr, e);
                }
            });
        }
        
        // For breaks, track monthly breaks separately
        if (stats.dailyBreaks) {
            Object.entries(stats.dailyBreaks).forEach(([dateStr, breaks]) => {
                try {
                    // Parse date string (format: "Mon Jan 01 2024" from toDateString())
                    const date = new Date(dateStr);
                    // Check if date is valid and matches current month/year
                    if (!isNaN(date.getTime()) && date.getMonth() === currentMonth && date.getFullYear() === currentYear) {
                        monthlyBreaks += breaks || 0;
                    }
                } catch (e) {
                    console.warn('Error parsing date in getMonthlyStats:', dateStr, e);
                }
            });
        }
        
        return {
            hours: monthlyHours,
            sessions: monthlySessions,
            breaks: monthlyBreaks
        };
    }

    getLastNDaysData(stats, n) {
        const days = [];
        const today = new Date();
        
        for (let i = n - 1; i >= 0; i--) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            const dateStr = date.toDateString();
            const hours = stats.daily?.[dateStr] || 0;
            
            const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
            days.push({
                date: dateStr,
                label: dayName,
                hours: hours
            });
        }
        
        return days;
    }

    getLastNWeeksData(stats, n) {
        const weeks = [];
        const today = new Date();
        
        for (let i = n - 1; i >= 0; i--) {
            const weekStart = new Date(today);
            weekStart.setDate(today.getDate() - (today.getDay() + i * 7));
            weekStart.setHours(0, 0, 0, 0);
            
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 6);
            
            let weekHours = 0;
            for (let d = new Date(weekStart); d <= weekEnd; d.setDate(d.getDate() + 1)) {
                const dateStr = d.toDateString();
                weekHours += stats.daily?.[dateStr] || 0;
            }
            
            const label = `${weekStart.getMonth() + 1}/${weekStart.getDate()}`;
            weeks.push({
                start: weekStart.toDateString(),
                end: weekEnd.toDateString(),
                label: label,
                hours: weekHours
            });
        }
        
        return weeks;
    }

    getLastNMonthsData(stats, n) {
        const months = [];
        const today = new Date();
        
        for (let i = n - 1; i >= 0; i--) {
            const monthDate = new Date(today.getFullYear(), today.getMonth() - i, 1);
            const monthStart = new Date(monthDate.getFullYear(), monthDate.getMonth(), 1);
            const monthEnd = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0);
            
            let monthHours = 0;
            for (let d = new Date(monthStart); d <= monthEnd; d.setDate(d.getDate() + 1)) {
                const dateStr = d.toDateString();
                monthHours += stats.daily?.[dateStr] || 0;
            }
            
            const label = monthDate.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
            months.push({
                start: monthStart.toDateString(),
                end: monthEnd.toDateString(),
                label: label,
                hours: monthHours
            });
        }
        
        return months;
    }

    generateHeatmapData(stats, days) {
        const heatmapData = [];
        const today = new Date();
        
        for (let i = days - 1; i >= 0; i--) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            const dateStr = date.toDateString();
            const hours = stats.daily?.[dateStr] || 0;
            
            heatmapData.push({
                date: dateStr,
                hours: hours
            });
        }
        
        return heatmapData;
    }

    getHeatmapColor(intensity) {
        // GitHub-style heatmap colors
        if (intensity === 0) return '#161b22';
        if (intensity < 0.25) return '#0e4429';
        if (intensity < 0.5) return '#006d32';
        if (intensity < 0.75) return '#26a641';
        return '#39d353';
    }

    calculateInsights(stats, last30Days) {
        const insights = [];
        
        // Find best day
        const bestDay = last30Days.reduce((best, day) => day.hours > best.hours ? day : best, { hours: 0, label: 'None' });
        if (bestDay.hours > 0) {
            insights.push({
                title: `Your best day was ${bestDay.label}`,
                description: `You focused for ${bestDay.hours.toFixed(1)} hours on ${bestDay.date}`
            });
        }
        
        // Calculate average
        const totalHours = last30Days.reduce((sum, day) => sum + day.hours, 0);
        const avgHours = totalHours / last30Days.length;
        if (avgHours > 0) {
            insights.push({
                title: `Daily average: ${avgHours.toFixed(1)} hours`,
                description: `You've been consistent with your focus time`
            });
        }
        
        // Find improvement
        const firstHalf = last30Days.slice(0, 15).reduce((sum, day) => sum + day.hours, 0) / 15;
        const secondHalf = last30Days.slice(15).reduce((sum, day) => sum + day.hours, 0) / 15;
        if (secondHalf > firstHalf * 1.1) {
            const improvement = ((secondHalf - firstHalf) / firstHalf * 100).toFixed(0);
            insights.push({
                title: `You've improved ${improvement}%!`,
                description: `Your focus time has increased in the last 15 days`
            });
        }
        
        // Find most active days
        const dayCounts = {};
        last30Days.forEach(day => {
            const dayName = new Date(day.date).toLocaleDateString('en-US', { weekday: 'long' });
            if (day.hours > 0) {
                dayCounts[dayName] = (dayCounts[dayName] || 0) + 1;
            }
        });
        const mostActiveDay = Object.entries(dayCounts).reduce((best, [day, count]) => 
            count > best.count ? { day, count } : best, { day: 'None', count: 0 }
        );
        if (mostActiveDay.count > 0) {
            insights.push({
                title: `${mostActiveDay.day} is your most productive day`,
                description: `You've been active ${mostActiveDay.count} times on ${mostActiveDay.day}s`
            });
        }
        
        return insights;
    }

    renderComparison(stats) {
        const today = new Date();
        const currentMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        
        const currentMonthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 0);
        const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0);
        
        let currentMonthHours = 0;
        let lastMonthHours = 0;
        
        for (let d = new Date(currentMonth); d <= currentMonthEnd; d.setDate(d.getDate() + 1)) {
            const dateStr = d.toDateString();
            currentMonthHours += stats.daily?.[dateStr] || 0;
        }
        
        for (let d = new Date(lastMonth); d <= lastMonthEnd; d.setDate(d.getDate() + 1)) {
            const dateStr = d.toDateString();
            lastMonthHours += stats.daily?.[dateStr] || 0;
        }
        
        const change = currentMonthHours - lastMonthHours;
        const changePercent = lastMonthHours > 0 ? ((change / lastMonthHours) * 100).toFixed(0) : 0;
        const isPositive = change >= 0;
        
        return `
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 16px;">
                <div style="flex: 1; text-align: center;">
                    <div style="font-size: 24px; font-weight: 700; color: #fff; margin-bottom: 4px;">${currentMonthHours.toFixed(1)}h</div>
                    <div style="font-size: 12px; color: #a3a3a3;">This Month</div>
                </div>
                <div style="flex: 1; text-align: center;">
                    <div style="font-size: 24px; font-weight: 700; color: #fff; margin-bottom: 4px;">${lastMonthHours.toFixed(1)}h</div>
                    <div style="font-size: 12px; color: #a3a3a3;">Last Month</div>
                </div>
                <div style="flex: 1; text-align: center;">
                    <div style="font-size: 24px; font-weight: 700; color: ${isPositive ? '#39d353' : '#ff4444'}; margin-bottom: 4px;">
                        ${isPositive ? '+' : ''}${change.toFixed(1)}h
                    </div>
                    <div style="font-size: 12px; color: #a3a3a3;">${isPositive ? '+' : ''}${changePercent}%</div>
                </div>
            </div>
        `;
    }

    // Day streak functions
    loadStreakData() {
        try {
            const data = JSON.parse(localStorage.getItem('streakData') || '{}');
            return {
                currentStreak: data.currentStreak || 0,
                lastActiveDate: data.lastActiveDate || null,
                ...data
            };
        } catch {
            return {
                currentStreak: 0,
                lastActiveDate: null
            };
        }
    }

    checkAndResetStreakIfNeeded() {
        // Only check for authenticated users
        if (!this.isAuthenticated) {
            return;
        }

        const today = new Date().toDateString();
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = yesterday.toDateString();

        // If we have a last active date, check if streak should be reset
        if (this.streakData.lastActiveDate) {
            // If last active date is not today and not yesterday, reset streak
            if (this.streakData.lastActiveDate !== today && this.streakData.lastActiveDate !== yesterdayStr) {
                console.log(`üîÑ Streak reset: Last active was ${this.streakData.lastActiveDate}, today is ${today}`);
                // Only reset currentStreak, preserve longestStreak as personal record
                this.streakData.currentStreak = 0;
                this.streakData.lastActiveDate = null;
                this.saveStreakData();
                this.updateStreakDisplay();
            }
        }
    }

    saveStreakData() {
        try {
            localStorage.setItem('streakData', JSON.stringify(this.streakData));
        } catch (error) {
            console.error('Error saving streak data:', error);
        }
    }

    updateStreak() {
        // Only track stats for authenticated users
        if (!this.isAuthenticated) {
            return;
        }
        
        const today = new Date().toDateString();
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = yesterday.toDateString();

        // Check if we already completed focus today
        if (this.hasCompletedFocusToday) {
            return; // Already counted today
        }

        // Mark that we completed focus today
        this.hasCompletedFocusToday = true;

        // If this is the first time today, update streak
        if (this.streakData.lastActiveDate !== today) {
            if (this.streakData.lastActiveDate === yesterdayStr) {
                // Consecutive day - increment streak
                this.streakData.currentStreak += 1;
            } else if (this.streakData.lastActiveDate === null) {
                // First time ever
                this.streakData.currentStreak = 1;
            } else {
                // Streak broken - reset to 1
                this.streakData.currentStreak = 1;
            }
            
            // Update longest streak if current streak is higher
            if (this.streakData.currentStreak > (this.streakData.longestStreak || 0)) {
                this.streakData.longestStreak = this.streakData.currentStreak;
                console.log(`üèÜ New longest streak record: ${this.streakData.longestStreak} days!`);
            }
            
            this.streakData.lastActiveDate = today;
            this.saveStreakData();
            this.updateStreakDisplay();
        }
    }

    updateStreakDisplay() {
        const streakDaysElement = document.getElementById('streakDays');
        if (streakDaysElement) {
            // In guest mode, always show 0. Only show real streak for authenticated users
            if (this.isAuthenticated) {
            streakDaysElement.textContent = this.streakData.currentStreak;
            } else {
                streakDaysElement.textContent = '0';
            }
        }
    }

    showStreakInfo() {
        // If user is not authenticated, show guest modal
        if (!this.isAuthenticated) {
            this.showGuestStreakModal();
            return;
        }
        
        // Check if report panel is currently open
        const reportPanel = document.getElementById('reportSidePanel');
        const isOpen = reportPanel && reportPanel.classList.contains('open');
        
        console.log('üîç Report panel check:', {
            panelExists: !!reportPanel,
            isOpen: isOpen,
            classList: reportPanel ? Array.from(reportPanel.classList) : []
        });
        
        if (isOpen) {
            console.log('üîí Closing report panel');
            // Close by clicking nav item
            const reportNavItem = document.querySelector('.nav-item[data-section="report"]');
            if (reportNavItem && reportNavItem.classList.contains('active')) {
                reportNavItem.click();
            }
        } else {
            console.log('üîì Opening report panel');
            // Open by clicking nav item
            const reportNavItem = document.querySelector('.nav-item[data-section="report"]');
            if (reportNavItem) {
                reportNavItem.click();
            }
        }
    }

    showGuestStreakModal() {
        // Redirect to the full guest report teaser with 4 graphs
        this.showGuestFocusReportTeaser();
    }

    showGuestFocusReportTeaser() {
        // For guests, show 0 values since stats are not saved
        // Stats are only tracked for authenticated users
        const totalHours = 0;
        const completedCycles = 0;
        
        // Format hours
        const hours = Math.floor(totalHours);
        const minutes = Math.round((totalHours - hours) * 60);
        const timeString = `${hours}h ${minutes}m`;
        
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'upgrade-modal-overlay';
        
        const modal = document.createElement('div');
        modal.className = 'upgrade-modal';
        
        modal.innerHTML = `
            <button class="close-upgrade-x" id="closeGuestReportX">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <div class="upgrade-content">
                <h3>Your Focus Progress</h3>
                <p style="color: #a3a3a3; margin-bottom: 24px;">Here's what you've accomplished so far</p>
                
                <div style="background: var(--onyx-dark, #064e3b); border-radius: 12px; padding: 20px; margin: 24px 0; display: flex; align-items: center; gap: 16px;">
                    <div style="flex-shrink: 0;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 8h1a4 4 0 1 1 0 8h-1"/>
                            <path d="M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4Z"/>
                            <line x1="6" x2="6" y1="2" y2="4"/>
                            <line x1="10" x2="10" y1="2" y2="4"/>
                            <line x1="14" x2="14" y1="2" y2="4"/>
                        </svg>
                    </div>
                    <div style="flex: 1; text-align: left;">
                        <div style="font-weight: 600; color: #fff; margin-bottom: 4px; font-size: 16px;">Save your progress</div>
                        <div style="font-size: 14px; color: white; opacity: 0.95;">Sync your tasks and stats across all your devices</div>
                    </div>
                    <button id="guestReportSignupBtn" style="background: white; color: var(--onyx-dark, #064e3b); border: none; padding: 8px 16px; border-radius: 6px; font-weight: 600; cursor: pointer; white-space: nowrap; font-size: 13px;">Sign up</button>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 16px 0;">
                    <!-- Total Focus Hours -->
                    <div style="background: #2a2a2a; border-radius: 12px; padding: 24px; text-align: center; filter: blur(2px); opacity: 0.6;">
                        <div style="color: #a3a3a3; margin-bottom: 12px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"/>
                                <polyline points="12 6 12 12 16 14"/>
                            </svg>
                        </div>
                        <div style="font-size: 28px; font-weight: 700; color: #fff; margin-bottom: 4px;">${timeString}</div>
                        <div style="font-size: 14px; color: #a3a3a3;">Focus Time</div>
                    </div>
                    
                    <!-- Completed Cycles -->
                    <div style="background: #2a2a2a; border-radius: 12px; padding: 24px; text-align: center; filter: blur(2px); opacity: 0.6;">
                        <div style="color: #a3a3a3; margin-bottom: 12px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                                <polyline points="22 4 12 14.01 9 11.01"/>
                            </svg>
                        </div>
                        <div style="font-size: 36px; font-weight: 700; color: #fff; margin-bottom: 4px;">${completedCycles}</div>
                        <div style="font-size: 14px; color: #a3a3a3;">Cycles Done</div>
                    </div>
                    
                    <!-- Day Streak - BLURRED -->
                    <div style="background: #2a2a2a; border-radius: 12px; padding: 24px; text-align: center; filter: blur(2px); opacity: 0.6;">
                        <div style="color: #a3a3a3; margin-bottom: 12px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"/>
                            </svg>
                        </div>
                        <div style="font-size: 36px; font-weight: 700; color: #fff; margin-bottom: 4px;">0</div>
                        <div style="font-size: 14px; color: #a3a3a3;">Day Streak</div>
                    </div>
                    
                    <!-- Longest Streak - BLURRED -->
                    <div style="background: #2a2a2a; border-radius: 12px; padding: 24px; text-align: center; filter: blur(2px); opacity: 0.6;">
                        <div style="color: #a3a3a3; margin-bottom: 12px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                        </div>
                        <div style="font-size: 36px; font-weight: 700; color: #fff; margin-bottom: 4px;">0</div>
                        <div style="font-size: 14px; color: #a3a3a3;">Longest Streak</div>
                    </div>
                </div>
            </div>
        `;
        
        modalOverlay.appendChild(modal);
        document.body.appendChild(modalOverlay);
        
        // Event listeners
        document.getElementById('guestReportSignupBtn').addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
            window.location.href = '/pricing';
        });
        
        document.getElementById('closeGuestReportX').addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
        });
        
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                document.body.removeChild(modalOverlay);
            }
        });
    }

    showStatisticsModal() {
        // Get user statistics
        const stats = this.getFocusStats();
        const currentStreak = this.streakData.currentStreak || 0;
        const longestStreak = this.streakData.longestStreak || currentStreak;
        const totalHours = stats.totalHours || 0;
        const completedCycles = stats.completedCycles || 0;
        
        // Format total hours
        const hours = Math.floor(totalHours);
        const minutes = Math.round((totalHours - hours) * 60);
        const timeString = `${hours}h ${minutes}m`;
        
        // Create statistics modal using upgrade modal styling
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'upgrade-modal-overlay';
        
        const modal = document.createElement('div');
        modal.className = 'upgrade-modal';
        
        modal.innerHTML = `
            <button class="close-upgrade-x" id="closeReportX">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <div class="upgrade-content">
                <h3>Report</h3>
                <p>Your productivity summary</p>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 16px 0;">
                    <!-- Day Streak -->
                    <div style="background: #2a2a2a; border-radius: 12px; padding: 24px; text-align: center;">
                        <div style="color: #a3a3a3; margin-bottom: 12px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"/>
                            </svg>
                        </div>
                        <div style="font-size: 36px; font-weight: 700; color: #fff; margin-bottom: 4px;">${currentStreak}</div>
                        <div style="font-size: 14px; color: #a3a3a3;">Day Streak</div>
                    </div>
                    
                    <!-- Longest Streak -->
                    <div style="background: #2a2a2a; border-radius: 12px; padding: 24px; text-align: center;">
                        <div style="color: #a3a3a3; margin-bottom: 12px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                            </svg>
                        </div>
                        <div style="font-size: 36px; font-weight: 700; color: #fff; margin-bottom: 4px;">${longestStreak}</div>
                        <div style="font-size: 14px; color: #a3a3a3;">Longest Streak</div>
                    </div>
                </div>
                
                <!-- Total Focus Hours - Full width below -->
                <div style="margin: 16px 0;">
                    <div style="background: #2a2a2a; border-radius: 12px; padding: 24px; text-align: center;">
                        <div style="color: #a3a3a3; margin-bottom: 12px;">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"/>
                                <polyline points="12 6 12 12 16 14"/>
                            </svg>
                        </div>
                        <div style="font-size: 28px; font-weight: 700; color: #fff; margin-bottom: 4px;">${timeString}</div>
                        <div style="font-size: 14px; color: #a3a3a3;">Total Focus Hours</div>
                    </div>
                </div>
            </div>
        `;
        
        modalOverlay.appendChild(modal);
        document.body.appendChild(modalOverlay);
        
        // Add event listeners
        document.getElementById('closeReportX').addEventListener('click', () => {
            document.body.removeChild(modalOverlay);
        });
        
        // Close on overlay click
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) {
                document.body.removeChild(modalOverlay);
            }
        });
    }

    async syncStatsToClerk(totalHours, fullSync = false) {
        // Only sync if authenticated
        if (!this.isAuthenticated || !this.user?.id) {
            return;
        }

        try {
            // Build sync payload
            const payload = { totalHours };
            
            // For full sync, include all user data for backup
            if (fullSync) {
                console.log('üì§ Performing full data sync to Clerk...');
                
                // Get full focus stats
                const focusStats = this.getFocusStats();
                if (focusStats && Object.keys(focusStats).length > 0) {
                    payload.focusStats = focusStats;
                }
                
                // Get custom techniques
                try {
                    const customTechniques = JSON.parse(localStorage.getItem('customTechniques') || '[]');
                    if (customTechniques.length > 0) {
                        payload.customTechniques = customTechniques;
                    }
                } catch (_) {}
                
                // Get custom cassettes (including private ones)
                try {
                    const customCassettes = JSON.parse(localStorage.getItem('customCassettes') || '[]');
                    if (customCassettes.length > 0) {
                        payload.customCassettes = customCassettes;
                    }
                } catch (_) {}
                
                // Get streak data
                if (this.streakData) {
                    payload.streakData = this.streakData;
                }
            }
            
            const response = await fetch('/api/sync-stats', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-clerk-userid': this.user.id
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                console.error('Failed to sync stats to Clerk');
            } else if (fullSync) {
                const result = await response.json();
                console.log('‚úÖ Full sync completed:', result);
            }
        } catch (error) {
            console.error('Error syncing stats to Clerk:', error);
        }
    }
    
    // Perform a full backup of user data to Clerk
    async performFullDataBackup() {
        if (!this.isAuthenticated || !this.user?.id) {
            console.log('‚ùå Cannot backup: Not authenticated');
            return false;
        }
        
        try {
            const stats = this.getFocusStats();
            const totalHours = stats?.totalHours || 0;
            await this.syncStatsToClerk(totalHours, true);
            console.log('‚úÖ Full data backup completed');
            return true;
        } catch (error) {
            console.error('‚ùå Full data backup failed:', error);
            return false;
        }
    }
    
    async restoreStatsFromClerk() {
        // Only restore if authenticated
        if (!this.isAuthenticated || !this.user?.id) {
            console.log('‚ùå Cannot restore stats: Not authenticated');
            return;
        }
        
        try {
            console.log('üîÑ Checking if data needs to be restored from server...');
            console.log('üë§ User details:', {
                userId: this.user.id,
                email: this.user.emailAddresses?.[0]?.emailAddress,
                createdAt: this.user.createdAt
            });
            
            // Check if user has data in localStorage with user-specific key
            const localStats = this.getFocusStats();
            const hasLocalData = localStats && localStats.totalHours && localStats.totalHours > 0;
            
            // Get all backup data from Clerk publicMetadata
            const serverTotalHours = this.user.publicMetadata?.totalFocusHours || 0;
            const serverStatsLastUpdated = this.user.publicMetadata?.statsLastUpdated;
            const focusStatsBackup = this.user.publicMetadata?.focusStatsBackup;
            const serverCustomTechniques = this.user.publicMetadata?.customTechniques;
            const serverPrivateCassettes = this.user.publicMetadata?.privateCassettes;
            const serverPublicCassettes = this.user.publicMetadata?.publicCassettes;
            const serverStreakData = this.user.publicMetadata?.streakData;
            
            // Check if there's any old generic data that shouldn't be migrated
            const oldGenericStats = localStorage.getItem('focusStats');
            if (oldGenericStats) {
                console.warn('‚ö†Ô∏è Found old generic focusStats in localStorage:', oldGenericStats.substring(0, 100));
            }
            
            console.log('üìä Data comparison:', {
                userId: this.user.id,
                userEmail: this.user.emailAddresses?.[0]?.emailAddress,
                localTotalHours: localStats.totalHours || 0,
                localHasData: hasLocalData,
                serverTotalHours: serverTotalHours,
                serverLastUpdated: serverStatsLastUpdated,
                hasStatsBackup: !!focusStatsBackup,
                hasCustomTechniques: !!(serverCustomTechniques && serverCustomTechniques.length > 0),
                hasPrivateCassettes: !!(serverPrivateCassettes && serverPrivateCassettes.length > 0),
                hasPublicCassettes: !!(serverPublicCassettes && serverPublicCassettes.length > 0),
                hasStreakData: !!serverStreakData,
                hasOldGenericData: !!oldGenericStats
            });
            
            // Check if user account is new (created recently, within last hour)
            const accountAge = this.user.createdAt ? Date.now() - this.user.createdAt : Infinity;
            const isNewAccount = accountAge < (60 * 60 * 1000); // Less than 1 hour old
            
            // Don't auto-restore for brand new accounts - they should start fresh
            if (isNewAccount && serverTotalHours > 0) {
                console.warn('‚ö†Ô∏è NEW ACCOUNT detected but has server data:', {
                    accountAge: Math.round(accountAge / 1000 / 60) + ' minutes',
                    serverHours: serverTotalHours,
                    email: this.user.emailAddresses?.[0]?.emailAddress
                });
                console.warn('üö´ Skipping auto-restore for new account. User may need manual reset if this is wrong data.');
                return false;
            }
            
            let restoredAnything = false;
            
            // Restore focus stats if server has more data
            if (serverTotalHours > 0 && (!hasLocalData || (localStats.totalHours || 0) < serverTotalHours)) {
                console.log('‚úÖ Restoring focus stats from server to localStorage');
                
                // Start with local stats as base
                let restoredStats = { ...localStats };
                
                // If we have a full backup, use that
                if (focusStatsBackup) {
                    console.log('üì¶ Found full stats backup, restoring detailed data...');
                    restoredStats = {
                        ...restoredStats,
                        totalHours: focusStatsBackup.totalHours || serverTotalHours,
                        completedCycles: focusStatsBackup.completedCycles || restoredStats.completedCycles,
                        daily: focusStatsBackup.daily || restoredStats.daily || {},
                        dailySessions: focusStatsBackup.dailySessions || restoredStats.dailySessions || {},
                        dailyBreaks: focusStatsBackup.dailyBreaks || restoredStats.dailyBreaks || {}
                    };
                } else {
                    // Only totalHours available
                    restoredStats.totalHours = serverTotalHours;
                }
                
                restoredStats.lastRestored = new Date().toISOString();
                restoredStats.restoredFrom = 'clerk_publicMetadata';
                restoredStats.restoredForUser = this.user.id;
                
                // Save to user-specific localStorage key
                const key = `focusStats_${this.user.id}`;
                localStorage.setItem(key, JSON.stringify(restoredStats));
                
                console.log('‚úÖ Focus stats restored:', {
                    totalHours: restoredStats.totalHours,
                    hasDailyData: Object.keys(restoredStats.daily || {}).length > 0,
                    key: key
                });
                
                restoredAnything = true;
            }
            
            // Restore custom techniques if server has them and local is empty
            const localTechniques = JSON.parse(localStorage.getItem('customTechniques') || '[]');
            if (serverCustomTechniques && serverCustomTechniques.length > 0 && localTechniques.length === 0) {
                console.log('üì¶ Restoring custom techniques from server...');
                localStorage.setItem('customTechniques', JSON.stringify(serverCustomTechniques));
                console.log(`‚úÖ Restored ${serverCustomTechniques.length} custom techniques`);
                restoredAnything = true;
                
                // Reload custom techniques UI
                try { this.loadCustomTechniques(); } catch (_) {}
            }
            
            // Restore cassettes if server has them and local is empty
            const localCassettes = JSON.parse(localStorage.getItem('customCassettes') || '[]');
            if (localCassettes.length === 0) {
                const cassettesToRestore = [];
                
                // Add private cassettes from backup
                if (serverPrivateCassettes && serverPrivateCassettes.length > 0) {
                    cassettesToRestore.push(...serverPrivateCassettes);
                }
                
                // Add public cassettes from publicCassettes
                if (serverPublicCassettes && serverPublicCassettes.length > 0) {
                    cassettesToRestore.push(...serverPublicCassettes);
                }
                
                if (cassettesToRestore.length > 0) {
                    console.log('üì¶ Restoring cassettes from server...');
                    localStorage.setItem('customCassettes', JSON.stringify(cassettesToRestore));
                    console.log(`‚úÖ Restored ${cassettesToRestore.length} cassettes`);
                    restoredAnything = true;
                    
                    // Reload cassettes UI
                    try { this.loadCustomCassettes(); } catch (_) {}
                }
            }
            
            // Restore streak data if server has it
            if (serverStreakData && (!this.streakData || !this.streakData.currentStreak)) {
                console.log('üì¶ Restoring streak data from server...');
                this.streakData = serverStreakData;
                console.log('‚úÖ Streak data restored:', serverStreakData);
                restoredAnything = true;
            }
            
            // If local data is more recent, do a full sync to server
            if (hasLocalData && (localStats.totalHours || 0) > serverTotalHours) {
                console.log('üì§ Local data is more recent, performing full sync to server...');
                await this.syncStatsToClerk(localStats.totalHours, true);
            }
            
            // Update UI if we restored anything
            if (restoredAnything) {
                this.updateFocusHoursDisplay();
                console.log('üéâ Data restoration completed!');
            } else {
                console.log('‚úÖ Data is in sync (no restoration needed)');
            }
            
            return restoredAnything;
        } catch (error) {
            console.error('‚ùå Error restoring data from Clerk:', error);
            return false;
        }
    }

    async loadLeaderboard(modalElement) {
        // Only load if authenticated
        if (!this.isAuthenticated || !this.user?.id) {
            return;
        }

        try {
            const response = await fetch('/api/leaderboard', {
                method: 'GET',
                headers: {
                    'x-clerk-userid': this.user.id
                }
            });

            if (!response.ok) {
                throw new Error('Failed to fetch leaderboard');
            }

            const data = await response.json();
            if (data.success && data.leaderboard) {
                this.displayLeaderboard(modalElement, data.leaderboard, data.currentUserPosition);
            }
        } catch (error) {
            console.error('Error loading leaderboard:', error);
        }
    }

    async loadLeaderboardForPanel(page = 1) {
        // Only load if authenticated
        if (!this.isAuthenticated || !this.user?.id) {
            const leaderboardContent = document.getElementById('leaderboardContent');
            if (leaderboardContent) {
                leaderboardContent.innerHTML = `
                    <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                        Please log in to view the leaderboard.
                    </div>
                `;
            }
            return;
        }

        const leaderboardContent = document.getElementById('leaderboardContent');
        if (!leaderboardContent) return;

        this.leaderboardCurrentPage = page;

        // Get current user's total hours
        const stats = this.getFocusStats();
        const currentTotalHours = stats.totalHours || 0;

        // Check if we have cached leaderboard data for this specific page
        const cachedData = this.leaderboardCache[page];
        const cachedTotalHours = this.leaderboardCachedAtHours || 0;
        const cacheAgeMs = cachedData?.cachedAt ? Date.now() - cachedData.cachedAt : Number.POSITIVE_INFINITY;
        const isCacheStale = cacheAgeMs > this.LEADERBOARD_CACHE_TTL_MS;

        // Calculate if user has earned at least 1 minute (0.0167 hours) since last cache
        const hoursEarnedSinceCache = currentTotalHours - cachedTotalHours;
        const needsRefresh = hoursEarnedSinceCache >= (1 / 60); // 1 minute = 1/60 hours

        // If user earned 1+ minute, clear ALL page caches (position may have changed)
        if (needsRefresh) {
            console.log(`üóëÔ∏è Clearing all leaderboard page caches (earned ${(hoursEarnedSinceCache * 60).toFixed(1)} min)`);
            this.leaderboardCache = {};
            localStorage.removeItem('leaderboardCache');
            localStorage.removeItem('leaderboardCachedAtHours');
        }

        // If we have cache for this page and user hasn't earned 1+ minute, show cached data
        if (cachedData) {
            console.log(`üì¶ Using cached leaderboard page ${page}`);
            console.log(`   Current: ${currentTotalHours.toFixed(2)}h, Cached at: ${cachedTotalHours.toFixed(2)}h, Diff: ${(hoursEarnedSinceCache * 60).toFixed(1)} min`);
            
            this.displayLeaderboardInPanel(
                leaderboardContent,
                cachedData.leaderboard,
                cachedData.currentUserPosition,
                cachedData.pagination,
                cachedData.rankMeta
            );

            if (!needsRefresh && !isCacheStale) {
                return;
            }
        }

        console.log(`üîÑ Fetching fresh leaderboard page ${page} from server...`);
        if (needsRefresh) {
            console.log(`   Reason: Earned ${(hoursEarnedSinceCache * 60).toFixed(1)} minutes since last load`);
        } else if (!cachedData) {
            console.log(`   Reason: First time loading page ${page}`);
        }

        // Sync local stats to Clerk if they exist (one-time sync for existing users)
        // Only sync on page 1 to avoid unnecessary calls
        if (page === 1) {
            if (stats.totalHours && stats.totalHours > 0) {
                // Sync stats to ensure they're in Clerk (async, don't wait)
                this.syncStatsToClerk(stats.totalHours);
            }
        }

        try {
            const response = await fetch(`/api/leaderboard?page=${page}&limit=100`, {
                method: 'GET',
                headers: {
                    'x-clerk-userid': this.user.id
                }
            });

            if (!response.ok) {
                throw new Error('Failed to fetch leaderboard');
            }

            const data = await response.json();
            if (data.success && data.leaderboard) {
                // Log debug info if available
                if (data.debug) {
                    console.log('Leaderboard Debug:', data.debug);
                }

                // Cache the leaderboard data for this page
                this.leaderboardCache[page] = {
                    leaderboard: data.leaderboard,
                    currentUserPosition: data.currentUserPosition,
                    pagination: {
                        page: data.page,
                        totalPages: data.totalPages,
                        totalUsers: data.totalUsers,
                        hasMore: data.hasMore
                    },
                    rankMeta: {
                        nextRankGapMinutes: data.nextRankGapMinutes,
                        nextRankTargetRank: data.nextRankTargetRank
                    },
                    cachedAt: Date.now()
                };
                
                // Update cached hours timestamp (shared across all pages)
                this.leaderboardCachedAtHours = currentTotalHours;
                
                // Persist cache to localStorage (survives page reloads and browser close)
                try {
                    localStorage.setItem('leaderboardCache', JSON.stringify(this.leaderboardCache));
                    localStorage.setItem('leaderboardCachedAtHours', currentTotalHours.toString());
                    localStorage.setItem('leaderboardCacheVersion', this.LEADERBOARD_CACHE_VERSION);
                } catch (err) {
                    console.error('Failed to save leaderboard cache to localStorage:', err);
                }
                
                console.log(`‚úÖ Leaderboard page ${page} cached at ${currentTotalHours.toFixed(2)}h`);

                this.displayLeaderboardInPanel(
                    leaderboardContent,
                    data.leaderboard,
                    data.currentUserPosition,
                    {
                        page: data.page,
                        totalPages: data.totalPages,
                        totalUsers: data.totalUsers,
                        hasMore: data.hasMore
                    },
                    {
                        nextRankGapMinutes: data.nextRankGapMinutes,
                        nextRankTargetRank: data.nextRankTargetRank
                    }
                );
            } else {
                leaderboardContent.innerHTML = `
                    <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                        Failed to load leaderboard.
                    </div>
                `;
            }
        } catch (error) {
            console.error('Error loading leaderboard:', error);
            leaderboardContent.innerHTML = `
                <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                    Error loading leaderboard. Please try again later.
                </div>
            `;
        }
    }

    displayLeaderboardInPanel(containerElement, leaderboard, currentUserPosition, pagination = null, rankMeta = null) {
        // Find current user's stats
        const stats = this.getFocusStats();
        const totalHours = stats.totalHours || 0;
        const hours = Math.floor(totalHours);
        const minutes = Math.round((totalHours - hours) * 60);
        const userTimeString = `${hours}h ${minutes}m`;
        const nextRankGapMinutes = rankMeta?.nextRankGapMinutes;
        const nextRankTargetRank = rankMeta?.nextRankTargetRank;

        let nextRankGapLine = '';
        if (
            currentUserPosition &&
            Number.isFinite(nextRankGapMinutes) &&
            nextRankGapMinutes > 0 &&
            nextRankTargetRank
        ) {
            const gapHours = Math.floor(nextRankGapMinutes / 60);
            const gapMinutes = nextRankGapMinutes % 60;
            const gapTime = gapHours > 0 ? `${gapHours}h ${gapMinutes}m` : `${gapMinutes}m`;
            nextRankGapLine = `You need ${gapTime} to pass Rank ${nextRankTargetRank}.`;
        }

        let html = '';
        const isPremiumUser = this.isPremiumUser ? this.isPremiumUser() : false;

        // Header with user position (Premium: full card; Free: rank + CTA to appear on list)
        if (isPremiumUser && currentUserPosition) {
            const totalUsersText = pagination?.totalUsers ?? leaderboard.length;
            html += `
                <div style="padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin-bottom: 16px; border: 1px solid rgba(255, 255, 255, 0.08);">
                    <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 4px;">Your Rank</div>
                    <div style="color: #fff; font-size: 24px; font-weight: 700;">#${currentUserPosition}</div>
                    <div style="color: #a3a3a3; font-size: 12px; margin-top: 4px;">${userTimeString} ‚Ä¢ ${totalUsersText} premium users</div>
                    ${nextRankGapLine ? `<div style="color: #a3a3a3; font-size: 12px; margin-top: 6px;">${nextRankGapLine}</div>` : ''}
                </div>
            `;
        } else if (!isPremiumUser) {
            const rankLine = currentUserPosition
                ? `<div style="color: #fff; font-size: 24px; font-weight: 700;">#${currentUserPosition}</div><div style="color: #a3a3a3; font-size: 12px; margin-top: 4px;">${userTimeString}</div>`
                : '';
            const ctaLine = currentUserPosition
                ? 'Want to appear on the list? Upgrade to Premium.'
                : 'Upgrade to Premium to see your ranking.';
            html += `
                <div style="padding: 16px; background: rgba(255, 255, 255, 0.05); border-radius: 12px; margin-bottom: 16px; border: 1px solid rgba(255, 255, 255, 0.08);">
                    <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 6px;">Your rank would be</div>
                    ${rankLine}
                    <div style="color: #a3a3a3; font-size: 12px; margin-top: 8px; margin-bottom: 12px;">${ctaLine}</div>
                    <button id="leaderboardPanelUpgradeBtn" style="background: #fff; color: #000; border: none; padding: 10px 18px; border-radius: 10px; font-weight: 700; cursor: pointer; font-size: 13px;">Unlock Unlimited</button>
                </div>
            `;
        }

        // Leaderboard list
        const topUsers = leaderboard.filter((user) => user.isPremium === true);
        const currentPage = pagination?.page || 1;
        const totalPages = pagination?.totalPages || 1;
        const pageSize = pagination?.pageSize || 100;
        const startRank = (currentPage - 1) * pageSize + 1;
        
        if (topUsers.length === 0) {
            html += `
                <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                    No Premium users yet. Be the first!
                </div>
            `;
        } else {
            html += '<div style="display: flex; flex-direction: column; gap: 8px;">';
            html += topUsers.map((user, index) => {
                const isCurrentUser = user.isCurrentUser;
                const isPremium = user.isPremium === true;
                const userHours = Math.floor(user.totalFocusHours);
                const userMinutes = Math.round((user.totalFocusHours - userHours) * 60);
                const userTimeStr = `${userHours}h ${userMinutes}m`;
                
                const globalRank = startRank + index;

                const premiumCrown = isPremium ? `
                    <span 
                        style="
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            margin-left: 8px;
                            cursor: help;
                            position: relative;
                        "
                        title="Premium Member"
                        class="premium-crown-badge"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z"/>
                            <path d="M5 21h14"/>
                        </svg>
                    </span>
                ` : '';

                const rankChange = user.rankChange;
                let rankChangeIcon = '';
                if (typeof rankChange === 'number' && rankChange !== 0) {
                    const isUp = rankChange > 0;
                    const color = isUp ? '#22c55e' : '#ef4444';
                    const iconSvg = isUp
                        ? `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-move-up-icon"><path d="M8 6L12 2L16 6"/><path d="M12 2V22"/></svg>`
                        : `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-move-down-icon"><path d="M8 18L12 22L16 18"/><path d="M12 2V22"/></svg>`;

                    rankChangeIcon = `
                        <span style="display: inline-flex; align-items: center; margin-left: 6px; color: ${color};">
                            ${iconSvg}
                        </span>
                    `;
                }

                return `
                    <div style="
                        padding: 12px 16px;
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        background: ${isCurrentUser ? 'rgba(34, 197, 94, 0.1)' : 'rgba(255, 255, 255, 0.05)'};
                        border-radius: 8px;
                        border: ${isCurrentUser ? '1px solid rgba(34, 197, 94, 0.3)' : '1px solid rgba(255, 255, 255, 0.05)'};
                        position: relative;
                    ">
                        <div style="display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0;">
                            <div style="display: flex; align-items: center; min-width: 60px;">
                                <span style="color: #a3a3a3; font-size: 14px; font-weight: 600;">${globalRank}.</span>
                                ${premiumCrown}
                                ${rankChangeIcon}
                            </div>
                            <span style="
                                color: ${isCurrentUser ? '#22c55e' : '#fff'}; 
                                font-size: 14px; 
                                font-weight: ${isCurrentUser ? '600' : '500'}; 
                                overflow: hidden; 
                                text-overflow: ellipsis; 
                                white-space: nowrap;
                            ">
                                ${this.escapeHtml(user.username)}
                            </span>
                        </div>
                        <span style="color: #a3a3a3; font-size: 14px; font-weight: 500;">${userTimeStr}</span>
                    </div>
                `;
            }).join('');
            html += '</div>';
        }

        // Pagination controls (only show if there are more than 100 users)
        if (pagination && totalPages > 1) {
            html += `
                <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid rgba(255, 255, 255, 0.1); display: flex; align-items: center; justify-content: space-between; gap: 16px;">
                    <button 
                        id="leaderboardPrevPage" 
                        style="
                            padding: 8px 16px;
                            background: ${currentPage > 1 ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 255, 255, 0.05)'};
                            color: ${currentPage > 1 ? '#fff' : '#d0d0d0'};
                            border: 1px solid rgba(255, 255, 255, 0.1);
                            border-radius: 8px;
                            cursor: ${currentPage > 1 ? 'pointer' : 'not-allowed'};
                            font-size: 14px;
                            font-weight: 500;
                            transition: all 0.2s;
                            ${currentPage > 1 ? '' : 'opacity: 0.5;'}
                        "
                        ${currentPage > 1 ? '' : 'disabled'}
                    >
                        ‚Üê Previous
                    </button>
                    <div style="color: #a3a3a3; font-size: 14px;">
                        Page ${currentPage} of ${totalPages}
                    </div>
                    <button 
                        id="leaderboardNextPage" 
                        style="
                            padding: 8px 16px;
                            background: ${currentPage < totalPages ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 255, 255, 0.05)'};
                            color: ${currentPage < totalPages ? '#fff' : '#d0d0d0'};
                            border: 1px solid rgba(255, 255, 255, 0.1);
                            border-radius: 8px;
                            cursor: ${currentPage < totalPages ? 'pointer' : 'not-allowed'};
                            font-size: 14px;
                            font-weight: 500;
                            transition: all 0.2s;
                            ${currentPage < totalPages ? '' : 'opacity: 0.5;'}
                        "
                        ${currentPage < totalPages ? '' : 'disabled'}
                    >
                        Next ‚Üí
                    </button>
                </div>
            `;
        }

        containerElement.innerHTML = html;

        const upgradeBtn = containerElement.querySelector('#leaderboardPanelUpgradeBtn');
        if (upgradeBtn) {
            upgradeBtn.addEventListener('click', () => {
                this.trackEvent('Subscribe Clicked', {
                    source: 'leaderboard_panel',
                    location: 'leaderboard_panel',
                    button_text: 'Unlock Unlimited'
                });
                this.showPricingPlansModal();
            });
        }

        // Add event listeners for pagination buttons
        if (pagination && totalPages > 1) {
            const prevBtn = document.getElementById('leaderboardPrevPage');
            const nextBtn = document.getElementById('leaderboardNextPage');
            
            if (prevBtn && currentPage > 1) {
                prevBtn.addEventListener('click', () => {
                    this.loadLeaderboardForPanel(currentPage - 1);
                });
            }
            
            if (nextBtn && currentPage < totalPages) {
                nextBtn.addEventListener('click', () => {
                    this.loadLeaderboardForPanel(currentPage + 1);
                });
            }
        }
    }

    async loadReportForPanel() {
        const reportContent = document.getElementById('reportContent');
        if (!reportContent) return;

        // Demo mode for preview/local (no login required)
        try {
            const params = new URLSearchParams(window.location.search);
            const demoParam = params.get('demo');
            const hostname = window.location.hostname;
            const isPreviewHost = hostname.includes('vercel.app') || hostname.includes('localhost');
            const isDemo = isPreviewHost && (demoParam === '1' || demoParam === 'true');
            if (isDemo) {
                reportContent.innerHTML = `
                    <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                        Loading report...
                    </div>
                `;
                const demo = this.getDemoReportData();
                // Seed demo tasks if none exist
                if (this.getLocalTasks().length === 0) {
                    this.setLocalTasks(demo.tasks);
                    demo.taskConfigs.forEach(cfg => this.setTaskConfig(cfg.id, cfg.config));
                }
                this.streakData = demo.streakData;
                this.displayAdvancedReport(reportContent, demo.stats);
                return;
            }
        } catch (_) {}

        // Only load if authenticated
        if (!this.isAuthenticated || !this.user?.id) {
            reportContent.innerHTML = `
                <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                    Please log in to view your report.
                </div>
            `;
            return;
        }

        // Check if user is premium
        const isPremium = this.isPremiumUser();

        // Show loading state
        reportContent.innerHTML = `
            <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                Loading report...
            </div>
        `;

        // Get stats
        const stats = this.getFocusStats();
        
        // Display report based on premium status
        try {
            if (isPremium) {
                this.displayAdvancedReport(reportContent, stats);
            } else {
                this.displayBasicReport(reportContent, stats);
            }
        } catch (error) {
            console.error('Error displaying report:', error);
            reportContent.innerHTML = `
                <div style="padding: 24px; text-align: center; color: #ff6b6b;">
                    <div style="margin-bottom: 8px;">Error loading report</div>
                    <div style="font-size: 12px; color: #a3a3a3;">${error.message}</div>
                </div>
            `;
        }
    }

    getDemoReportData() {
        const today = new Date();
        const dayHours = [0.6, 1.2, 0.8, 1.7, 2.4, 0.4, 1.1];
        const daily = {};
        const dailySessions = {};
        const dailyBreaks = {};
        dayHours.forEach((hours, index) => {
            const d = new Date(today);
            d.setDate(today.getDate() - (6 - index));
            const dateStr = d.toDateString();
            daily[dateStr] = hours;
            dailySessions[dateStr] = Math.max(1, Math.round(hours / 0.5));
            dailyBreaks[dateStr] = Math.max(0, Math.round(hours / 1.5));
        });
        const totalHours = dayHours.reduce((sum, h) => sum + h, 0);
        const completedCycles = Object.values(dailySessions).reduce((sum, v) => sum + v, 0);
        const nowIso = new Date().toISOString();
        return {
            stats: {
                totalHours,
                completedCycles,
                daily,
                dailySessions,
                dailyBreaks
            },
            streakData: {
                currentStreak: 0,
                longestStreak: 8,
                lastActiveDate: null
            },
            tasks: [
                { id: 'demo-1', content: 'Calculus ‚Äî Chapter 3', completed: true, completedAt: nowIso },
                { id: 'demo-2', content: 'History ‚Äî Essay outline', completed: true, completedAt: nowIso },
                { id: 'demo-3', content: 'Biology ‚Äî Review notes', completed: true, completedAt: nowIso }
            ],
            taskConfigs: [
                { id: 'demo-1', config: { completedSessions: 3, completedFocusTime: 3 * 25 * 60 } },
                { id: 'demo-2', config: { completedSessions: 2, completedFocusTime: 2 * 25 * 60 } },
                { id: 'demo-3', config: { completedSessions: 4, completedFocusTime: 4 * 25 * 60 } }
            ]
        };
    }

    displayBasicReport(containerElement, stats) {
        try {
            const currentStreak = this.calculateCurrentStreak(stats);
            const longestStreak = this.streakData?.longestStreak || 0;
            const streakTitle = currentStreak > 0 ? `${currentStreak}-day streak` : 'No streak yet';
            const streakSubtitle = currentStreak > 0 ? `Best: ${longestStreak} days` : 'Start today with one session';
            const last7Days = this.getLastNDaysData(stats, 7);
            const weekTotalHours = last7Days.reduce((sum, day) => sum + (day.hours || 0), 0);

        const html = `
            <div style="padding: 0; position: relative;">

                <!-- Streak (FREE) -->
                <div style="background: #2a2a2a; border-radius: 12px; padding: 24px; margin-bottom: 16px; display: flex; align-items: center; justify-content: space-between; gap: 16px;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 28px;">üî•</div>
                        <div>
                            <div style="font-size: 22px; font-weight: 700; color: #fff;">${streakTitle}</div>
                            <div style="font-size: 12px; color: #a3a3a3;">${streakSubtitle}</div>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 12px; color: #a3a3a3;">Last 7 days</div>
                        <div style="font-size: 16px; color: #fff; font-weight: 600;">${weekTotalHours < 0.1 ? weekTotalHours.toFixed(2) : weekTotalHours.toFixed(1)}h total</div>
                    </div>
                </div>

                <!-- Disabled Sections Wrapper -->
                <div style="position: relative;">
                <!-- Activity (disabled for Free) -->
                <div style="background: #2a2a2a; border-radius: 12px; padding: 20px; margin-bottom: 16px; opacity: 0.5;">
                    <div style="font-size: 16px; color: #fff; font-weight: 600; margin-bottom: 12px;">Activity</div>
                    <div style="height: 120px; display: flex; align-items: flex-end; gap: 6px;">
                        ${Array(7).fill(0).map((_, i) => `
                            <div style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; gap: 4px; height: 100%;">
                                <div style="width: 100%; height: ${Math.random() * 60 + 20}%; background: #444; border-radius: 4px;"></div>
                                <div style="font-size: 10px; color: #d0d0d0;">Day ${i + 1}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>

                <!-- Level (disabled for Free) -->
                <div style="background: #2a2a2a; border-radius: 12px; padding: 20px; margin-bottom: 16px; opacity: 0.5;">
                    <div style="font-size: 16px; color: #fff; font-weight: 600; margin-bottom: 12px;">Level</div>
                    <div style="width: 100%; height: 5px; background: #333; border-radius: 6px; overflow: hidden; margin-bottom: 8px;">
                        <div style="width: 50%; height: 100%; background: #555;"></div>
                    </div>
                    <div style="font-size: 12px; color: #a3a3a3;">Unlock to see your level</div>
                </div>

                <!-- Recent Activity (disabled for Free) -->
                <div style="background: #2a2a2a; border-radius: 12px; padding: 20px; margin-bottom: 16px; opacity: 0.5;">
                    <h4 style="margin: 0 0 16px 0; color: #ffffff; font-size: 16px;">Recent Activity</h4>
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        ${(() => {
                            // Get real completed tasks but show them disabled
                            const allTasks = this.getLocalTasks();
                            const completedTasks = allTasks
                                .filter(task => task.completed && task.completedAt)
                                .sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt))
                                .slice(0, 2); // Show only 2 for free users
                            
                            if (completedTasks.length === 0) {
                                return `
                                    <div style="background: #333; border-radius: 8px; padding: 12px;">
                                        <div style="color: #d0d0d0; font-size: 14px; margin-bottom: 4px;">No completed tasks yet</div>
                                        <div style="color: #d0d0d0; font-size: 12px;">Complete tasks to see them here</div>
                                    </div>
                                `;
                            }
                            
                            return completedTasks.map(task => {
                                const completedDate = new Date(task.completedAt);
                                const dateStr = completedDate.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: '2-digit' });
                                const timeStr = completedDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                                
                                const taskConfig = this.getTaskConfig(task.id);
                                const sessions = taskConfig.completedSessions || 0;
                                const focusHours = (taskConfig.completedFocusTime || 0) / 3600;
                                
                                return `
                                    <div style="background: #333; border-radius: 8px; padding: 12px;">
                                        <div style="color: #d0d0d0; font-size: 14px; margin-bottom: 4px;">${dateStr} ‚Ä¢ ${task.content}</div>
                                        <div style="color: #d0d0d0; font-size: 12px;">${focusHours.toFixed(1)}h ‚Ä¢ ${sessions} session${sessions !== 1 ? 's' : ''} ‚Ä¢ ${timeStr}</div>
                                    </div>
                                `;
                            }).join('');
                        })()}
                    </div>
                </div>

                <!-- Single Unlock Overlay -->
                <div style="position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.6); backdrop-filter: blur(2px); -webkit-backdrop-filter: blur(2px); border-radius: 12px;">
                    <div style="text-align: center;">
                        <div style="font-size: 16px; color: #fff; font-weight: 700; margin-bottom: 12px; max-width: 240px; margin-left: auto; margin-right: auto;">Unlock analytics to see if you're improving every day.</div>
                        <button id="upgradeFromFreeReport" style="background: #fff; color: #000; border: none; padding: 12px 22px; border-radius: 10px; font-weight: 700; cursor: pointer; font-size: 14px;">Unlock Unlimited</button>
                    </div>
                </div>
                </div>


            </div>
        `;

        containerElement.innerHTML = html;

        // Single upgrade button event
        const freeUpgradeBtn = document.getElementById('upgradeFromFreeReport');
        if (freeUpgradeBtn) {
            freeUpgradeBtn.addEventListener('click', () => {
                if (window.pomodoroTimer) {
                    window.pomodoroTimer.trackEvent('Subscribe Clicked', {
                        button_type: 'subscribe',
                        source: 'report_panel',
                        location: 'free_report',
                        user_type: 'free',
                        modal_type: 'report_upgrade_prompt'
                    });
                    window.pomodoroTimer.showPricingPlansModal();
                }
            });
        }
        } catch (error) {
            console.error('Error in displayBasicReport:', error);
            containerElement.innerHTML = `
                <div style="padding: 24px; text-align: center; color: #ff6b6b;">
                    <div style="margin-bottom: 8px;">Error loading report</div>
                    <div style="font-size: 12px; color: #a3a3a3;">${error.message}</div>
                </div>
            `;
        }
    }

    displayAdvancedReport(containerElement, stats) {
        try {
            // For level calculation, use all-time totals
            const totalHours = stats.totalHours || 0;
        
        // Get data for chart
        const last7Days = this.getLastNDaysData(stats, 7);
        const weekTotalHours = last7Days.reduce((sum, day) => sum + (day.hours || 0), 0);
        
        // Calculate level based on total hours (all-time)
        const level = this.calculateUserLevel(totalHours);
        const currentStreak = this.calculateCurrentStreak(stats);
        const longestStreak = this.streakData?.longestStreak || 0;
        const streakTitle = currentStreak > 0 ? `${currentStreak}-day streak` : 'No streak yet';
        const streakSubtitle = currentStreak > 0 ? `Best: ${longestStreak} days` : 'Start today with one session';
        
        const html = `
            <div style="padding: 0;">
                <!-- Streak Hero -->
                <div style="background: #2a2a2a; border-radius: 12px; padding: 24px; margin-bottom: 16px; display: flex; align-items: center; justify-content: space-between; gap: 16px;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 28px;">üî•</div>
                        <div>
                            <div style="font-size: 22px; font-weight: 700; color: #fff;">${streakTitle}</div>
                            <div style="font-size: 12px; color: #a3a3a3;">${streakSubtitle}</div>
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-size: 12px; color: #a3a3a3;">Last 7 days</div>
                        <div style="font-size: 16px; color: #fff; font-weight: 600;">${weekTotalHours < 0.1 ? weekTotalHours.toFixed(2) : weekTotalHours.toFixed(1)}h total</div>
                    </div>
                </div>

                <!-- Activity Chart -->
                <div style="background: #2a2a2a; border-radius: 12px; padding: 20px; margin-bottom: 16px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                        <div style="font-size: 16px; color: #fff; font-weight: 600;">Activity</div>
                    <div style="display: inline-flex; background: #1a1a1a; border-radius: 8px; padding: 2px;">
                            <button class="activity-range-btn active" data-range="W" style="background: #2a2a2a; color: #fff; border: none; padding: 4px 8px; font-size: 11px; border-radius: 6px;">W</button>
                            <button class="activity-range-btn" data-range="M" style="background: transparent; color: #a3a3a3; border: none; padding: 4px 8px; font-size: 11px; border-radius: 6px;">M</button>
                            <button class="activity-range-btn" data-range="Y" style="background: transparent; color: #a3a3a3; border: none; padding: 4px 8px; font-size: 11px; border-radius: 6px;">Y</button>
                        </div>
                    </div>
                    <div id="activityRangeLabel" style="font-size: 12px; color: #a3a3a3; margin-bottom: 12px;">Last 7 days ¬∑ ${weekTotalHours < 0.1 ? weekTotalHours.toFixed(2) : weekTotalHours.toFixed(1)}h</div>
                    <div id="activityChartBars" style="height: 140px; display: flex; align-items: flex-end; gap: 6px;">
                        ${(() => {
                            const maxHours = Math.max(...last7Days.map(d => d.hours), 1);
                            return last7Days.map(day => {
                                const height = (day.hours / maxHours) * 100;
                                const valueLabel = day.hours ? (day.hours < 0.1 ? day.hours.toFixed(2) : day.hours.toFixed(1)) + 'h' : '‚Äî';
                                return `
                                    <div style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; gap: 4px; height: 100%;">
                                        <div style="font-size: 10px; color: #a3a3a3;">${valueLabel}</div>
                                        <div style="width: 100%; height: ${height}%; background: #ffffff; border-radius: 4px; min-height: ${day.hours > 0 ? '4px' : '0'}; opacity: ${day.hours > 0 ? '0.9' : '0.2'};"></div>
                                        <div style="font-size: 10px; color: #a3a3a3;">${day.label}</div>
                                    </div>
                                `;
                            }).join('');
                        })()}
                    </div>
                </div>

                <!-- Level -->
                <div style="background: #2a2a2a; border-radius: 12px; padding: 16px; margin-bottom: 16px;">
                        <div style="font-size: 12px; color: #a3a3a3; margin-bottom: 8px;">LEVEL</div>
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                            <div style="font-size: 22px;">${level.emoji}</div>
                            <div style="font-size: 14px; color: #fff; font-weight: 600;">${level.name}</div>
                        </div>
                    <div style="font-size: 11px; color: #a3a3a3; margin-bottom: 6px;">${totalHours < 0.1 ? totalHours.toFixed(2) : totalHours.toFixed(1)}h total</div>
                    <div style="width: 100%; height: 5px; background: #1a1a1a; border-radius: 6px; overflow: hidden; margin-bottom: 6px;">
                        <div style="width: ${level.progress}%; height: 100%; background: #ffffff;"></div>
                    </div>
                        <div style="font-size: 11px; color: #a3a3a3;">${level.hoursToNext.toFixed(1)}h to ${level.nextLevel}</div>
                    <div style="margin-top: 12px; text-align: center;">
                        <button id="viewAllLevels" style="background: #1a1a1a; color: #fff; border: 1px solid rgba(255,255,255,0.1); padding: 8px 12px; border-radius: 10px; font-size: 12px; cursor: pointer;">View All Levels</button>
                    </div>
                </div>

                <!-- Recent Activity (Done Tasks) -->
                <div style="background: #2a2a2a; border-radius: 12px; padding: 16px; margin-bottom: 16px;">
                    <div style="font-size: 12px; color: #a3a3a3; margin-bottom: 10px;">RECENT ACTIVITY</div>
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        ${(() => {
                            const allTasks = this.getLocalTasks();
                            const completedTasks = allTasks
                                .filter(task => task.completed && task.completedAt)
                                .sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt))
                                .slice(0, 5);
                            
                            if (completedTasks.length === 0) {
                                return `
                                    <div style="text-align: center; padding: 16px; color: #d0d0d0;">
                                        <div style="font-size: 12px;">No completed tasks yet</div>
                                    </div>
                                `;
                            }
                            
                            return completedTasks.map(task => {
                                const completedDate = new Date(task.completedAt);
                                const dateStr = completedDate.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: '2-digit' });
                                const timeStr = completedDate.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                                const taskConfig = this.getTaskConfig(task.id);
                                const sessions = taskConfig.completedSessions || 0;
                                const focusHours = (taskConfig.completedFocusTime || 0) / 3600;
                                
                                return `
                                    <div style="background: #1a1a1a; border-radius: 12px; padding: 12px;">
                                        <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 4px;">${dateStr} ‚Ä¢ ${task.content}</div>
                                        <div style="color: #a3a3a3; font-size: 12px;">${focusHours.toFixed(1)}h ‚Ä¢ ${sessions} session${sessions !== 1 ? 's' : ''} ‚Ä¢ Completed at ${timeStr}</div>
                                    </div>
                                `;
                            }).join('');
                        })()}
                    </div>
                    <div style="margin-top: 12px; text-align: center;">
                        <button id="openDoneHistory" style="background: #1a1a1a; color: #fff; border: 1px solid rgba(255,255,255,0.1); padding: 8px 12px; border-radius: 10px; font-size: 12px; cursor: pointer;">View Done History</button>
                    </div>
                </div>

            </div>
        `;

            containerElement.innerHTML = html;
            const openDoneHistoryBtn = document.getElementById('openDoneHistory');
            if (openDoneHistoryBtn && window.sidebarManager && typeof window.sidebarManager.openTaskPanel === 'function') {
                openDoneHistoryBtn.addEventListener('click', () => {
                    window.sidebarManager.openTaskPanel();
                    setTimeout(() => {
                        const panel = document.getElementById('taskSidePanel');
                        const doneTab = panel?.querySelector('.task-tab[data-tab="done"]');
                        if (doneTab) doneTab.click();
                    }, 50);
                });
            }

            // Activity range buttons (D/W/M/Y)
            const rangeButtons = containerElement.querySelectorAll('.activity-range-btn');
            const rangeLabel = containerElement.querySelector('#activityRangeLabel');
            const barsEl = containerElement.querySelector('#activityChartBars');
            const renderBars = (items) => {
                if (!barsEl) return;
                const maxHours = Math.max(...items.map(d => d.hours || 0), 1);
                barsEl.innerHTML = items.map(item => {
                    const height = ((item.hours || 0) / maxHours) * 100;
                    const valueLabel = item.hours ? (item.hours < 0.1 ? item.hours.toFixed(2) : item.hours.toFixed(1)) + 'h' : '‚Äî';
                    return `
                        <div style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; gap: 4px; height: 100%;">
                            <div style="font-size: 10px; color: #a3a3a3;">${valueLabel}</div>
                            <div style="width: 100%; height: ${height}%; background: #ffffff; border-radius: 4px; min-height: ${(item.hours || 0) > 0 ? '4px' : '0'}; opacity: ${(item.hours || 0) > 0 ? '0.9' : '0.2'};"></div>
                            <div style="font-size: 10px; color: #a3a3a3;">${item.label}</div>
                        </div>
                    `;
                }).join('');
            };
            const setRange = (range) => {
                let items = [];
                let labelText = '';
                if (range === 'W') {
                    items = this.getLastNDaysData(stats, 7);
                    const total = items.reduce((sum, d) => sum + (d.hours || 0), 0);
                    labelText = `Last 7 days ¬∑ ${total < 0.1 ? total.toFixed(2) : total.toFixed(1)}h`;
                } else if (range === 'M') {
                    items = this.getLastNWeeksData(stats, 4);
                    items = items.map(item => ({
                        ...item,
                        label: new Date(item.start).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
                    }));
                    const total = items.reduce((sum, d) => sum + (d.hours || 0), 0);
                    labelText = `Last 4 weeks ¬∑ ${total < 0.1 ? total.toFixed(2) : total.toFixed(1)}h`;
                } else if (range === 'Y') {
                    items = this.getLastNMonthsData(stats, 12);
                    items = items.map(item => ({
                        ...item,
                        label: new Date(item.start).toLocaleDateString('en-US', { month: 'short' })
                    }));
                    const total = items.reduce((sum, d) => sum + (d.hours || 0), 0);
                    labelText = `Last 12 months ¬∑ ${total < 0.1 ? total.toFixed(2) : total.toFixed(1)}h`;
                }
                if (rangeLabel) rangeLabel.textContent = labelText;
                renderBars(items);
            };
            rangeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    rangeButtons.forEach(b => {
                        b.classList.remove('active');
                        b.style.background = 'transparent';
                        b.style.color = '#a3a3a3';
                    });
                    btn.classList.add('active');
                    btn.style.background = '#2a2a2a';
                    btn.style.color = '#fff';
                    setRange(btn.dataset.range);
                });
            });
            // Initialize with W
            setRange('W');

            // View all levels modal
            const viewAllLevelsBtn = document.getElementById('viewAllLevels');
            if (viewAllLevelsBtn) {
                viewAllLevelsBtn.addEventListener('click', () => {
                    const overlay = document.createElement('div');
                    overlay.className = 'focus-stats-overlay';
                    overlay.style.cssText = `
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0,0,0,0.6);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10050;
                    `;
                    const modal = document.createElement('div');
                    modal.style.cssText = `
                        background: #1a1a1a;
                        border: 1px solid rgba(255,255,255,0.08);
                        border-radius: 12px;
                        padding: 20px;
                        width: 90%;
                        max-width: 420px;
                        color: #fff;
                    `;
                    modal.innerHTML = `
                        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom: 12px;">
                            <div style="font-size: 14px; font-weight: 600;">All Levels</div>
                            <button id="closeLevelsModal" style="background: transparent; border: none; color: #a3a3a3; font-size: 16px; cursor: pointer;">‚úï</button>
                        </div>
                        <div style="display:flex; flex-direction:column; gap:8px;">
                            ${(() => {
                                const levels = [
                                    { name: 'JUST STARTING', range: '0‚Äì5h', emoji: 'üå±' },
                                    { name: 'GETTING SERIOUS', range: '5‚Äì15h', emoji: 'üìò' },
                                    { name: 'CONSISTENT STUDENT', range: '15‚Äì30h', emoji: 'üß†' },
                                    { name: 'EXAM READY', range: '30‚Äì50h', emoji: 'üéì' },
                                    { name: 'EXAM CRUSHER', range: '50‚Äì100h', emoji: 'üèÜ' },
                                    { name: 'TOP OF CLASS', range: '100‚Äì200h', emoji: 'ü•á' },
                                    { name: 'LEGENDARY STUDENT', range: '200h+', emoji: 'üëë' }
                                ];
                                return levels.map(l => `
                                    <div style="display:flex; justify-content:space-between; align-items:center; padding:6px 2px;">
                                        <div style="font-size:12px; color:#fff; display:flex; align-items:center; gap:6px;">
                                            <span>${l.emoji}</span>
                                            <span>${l.name}</span>
                                        </div>
                                        <div style="font-size:11px; color:#a3a3a3;">${l.range}</div>
                                    </div>
                                `).join('');
                            })()}
                        </div>
                    `;
                    overlay.appendChild(modal);
                    document.body.appendChild(overlay);
                    const close = () => overlay.remove();
                    overlay.addEventListener('click', (e) => {
                        if (e.target === overlay) close();
                    });
                    const closeBtn = modal.querySelector('#closeLevelsModal');
                    if (closeBtn) closeBtn.addEventListener('click', close);
                });
            }
        } catch (error) {
            console.error('Error in displayAdvancedReport:', error);
            containerElement.innerHTML = `
                <div style="padding: 24px; text-align: center; color: #ff6b6b;">
                    <div style="margin-bottom: 8px;">Error loading report</div>
                    <div style="font-size: 12px; color: #a3a3a3;">${error.message}</div>
                </div>
            `;
        }
    }

    calculateUserLevel(totalHours) {
        try {
            const levels = [
                { level: 1, name: 'JUST STARTING', emoji: 'üå±', min: 0, max: 5, color: '#10b981' },
                { level: 2, name: 'GETTING SERIOUS', emoji: 'üìò', min: 5, max: 15, color: '#3b82f6' },
                { level: 3, name: 'CONSISTENT STUDENT', emoji: 'üß†', min: 15, max: 30, color: '#8b5cf6' },
                { level: 4, name: 'EXAM READY', emoji: 'üéì', min: 30, max: 50, color: '#ec4899' },
                { level: 5, name: 'EXAM CRUSHER', emoji: 'üèÜ', min: 50, max: 100, color: '#f59e0b' },
                { level: 6, name: 'TOP OF CLASS', emoji: 'ü•á', min: 100, max: 200, color: '#ef4444' },
                { level: 7, name: 'LEGENDARY STUDENT', emoji: 'üëë', min: 200, max: 999999, color: '#fbbf24' }
            ];

            let currentLevel = levels[0];
            for (const level of levels) {
                if (totalHours >= level.min && totalHours < level.max) {
                    currentLevel = level;
                    break;
                }
            }
            
            // Handle max level case
            if (totalHours >= 200) {
                currentLevel = levels[6];
            }

            const nextLevelIndex = currentLevel.level < levels.length ? currentLevel.level : currentLevel.level - 1;
            const nextLevel = levels[nextLevelIndex] || levels[levels.length - 1];
            const hoursInLevel = totalHours - currentLevel.min;
            const hoursNeededForLevel = currentLevel.max - currentLevel.min;
            const progress = hoursNeededForLevel > 0 && isFinite(hoursNeededForLevel) ? (hoursInLevel / hoursNeededForLevel) * 100 : 100;
            const hoursToNext = currentLevel.max - totalHours;

            // TODO: Get real user count from API
            const usersCount = Math.floor(Math.random() * 200) + 50;

            return {
                level: currentLevel.level,
                name: currentLevel.name,
                emoji: currentLevel.emoji,
                color: currentLevel.color,
                progress: Math.min(progress, 100),
                hoursToNext: isFinite(hoursToNext) ? Math.max(hoursToNext, 0) : 0,
                nextLevel: currentLevel.level >= 7 ? 'MAX LEVEL' : nextLevel.name,
                usersCount: usersCount
            };
        } catch (error) {
            console.error('Error calculating user level:', error);
            return {
                level: 1,
                name: 'BEGINNER',
                emoji: 'üå±',
                color: '#10b981',
                progress: 0,
                hoursToNext: 5,
                nextLevel: 'FOCUSED',
                usersCount: 100
            };
        }
    }

    displayLeaderboard(modalElement, leaderboard, currentUserPosition) {
        const contentDiv = modalElement.querySelector('.upgrade-content');
        if (!contentDiv) return;

        // Find current user's stats
        const stats = this.getFocusStats();
        const totalHours = stats.totalHours || 0;
        const hours = Math.floor(totalHours);
        const minutes = Math.round((totalHours - hours) * 60);
        const userTimeString = `${hours}h ${minutes}m`;

        // Create leaderboard section
        const leaderboardSection = document.createElement('div');
        leaderboardSection.style.marginTop = '24px';
        leaderboardSection.style.paddingTop = '24px';
        leaderboardSection.style.borderTop = '1px solid rgba(255, 255, 255, 0.1)';

        // Leaderboard header
        const leaderboardHeader = document.createElement('div');
        leaderboardHeader.style.marginBottom = '16px';
        leaderboardHeader.innerHTML = `
            <h4 style="color: #fff; font-size: 18px; font-weight: 600; margin-bottom: 8px;">Leaderboard</h4>
            <p style="color: #a3a3a3; font-size: 14px; margin: 0;">
                ${currentUserPosition ? `You're ranked #${currentUserPosition} of ${leaderboard.length}` : 'Top Focus Hours'}
            </p>
        `;
        leaderboardSection.appendChild(leaderboardHeader);

        // Leaderboard list container
        const leaderboardList = document.createElement('div');
        leaderboardList.style.maxHeight = '300px';
        leaderboardList.style.overflowY = 'auto';
        leaderboardList.style.borderRadius = '12px';
        leaderboardList.style.background = '#1a1a1a';

        // Show top 10 users
        const topUsers = leaderboard.slice(0, 10);
        
        if (topUsers.length === 0) {
            leaderboardList.innerHTML = `
                <div style="padding: 24px; text-align: center; color: #a3a3a3;">
                    No users yet. Be the first!
                </div>
            `;
        } else {
            leaderboardList.innerHTML = topUsers.map((user, index) => {
                const isCurrentUser = user.isCurrentUser;
                const userHours = Math.floor(user.totalFocusHours);
                const userMinutes = Math.round((user.totalFocusHours - userHours) * 60);
                const userTimeStr = `${userHours}h ${userMinutes}m`;
                
                // Medal emojis for top 3
                let rankDisplay = `${index + 1}.`;
                if (index === 0) rankDisplay = 'ü•á 1.';
                else if (index === 1) rankDisplay = 'ü•à 2.';
                else if (index === 2) rankDisplay = 'ü•â 3.';

                return `
                    <div style="
                        padding: 12px 16px;
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                        ${isCurrentUser ? 'background: rgba(34, 197, 94, 0.1); border-left: 3px solid #22c55e;' : ''}
                    ">
                        <div style="display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0;">
                            <span style="color: #a3a3a3; font-size: 14px; font-weight: 600; min-width: 40px;">${rankDisplay}</span>
                            <span style="color: ${isCurrentUser ? '#22c55e' : '#fff'}; font-size: 14px; font-weight: ${isCurrentUser ? '600' : '500'}; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                ${this.escapeHtml(user.username)}
                            </span>
                        </div>
                        <span style="color: #a3a3a3; font-size: 14px; font-weight: 500;">${userTimeStr}</span>
                    </div>
                `;
            }).join('');
        }

        leaderboardSection.appendChild(leaderboardList);

        // Add current user's position if not in top 10
        if (currentUserPosition && currentUserPosition > 10) {
            const currentUserRow = document.createElement('div');
            currentUserRow.style.marginTop = '12px';
            currentUserRow.style.padding = '12px 16px';
            currentUserRow.style.background = 'rgba(34, 197, 94, 0.1)';
            currentUserRow.style.borderRadius = '12px';
            currentUserRow.style.border = '1px solid rgba(34, 197, 94, 0.3)';
            currentUserRow.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span style="color: #a3a3a3; font-size: 14px; font-weight: 600;">#${currentUserPosition}</span>
                        <span style="color: #22c55e; font-size: 14px; font-weight: 600;">You</span>
                    </div>
                    <span style="color: #a3a3a3; font-size: 14px; font-weight: 500;">${userTimeString}</span>
                </div>
            `;
            leaderboardSection.appendChild(currentUserRow);
        }

        contentDiv.appendChild(leaderboardSection);
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    async resetAllData() {
        if (!confirm('‚ö†Ô∏è Are you sure you want to PERMANENTLY reset ALL your focus data?\n\nThis will:\n- Clear all local focus hours\n- Reset your server stats to 0\n- Clear your streak data\n\nThis action CANNOT be undone!')) {
            return;
        }
        
        console.log('üóëÔ∏è Resetting all user data...');
        
        // Reset focus stats (user-specific and generic)
        const key = this.isAuthenticated && this.user?.id 
            ? `focusStats_${this.user.id}` 
            : 'focusStats';
        localStorage.removeItem(key);
        localStorage.removeItem('focusStats');
        
        // Reset focus seconds today
        if (this.isAuthenticated && this.user?.id) {
            localStorage.removeItem(`focusSecondsToday_${this.user.id}`);
            localStorage.removeItem(`focusSecondsTodayDate_${this.user.id}`);
        }
        localStorage.removeItem('focusSecondsToday');
        localStorage.removeItem('focusSecondsTodayDate');
        
        // Reset in-memory values
        this.focusSecondsToday = 0;
        
        // Reset streak data
        this.streakData = {
            currentStreak: 0,
            longestStreak: 0,
            lastActiveDate: null
        };
        localStorage.removeItem('streakData');
        
        // CRITICAL: Sync 0 hours to server to prevent restoration
        if (this.isAuthenticated && this.user?.id) {
            console.log('üì§ Syncing reset (0 hours) to server...');
            try {
                await this.syncStatsToClerk(0);
                console.log('‚úÖ Server stats reset to 0');
            } catch (error) {
                console.error('‚ùå Failed to reset server stats:', error);
                alert('Warning: Local data was reset but server sync failed. Data may be restored on next login.');
            }
        }
        
        // Update displays
        this.updateFocusHoursDisplay();
        this.updateStreakDisplay();
        
        // Show confirmation
        console.log('‚úÖ All focus data has been reset');
        alert('‚úÖ All focus data has been reset successfully!');
    }

    updateConsecutiveDays(stats) {
        // Kept for backward compatibility when called by legacy flows
        const today = new Date();
        const todayStr = today.toDateString();
        if (!stats.daily) stats.daily = {};
        if ((stats.daily[todayStr] || 0) > 0) {
            if (!stats.lastActiveDate) {
                stats.consecutiveDays = 1;
                stats.lastActiveDate = todayStr;
            }
        }
    }

    updateFocusHoursDisplay() {
        if (this.achievementIcon && this.achievementCounter) {
            const stats = this.getFocusStats();
            const totalMinutes = Math.round((stats.totalHours || 0) * 60); // Convert to minutes
            const hours = Math.floor(totalMinutes / 60);
            const minutes = totalMinutes % 60;
            const timeString = `${hours.toString().padStart(2, '0')}h:${minutes.toString().padStart(2, '0')}m`;
            this.achievementCounter.textContent = timeString;
            this.achievementIcon.classList.add('active');
        }
    }

    showSimpleFocusStats() {
        const stats = this.getFocusStats();
        const totalFocusHours = stats.totalFocusHours || 0;
        const hours = Math.floor(totalFocusHours);
        const minutes = Math.floor((totalFocusHours - hours) * 60);
        const timeString = `${hours.toString().padStart(2, '0')}h:${minutes.toString().padStart(2, '0')}m`;
        
        // Simple alert for now - could be enhanced later
        alert(`Total Focus Time: ${timeString}\nCycles Completed: ${this.calculateCyclesCompleted(stats)}`);
    }


    setupSettingsTabs() {
        const navItems = document.querySelectorAll('.settings-nav-item');
        const tabs = document.querySelectorAll('.settings-tab');
        
        
        navItems.forEach(item => {
            item.addEventListener('click', () => {
                const tabName = item.getAttribute('data-tab');
                
                // Remove active class from all nav items and tabs
                navItems.forEach(nav => nav.classList.remove('active'));
                tabs.forEach(tab => tab.classList.remove('active'));
                
                // Add active class to clicked nav item and corresponding tab
                item.classList.add('active');
                const targetTab = document.getElementById(`${tabName}-tab`);
                if (targetTab) {
                    targetTab.classList.add('active');
                }
            });
        });
        
        // Setup integration controls in settings
        this.setupTodoistIntegrationControls();
        this.setupNotionIntegrationControls();
        
        
        // Check if user just signed up successfully
        this.checkSignupSuccessRedirect();
        
        // Check if user tried to access Pro feature without subscription
        this.checkProRequiredError();
    }
    
    checkProRequiredError() {
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('error') === 'pro_required') {
            // Only show modal if user is actually not Pro
            // If they're in Developer Mode as Pro, don't show it
            // Clean URL regardless of Pro status
            const newUrl = window.location.origin + window.location.pathname;
            window.history.replaceState({}, document.title, newUrl);
        }
    }



    // Centralized conversion tracking function
    trackConversion(type, value = 1.0, additionalData = {}) {
        console.log(`üéØ Tracking ${type} conversion...`, { type, value, additionalData });
        
        // Helper function to wait for gtag to be available
        const waitForGtag = (maxAttempts = 10, delay = 200) => {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const checkGtag = () => {
                    attempts++;
                    // Check if gtag is available as a function (either global or window)
                    const gtagFn = typeof window !== 'undefined' ? window.gtag : (typeof gtag !== 'undefined' ? gtag : null);
                    if (typeof gtagFn === 'function') {
                        console.log('‚úÖ gtag is available');
                        resolve();
                    } else if (attempts >= maxAttempts) {
                        console.warn('‚ö†Ô∏è gtag not available after waiting', { attempts, gtag: typeof gtag, windowGtag: typeof window?.gtag });
                        reject(new Error('gtag not available'));
                    } else {
                        setTimeout(checkGtag, delay);
                    }
                };
                checkGtag();
            });
        };

        // Track conversion with retry logic
        const attemptTracking = async () => {
            try {
                // Wait for gtag to be available
                await waitForGtag();
                
                // Use window.gtag if available, otherwise fallback to gtag
                const gtagFn = window.gtag || gtag;
                
                if (typeof gtagFn !== 'function') {
                    console.error('‚ùå gtag is not a function');
                    return false;
                }

                // Generate consistent transaction ID if not provided
                const transactionId = additionalData.transaction_id || `trans_${Date.now()}`;

                let conversionId;
                let eventName;
                let eventData = {
                    'value': value,
                    'currency': 'USD',
                    'transaction_id': transactionId,
                    ...additionalData
                };

                switch (type) {
                    case 'signup':
                        conversionId = 'AW-17614436696/HLp9CM6Plq0bENjym89B';
                        eventName = 'sign_up';
                        eventData.method = 'clerk';
                        eventData.event_category = 'engagement';
                        eventData.event_label = 'user_signup';
                        break;
                    case 'monthly':
                        // Monthly subscription: $3.99/month
                        conversionId = 'AW-17614436696/wlmKCI_fiuwbENjym89B';
                        eventName = 'purchase';
                        eventData.transaction_id = transactionId;
                        eventData.event_category = 'ecommerce';
                        eventData.event_label = 'monthly_subscription';
                        eventData.value = 3.99;
                        value = 3.99; // Ensure value is set correctly
                        break;
                    case 'lifetime':
                        // Lifetime purchase: $24.00 one-time
                        conversionId = 'AW-17614436696/unsECLnWiewbENjym89B';
                        eventName = 'purchase';
                        eventData.transaction_id = transactionId;
                        eventData.event_category = 'ecommerce';
                        eventData.event_label = 'lifetime_purchase';
                        eventData.value = 24.0;
                        value = 24.0; // Ensure value is set correctly
                        break;
                    case 'subscription':
                        // Legacy/fallback - treat as monthly
                        conversionId = 'AW-17614436696/wlmKCI_fiuwbENjym89B';
                        eventName = 'purchase';
                        eventData.transaction_id = transactionId;
                        eventData.event_category = 'ecommerce';
                        eventData.event_label = 'pro_subscription';
                        break;
                    default:
                        console.error('‚ùå Unknown conversion type:', type);
                        return false;
                }

                // Track Google Ads conversion
                const conversionEvent = {
                    'send_to': conversionId,
                    'value': value,
                    'currency': 'USD',
                    'transaction_id': transactionId
                };
                
                console.log(`üì§ Sending Google Ads conversion event:`, conversionEvent);
                
                gtagFn('event', 'conversion', conversionEvent);
                
                console.log(`‚úÖ Google Ads conversion tracked: ${type}`, {
                    conversion_id: conversionId,
                    value: value,
                    currency: 'USD',
                    send_to: conversionId,
                    event_sent: true
                });

                // Track Google Analytics event
                gtagFn('event', eventName, eventData);

                console.log(`‚úÖ ${type} conversion tracked successfully to Google Ads and GA4`);
                return true;

            } catch (error) {
                console.error(`‚ùå Error tracking ${type} conversion:`, error);
                return false;
            }
        };

        // Execute tracking (async but don't block)
        attemptTracking().catch(err => {
            console.error(`‚ùå Failed to track ${type} conversion after retries:`, err);
        });

        return true; // Return immediately, tracking happens asynchronously
    }

    checkSignupSuccessRedirect() {
        // Check if user just signed up successfully or completed payment
        const urlParams = new URLSearchParams(window.location.search);
        const signupSuccess = urlParams.get('signup');
        const paymentSuccess = urlParams.get('payment');
        const premiumStatus = urlParams.get('premium');
        
        if (signupSuccess === 'success') {
            // Remove the parameter from URL without page reload
            const newUrl = window.location.pathname;
            window.history.replaceState({}, document.title, newUrl);
            
            // CRITICAL: Force check auth state after signup redirect
            // Wait for Clerk to hydrate, then update auth state
            const checkAuthAfterSignup = async () => {
                // Wait for Clerk to be ready
                await this.waitForClerk();
                
                // Give Clerk a moment to hydrate the user after redirect
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Force check auth state
                this.checkAuthState();
                
                // Wait a bit more and check again to ensure state is updated
                setTimeout(() => {
                    this.checkAuthState();
                    this.updateAuthState();
                }, 1000);
            };
            
            checkAuthAfterSignup();
            
            // Track successful signup conversion
            this.trackEvent('Signup Success', {
                conversion_type: 'guest_to_signup',
                user_journey: 'guest ‚Üí signup',
                source: 'clerk_signup',
                timestamp: new Date().toISOString()
            });
            
            // Track signup conversion
            this.trackConversion('signup');
            
            // üéØ Track User Signup event to Mixpanel
            if (window.mixpanelTracker) {
                window.mixpanelTracker.trackUserSignup('clerk');
                console.log('üìä User signup event tracked to Mixpanel');
            }
            
            // Trigger signup email sequence (wait for user to be available)
            setTimeout(() => {
                if (window.Clerk && window.Clerk.user) {
                    const userId = window.Clerk.user.id;
                    fetch('/api/triggers/on-signup', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ userId })
                    }).then(response => {
                        if (response.ok) {
                            console.log('‚úÖ Signup email sequence triggered');
                        } else {
                            console.error('‚ùå Failed to trigger signup email sequence');
                        }
                    }).catch(err => {
                        console.error('‚ùå Error triggering signup email:', err);
                    });
                }
            }, 2000);
            
            // Show success message for signup - DISABLED
            // setTimeout(() => {
            //     this.showSignupSuccessMessage();
            // }, 1000); // Small delay to let the page fully load
        }
        
        if (paymentSuccess === 'success' || premiumStatus === '1') {
            // Get the plan type from URL (monthly or lifetime)
            const planType = urlParams.get('plan') || 'monthly'; // Default to monthly for backwards compatibility
            const isLifetime = planType === 'lifetime';
            const conversionValue = isLifetime ? 24.0 : 3.99;
            
            // Remove the parameters from URL without page reload
            const newUrl = window.location.pathname;
            window.history.replaceState({}, document.title, newUrl);
            
            // Track successful subscription conversion
            this.trackEvent('Subscribe Success', {
                conversion_type: isLifetime ? 'lifetime_purchase' : 'monthly_subscription',
                plan_type: planType,
                user_journey: 'signup ‚Üí premium',
                source: 'stripe_payment',
                value: conversionValue,
                timestamp: new Date().toISOString()
            });
            
            // Track conversion with correct plan type and value
            // Monthly: $3.99 with label wlmKCI_fiuwbENjym89B
            // Lifetime: $24.0 with label unsECLnWiewbENjym89B
            console.log(`üéØ Tracking ${planType} conversion with value $${conversionValue}`);
            this.trackConversion(planType, conversionValue);
            
            // üéØ Track Subscription Upgrade event to Mixpanel
            if (window.mixpanelTracker) {
                window.mixpanelTracker.trackSubscriptionUpgrade(planType, conversionValue);
                console.log(`üìä ${planType} upgrade event tracked to Mixpanel`);
            }
            
            // Refresh premium status immediately and wait for webhook to update
            setTimeout(() => {
                this.updatePremiumUI(); // Refresh premium status
                
                // Force refresh Clerk user data
                if (window.Clerk && window.Clerk.user && typeof window.Clerk.user.reload === 'function') {
                    // Never allow Clerk reload to create an unhandled promise rejection during hydration.
                    Promise.resolve()
                        .then(() => window.Clerk.user.reload())
                        .catch((err) => console.warn('‚ö†Ô∏è Clerk.user.reload() failed (ignored):', err));
                }
                
                // If user is still not premium after 5 seconds, try to sync manually
                setTimeout(() => {
                    if (!this.isPremium) {
                        console.log('User still not premium after payment, attempting manual sync...');
                        this.attemptPremiumSync();
                    }
                }, 5000);
            }, 2000); // Wait 2 seconds for webhook to process
        }
    }

    showSignupSuccessMessage() {
        // Show success notification for signup
        const notification = document.createElement('div');
        notification.className = 'signup-success-notification';
        notification.innerHTML = `
            <div class="notification-content">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 12l2 2 4-4"/>
                    <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/>
                </svg>
                <span>Welcome to Superfocus! Your account has been created successfully.</span>
            </div>
        `;
        
        // Add styles
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            max-width: 400px;
        `;
        
        document.body.appendChild(notification);
        
        // Auto remove after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }

    showPaymentSuccessMessage() {
        // Note: Conversion tracking is now handled in checkSignupSuccessRedirect()
        // to avoid duplicate tracking
        
        // Show success notification for payment
        const notification = document.createElement('div');
        notification.className = 'payment-success-notification';
        notification.innerHTML = `
            <div class="notification-content">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M9 12l2 2 4-4"/>
                    <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/>
                </svg>
                <span>Payment successful! You now have Pro access to Superfocus.</span>
            </div>
        `;
        
        // Add styles
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            max-width: 400px;
        `;
        
        document.body.appendChild(notification);
        
        // Auto remove after 5 seconds
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 5000);
    }

    async attemptPremiumSync() {
        try {
            console.log('Attempting to sync premium status...');
            
            // Try to sync premium users from Stripe
            const response = await fetch('/api/sync-premium-users', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
            });
            
            if (response.ok) {
                console.log('Premium sync successful, updating UI...');
                
                // Force Clerk to reload user data
                if (window.Clerk && window.Clerk.user && typeof window.Clerk.user.reload === 'function') {
                    try {
                        await window.Clerk.user.reload();
                        console.log('Clerk user data reloaded');
                    } catch (error) {
                        console.log('Could not reload Clerk user:', error);
                    }
                }
                
                // Wait a bit for the sync to complete, then refresh
                setTimeout(() => {
                    this.updateAuthState();
                    this.updatePremiumUI();
                    
                    // Show success notification
                    this.showPremiumSyncSuccessMessage();
                }, 1000);
            } else {
                console.error('Premium sync failed:', response.status);
            }
        } catch (error) {
            console.error('Error during premium sync:', error);
        }
    }
    showPremiumSyncSuccessMessage() {
        // Intentionally disabled: UX request to remove this banner.
        return;
    }


    setupTodoistIntegrationControls() {
        const connectBtn = document.getElementById('connectTodoistBtn');
        const disconnectBtn = document.getElementById('disconnectTodoistBtn');
        const statusText = document.getElementById('todoistStatusText');
        
        if (!connectBtn || !disconnectBtn || !statusText) return;
        
        connectBtn.addEventListener('click', () => {
            this.trackEvent('Todoist Connect Clicked', {
                button_type: 'todoist_connect',
                source: 'settings_modal',
                user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                conversion_funnel: 'integration_interest'
            });
            // Add user ID to URL for server-side verification
            const userId = window.Clerk?.user?.id || '';
            const viewMode = localStorage.getItem('viewMode');
            
            console.log('üîó Connecting Todoist:', { 
                userId, 
                viewMode,
                clerkUser: window.Clerk?.user 
            });
            
            // Check if Developer Mode is active
            const devModeParam = viewMode === 'pro' ? '&devMode=pro&bypass=true' : '';
            
            // Let the server verify Pro status - it will redirect with error if not Pro
            window.location.href = `/api/todoist-auth-start?uid=${encodeURIComponent(userId)}${devModeParam}`;
        });

        disconnectBtn.addEventListener('click', async () => {
            try {
                await fetch('/api/todoist-disconnect', { method: 'POST' });
            } catch (_) {}
            statusText.textContent = 'Not connected';
            disconnectBtn.style.display = 'none';
            connectBtn.style.display = '';
            this.todoistTasks = [];
            this.todoistProjectsById = {};
        });

        // Fetch Tasks button removed - tasks are fetched automatically when connected

        // Check connection status and update UI
        (async () => {
            try {
                const resp = await fetch('/api/todoist-status');
                const json = await resp.json();
                const connected = !!json.connected;
                if (connected) {
                    statusText.textContent = 'Connected';
                    connectBtn.style.display = 'none';
                    disconnectBtn.style.display = '';
                    this.fetchTodoistData();
                } else {
                    statusText.textContent = 'Not connected';
                    connectBtn.style.display = '';
                    disconnectBtn.style.display = 'none';
                }
            } catch (_) {
                statusText.textContent = 'Not connected';
                connectBtn.style.display = '';
                disconnectBtn.style.display = 'none';
            }
        })();
    }

    setupNotionIntegrationControls() {
        const connectBtn = document.getElementById('connectNotionBtn');
        const disconnectBtn = document.getElementById('disconnectNotionBtn');
        const statusText = document.getElementById('notionStatusText');
        
        if (!connectBtn || !disconnectBtn || !statusText) return;
        
        connectBtn.addEventListener('click', () => {
            this.trackEvent('Notion Connect Clicked', {
                button_type: 'notion_connect',
                source: 'settings_modal',
                user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                conversion_funnel: 'integration_interest'
            });
            // Add user ID to URL for server-side verification
            const userId = window.Clerk?.user?.id || '';
            console.log('Connecting Notion:', { userId, clerkUser: window.Clerk?.user });
            
            // Check if Developer Mode is active
            const viewMode = localStorage.getItem('viewMode');
            const devModeParam = viewMode === 'pro' ? '&devMode=pro' : '';
            
            // Let the server verify Pro status - it will redirect with error if not Pro
            window.location.href = `/api/notion-auth-start?uid=${encodeURIComponent(userId)}${devModeParam}`;
        });

        disconnectBtn.addEventListener('click', async () => {
            try {
                await fetch('/api/notion-disconnect', { method: 'POST' });
            } catch (_) {}
            statusText.textContent = 'Not connected';
            disconnectBtn.style.display = 'none';
            connectBtn.style.display = '';
            this.notionPages = [];
        });

        // Check connection status and update UI
        (async () => {
            try {
                const resp = await fetch('/api/notion-status');
                const json = await resp.json();
                const connected = !!json.connected;
                if (connected) {
                    statusText.textContent = 'Connected';
                    connectBtn.style.display = 'none';
                    disconnectBtn.style.display = '';
                    this.fetchNotionData();
                } else {
                    statusText.textContent = 'Not connected';
                    connectBtn.style.display = '';
                    disconnectBtn.style.display = 'none';
                }
            } catch (_) {
                statusText.textContent = 'Not connected';
                connectBtn.style.display = '';
                disconnectBtn.style.display = 'none';
            }
        })();
    }

    async fetchNotionData() {
        if (!this.isAuthenticated || !this.user || !this.isPremiumUser()) {
            this.notionPages = [];
            return;
        }
        try {
            // Check if Developer Mode is active
            const viewMode = localStorage.getItem('viewMode');
            const userId = window.Clerk?.user?.id || '';
            
            // Build query params
            const params = new URLSearchParams();
            if (viewMode === 'pro') params.append('devMode', 'pro');
            if (userId) params.append('uid', userId);
            const queryString = params.toString() ? `?${params.toString()}` : '';
            
            console.log('Fetching Notion data with params:', queryString);
            
            const resp = await fetch(`/api/notion-pages${queryString}`);
            if (resp.ok) {
                const pages = await resp.json();
                this.notionPages = pages;
                console.log('Notion pages loaded:', pages.length);
            } else {
                console.error('Failed to fetch Notion pages:', resp.status, await resp.text());
                this.notionPages = [];
            }
        } catch (e) {
            console.error('Error fetching Notion data:', e);
            this.notionPages = [];
        }
    }

    checkAdminAccess() {
        // Hide Developer tab for all users (including jcjimenezglez@gmail.com)
        const developerNavItem = document.getElementById('developerNavItem');
        
        if (!developerNavItem) return;
        
        // Always hide Developer tab - no more admin access
        developerNavItem.style.display = 'none';
        console.log('‚ùå Developer tab hidden for all users');
    }

    async handleManageSubscription() {
        try {
            // Get user email for Stripe customer portal
            let userEmail = '';
            if (window.Clerk && window.Clerk.user) {
                userEmail = window.Clerk.user.primaryEmailAddress?.emailAddress || 
                           window.Clerk.user.emailAddresses?.[0]?.emailAddress || '';
            }
            
            if (!userEmail) {
                console.error('No user email found');
                return;
            }
            
            // Call Stripe customer portal API
            const response = await fetch('/api/customer-portal', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ email: userEmail })
            });
            
            if (response.ok) {
                const data = await response.json();
                if (data.url) {
                    window.location.href = data.url;
                } else {
                    console.error('No portal URL returned');
                }
            } else {
                console.error('Failed to create customer portal session');
            }
        } catch (error) {
            console.error('Error managing subscription:', error);
        }
    }

    setupViewModeButtons() {
        const guestModeBtn = document.getElementById('guestModeBtn');
        const freeModeBtn = document.getElementById('freeModeBtn');
        const proModeBtn = document.getElementById('proModeBtn');
        const applyViewModeBtn = document.getElementById('applyViewModeBtn');
        
        // Store selected mode (not applied yet)
        this.selectedViewMode = localStorage.getItem('viewMode') || 'guest';
        
        if (guestModeBtn) {
            guestModeBtn.addEventListener('click', () => {
                this.selectViewMode('guest');
            });
        }
        
        if (freeModeBtn) {
            freeModeBtn.addEventListener('click', () => {
                this.selectViewMode('free');
            });
        }
        
        if (proModeBtn) {
            proModeBtn.addEventListener('click', () => {
                this.selectViewMode('pro');
            });
        }
        
        if (applyViewModeBtn) {
            applyViewModeBtn.addEventListener('click', () => {
                this.applyViewMode();
            });
        }
        
        // Set initial active button based on current view mode
        this.updateViewModeButtons();
    }

    selectViewMode(mode) {
        // Just select the mode, don't apply yet
        this.selectedViewMode = mode;
        this.updateViewModeButtons();
    }

    applyViewMode() {
        const mode = this.selectedViewMode;
        localStorage.setItem('viewMode', mode);
        
        // Close settings modal
        this.hideSettingsModal();
        
        // Apply the selected mode
        if (mode === 'guest') {
            // Simulate guest user - logout completely
            try {
                if (window.Clerk && window.Clerk.signOut) {
                    window.Clerk.signOut();
                }
            } catch (_) {}
            this.isAuthenticated = false;
            this.user = null;
            // Clear Todoist tasks when switching to guest mode
            this.clearTodoistTasks();
            localStorage.removeItem('hasAccount');
            localStorage.setItem('isPremium', 'false');
            localStorage.setItem('hasPaidSubscription', 'false');
            this.updateAuthState();
        } else if (mode === 'free') {
            // Simulate free user - logged in but not premium
            this.isAuthenticated = true;
            this.user = { emailAddresses: [{ emailAddress: 'test@example.com' }] };
            localStorage.setItem('hasAccount', 'true');
            localStorage.setItem('isPremium', 'false');
            localStorage.setItem('hasPaidSubscription', 'false');
            this.updateAuthState();
        } else if (mode === 'pro') {
            // Simulate pro user - logged in and premium
            this.isAuthenticated = true;
            this.user = { emailAddresses: [{ emailAddress: 'test@example.com' }] };
            localStorage.setItem('hasAccount', 'true');
            localStorage.setItem('isPremium', 'true');
            localStorage.setItem('hasPaidSubscription', 'true');
            this.updateAuthState();
        }
    }

    updateViewModeButtons() {
        const currentMode = this.selectedViewMode || localStorage.getItem('viewMode') || 'guest';
        const guestModeBtn = document.getElementById('guestModeBtn');
        const freeModeBtn = document.getElementById('freeModeBtn');
        const proModeBtn = document.getElementById('proModeBtn');
        const currentViewModeText = document.getElementById('currentViewMode');
        
        // Update current mode text
        if (currentViewModeText) {
            currentViewModeText.textContent = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
        }
        
        // Remove active class from all buttons
        [guestModeBtn, freeModeBtn, proModeBtn].forEach(btn => {
            if (btn) btn.classList.remove('active');
        });
        
        // Add active class to current mode button
        if (currentMode === 'guest' && guestModeBtn) {
            guestModeBtn.classList.add('active');
        } else if (currentMode === 'free' && freeModeBtn) {
            freeModeBtn.classList.add('active');
        } else if (currentMode === 'pro' && proModeBtn) {
            proModeBtn.classList.add('active');
        }
    }

    calculateWeekHours(stats) {
        if (!stats.daily) return 0;
        
        const today = new Date();
        let weekHours = 0;
        
        for (let i = 0; i < 7; i++) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            const dateStr = date.toDateString();
            weekHours += stats.daily[dateStr] || 0;
        }
        
        return Math.round(weekHours * 10) / 10;
    }

    calculateCyclesCompleted(stats) {
        // Prefer the real completed cycles counter
        if (stats.completedCycles && stats.completedCycles > 0) {
            return stats.completedCycles;
        }
        // Fallback estimate if user had progress before this feature
        const totalHours = stats.totalHours || 0;
        const avgCycleHours = 2; // reasonable default
        return Math.max(0, Math.floor(totalHours / avgCycleHours));
    }

    getCurrentTechniqueName() {
        const selectedTechnique = localStorage.getItem('selectedTechnique');
        
        // Handle custom techniques
        if (selectedTechnique && selectedTechnique.startsWith('custom_')) {
            const customId = selectedTechnique.replace('custom_', '');
            try {
                const techniques = JSON.parse(localStorage.getItem('customTechniques') || '[]');
                const customTechnique = techniques.find(t => t.id === customId);
                return customTechnique ? customTechnique.name : 'Custom Technique';
            } catch (_) {
                return 'Custom Technique';
            }
        }
        
        if (selectedTechnique === 'custom') {
            const savedCustomTimer = localStorage.getItem('customTimer');
            if (savedCustomTimer) {
                try {
                    const customConfig = JSON.parse(savedCustomTimer);
                    return customConfig.name || 'Custom Timer';
                } catch (_) {
                    return 'Custom Timer';
                }
            }
            return 'Custom Timer';
        }
        
        const techniqueMap = {
            'pomodoro': 'Pomodoro',
            'sprint': 'Sprint',
            'focus': 'Focus',
            'flow': 'Flow State',
            'marathon': 'Marathon',
            'deepwork': 'Deep Work'
        };
        
        return techniqueMap[selectedTechnique] || 'Pomodoro';
    }

    getMostUsedTechnique(stats) {
        // Prefer accumulated technique time (focus + breaks)
        if (stats.techniqueTime && Object.keys(stats.techniqueTime).length > 0) {
            let mostUsed = '';
            let maxHours = -1;
            for (const [technique, hours] of Object.entries(stats.techniqueTime)) {
                if (hours > maxHours) {
                    maxHours = hours;
                    mostUsed = technique;
                }
            }
            return mostUsed || this.getCurrentTechniqueName();
        }

        // Fallback to count-based usage if old data
        if (stats.techniqueUsage && Object.keys(stats.techniqueUsage).length > 0) {
            let mostUsed = '';
            let maxCount = -1;
            for (const [technique, count] of Object.entries(stats.techniqueUsage)) {
                if (count > maxCount) {
                    maxCount = count;
                    mostUsed = technique;
                }
            }
            return mostUsed || this.getCurrentTechniqueName();
        }

        return this.getCurrentTechniqueName();
    }

    initializeCycleCounter() {
        if (this.isAuthenticated && this.achievementCounter) {
            this.updateFocusHoursDisplay();
        }
    }

    showTechniqueInfo(technique) {
        // Handle custom timer configuration
        if (technique === 'custom') {
            this.showCustomTimerModal();
            return;
        }
        
        const techniqueInfo = {
            'pomodoro': {
                title: 'Pomodoro Technique',
                description: 'The Pomodoro Technique is a time management method developed by Francesco Cirillo. It uses a timer to break work into intervals, traditionally 25 minutes in length, separated by short breaks. After 4 pomodoros, take a longer break of 15-30 minutes.',
                benefits: [
                    'Improves focus and concentration',
                    'Reduces mental fatigue',
                    'Increases productivity',
                    'Helps manage time effectively'
                ],
                videoId: 'IlU-zDU6aQ0'
            }
        };

        const info = techniqueInfo[technique];
        if (!info) return;

        // Create modal content
        const modalContent = `
            <div class="technique-info-modal">
                <button class="close-technique-info-x">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x">
                        <path d="M18 6 6 18"/>
                        <path d="m6 6 12 12"/>
                    </svg>
                </button>
                <h3>${info.title}</h3>
                <p class="technique-description">${info.description}</p>
                <div class="technique-video">
                    <iframe 
                        width="100%" 
                        height="200" 
                        src="https://www.youtube.com/embed/${info.videoId}" 
                        title="${info.title} Video"
                        frameborder="0" 
                        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                        allowfullscreen>
                    </iframe>
                </div>
                <div class="technique-benefits">
                    <h4>Benefits:</h4>
                    <ul>
                        ${info.benefits.map(benefit => `<li>${benefit}</li>`).join('')}
                    </ul>
                </div>
                <button class="close-technique-info">Got it</button>
            </div>
        `;

        // Create modal overlay
        const modalOverlay = document.createElement('div');
        modalOverlay.className = 'technique-info-overlay';
        modalOverlay.innerHTML = modalContent;
        document.body.appendChild(modalOverlay);

        // Show modal
        modalOverlay.style.display = 'flex';

        // Close modal functionality
        const closeBtn = modalOverlay.querySelector('.close-technique-info');
        const closeBtnX = modalOverlay.querySelector('.close-technique-info-x');
        
        closeBtn.addEventListener('click', (evt) => {
            // Prevent this click from bubbling to document listener
            evt.stopPropagation();
            document.body.removeChild(modalOverlay);
            // Keep dropdown open after closing modal
            if (this.techniqueDropdown) {
                this.techniqueDropdown.classList.add('open');
            }
        });
        
        closeBtnX.addEventListener('click', (evt) => {
            // Prevent this click from bubbling to document listener
            evt.stopPropagation();
            document.body.removeChild(modalOverlay);
            // Keep dropdown open after closing modal
            if (this.techniqueDropdown) {
                this.techniqueDropdown.classList.add('open');
            }
        });

        modalOverlay.addEventListener('click', (e) => {
            // Prevent bubbling for any click inside the modal content
            const inModal = e.target.closest && e.target.closest('.technique-info-modal');
            if (inModal) {
                e.stopPropagation();
                return;
            }
            if (e.target === modalOverlay) {
                e.stopPropagation();
                document.body.removeChild(modalOverlay);
                // Keep dropdown open after closing modal
                if (this.techniqueDropdown) {
                this.techniqueDropdown.classList.add('open');
            }
            }
        });

        // Initialize integration controls for Spotify similar to Todoist
        this.setupSpotifyIntegrationControls();
    }

    setupSpotifyIntegrationControls() {
        try {
            const connectBtn = document.getElementById('connectSpotifyBtn');
            const disconnectBtn = document.getElementById('disconnectSpotifyBtn');
            const openBtn = document.getElementById('openSpotifyModalBtn');
            const statusText = document.getElementById('spotifyStatusText');

            if (!connectBtn || !disconnectBtn || !openBtn || !statusText) return;

            // Check if this is jcjimenezglez@gmail.com and clear Spotify data
            const isSpecificUser = window.Clerk && window.Clerk.user && 
                (window.Clerk.user.primaryEmailAddress?.emailAddress === 'jcjimenezglez@gmail.com' ||
                 window.Clerk.user.emailAddresses?.[0]?.emailAddress === 'jcjimenezglez@gmail.com');
            
            if (isSpecificUser) {
                // Clear any Spotify-related localStorage data for this specific user
                try {
                    localStorage.removeItem('spotify_access_token');
                    localStorage.removeItem('spotify_refresh_token');
                    localStorage.removeItem('spotify_connected');
                    localStorage.removeItem('spotify_user_data');
                    console.log('‚úÖ Cleared Spotify data for jcjimenezglez@gmail.com');
                } catch (e) {
                    console.log('Error clearing Spotify data:', e);
                }
            }

            const refreshStatus = async () => {
                try {
                    // Skip Spotify API calls for jcjimenezglez@gmail.com to avoid timeouts
                    if (isSpecificUser) {
                        statusText.textContent = 'Not connected';
                        connectBtn.style.display = '';
                        disconnectBtn.style.display = 'none';
                        openBtn.style.display = 'none';
                        return;
                    }
                    
                    const resp = await fetch('/api/spotify-status');
                    const data = await resp.json();
                    if (data.connected) {
                        statusText.textContent = 'Connected';
                        connectBtn.style.display = 'none';
                        disconnectBtn.style.display = '';
                        openBtn.style.display = '';
                    } else {
                        statusText.textContent = 'Not connected';
                        connectBtn.style.display = '';
                        disconnectBtn.style.display = 'none';
                        openBtn.style.display = 'none';
                    }
                } catch (_) {
                    statusText.textContent = 'Not connected';
                    connectBtn.style.display = '';
                    disconnectBtn.style.display = 'none';
                    openBtn.style.display = 'none';
                }
            };

            connectBtn.addEventListener('click', async () => {
                // Skip Spotify auth for jcjimenezglez@gmail.com
                if (isSpecificUser) {
                    alert('Spotify integration is not available at the moment.');
                    return;
                }
                window.location.href = '/api/spotify-auth-start';
            });

            disconnectBtn.addEventListener('click', async () => {
                // Skip Spotify disconnect for jcjimenezglez@gmail.com
                if (isSpecificUser) {
                    alert('Spotify integration is not available at the moment.');
                    refreshStatus();
                    return;
                }
                await fetch('/api/spotify-disconnect');
                refreshStatus();
            });

            openBtn.addEventListener('click', () => {
                // Skip Spotify modal for jcjimenezglez@gmail.com
                if (isSpecificUser) {
                    alert('Spotify integration is not available at the moment.');
                    return;
                }
                this.showSpotifyModal();
            });

            refreshStatus();
        } catch (_) {}
    }

    showSpotifyModal() {
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';

        const modal = document.createElement('div');
        modal.className = 'focus-stats-modal';
        modal.style.maxWidth = '720px';
        modal.innerHTML = `
            <button class="close-focus-stats-x">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-icon lucide-x">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <h3>Spotify</h3>
            <div class="spotify-content">
                <div class="spotify-devices" id="spotifyDevices"></div>
                <div class="spotify-playlists" id="spotifyPlaylists"></div>
            </div>
        `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        const close = () => { try { document.body.removeChild(overlay); } catch (_) {} };
        modal.querySelector('.close-focus-stats-x').addEventListener('click', close);
        overlay.addEventListener('click', (e) => { if (e.target === overlay) close(); });

        // Load devices and playlists
        this.loadSpotifyDevices(modal);
        this.loadSpotifyPlaylists(modal);
    }

    async loadSpotifyDevices(modal) {
        const el = modal.querySelector('#spotifyDevices');
        
        // Check if this is jcjimenezglez@gmail.com and skip API calls
        const isSpecificUser = window.Clerk && window.Clerk.user && 
            (window.Clerk.user.primaryEmailAddress?.emailAddress === 'jcjimenezglez@gmail.com' ||
             window.Clerk.user.emailAddresses?.[0]?.emailAddress === 'jcjimenezglez@gmail.com');
        
        if (isSpecificUser) {
            el.innerHTML = '<div>Spotify integration not available</div>';
            return;
        }
        
        try {
            const resp = await fetch('/api/spotify-devices');
            const data = await resp.json();
            const devices = data.devices || [];
            el.innerHTML = '<h4>Devices</h4>' + (devices.length ? devices.map(d => `<div class="device" data-id="${d.id}">${d.is_active ? '‚Ä¢ ' : ''}${d.name}</div>`).join('') : '<div>No devices found. Open Spotify on a device.</div>');
        } catch (e) {
            el.innerHTML = '<div>Failed to load devices</div>';
        }
    }

    async loadSpotifyPlaylists(modal) {
        const el = modal.querySelector('#spotifyPlaylists');
        
        // Check if this is jcjimenezglez@gmail.com and skip API calls
        const isSpecificUser = window.Clerk && window.Clerk.user && 
            (window.Clerk.user.primaryEmailAddress?.emailAddress === 'jcjimenezglez@gmail.com' ||
             window.Clerk.user.emailAddresses?.[0]?.emailAddress === 'jcjimenezglez@gmail.com');
        
        if (isSpecificUser) {
            el.innerHTML = '<div>Spotify integration not available</div>';
            return;
        }
        
        try {
            const resp = await fetch('/api/spotify-playlists');
            const data = await resp.json();
            const items = data.items || [];
            el.innerHTML = '<h4>Playlists</h4>' + (items.length ? items.map(p => `<div class="playlist" data-uri="${p.uri}">${p.name}</div>`).join('') : '<div>No playlists</div>');

            el.querySelectorAll('.playlist').forEach(pl => {
                pl.addEventListener('click', async () => {
                    const uri = pl.getAttribute('data-uri');
                    // Find active device if any
                    let deviceId = '';
                    try {
                        const devResp = await fetch('/api/spotify-devices');
                        const devData = await devResp.json();
                        const active = (devData.devices || []).find(d => d.is_active) || (devData.devices || [])[0];
                        if (active) deviceId = active.id;
                    } catch (_) {}
                    await fetch('/api/spotify-play', { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ device_id: deviceId, context_uri: uri }) });
                });
            });
        } catch (e) {
            el.innerHTML = '<div>Failed to load playlists</div>';
        }
    }

    setupSpotifyInModal(modalOverlay) {}

    initSpotifyWebPlayerIfNeeded() {}

    async loadSpotifyDevicesInModal() {}

    async loadSpotifyPlaylistsInModal() {}

    async playSpotifyUri() {}

    async pauseSpotify() {}

    showCustomTimerModal() {
        // Check if modal exists (legacy code)
        if (!this.customTimerModal) {
            console.warn('customTimerModal not found - using showCustomForm instead');
            this.showCustomForm();
            return;
        }
        
        // Load saved custom timer data if it exists
        const savedCustomTimer = localStorage.getItem('customTimer');
        if (savedCustomTimer) {
            try {
                const customConfig = JSON.parse(savedCustomTimer);
                console.log('Loading custom timer for editing:', customConfig);
                
                // Populate form fields with saved values (check if elements exist)
                const nameInput = document.getElementById('customName');
                const focusInput = document.getElementById('focusTime');
                const breakInput = document.getElementById('breakTime');
                const longBreakInput = document.getElementById('longBreakTime');
                const cyclesInput = document.getElementById('cycles');
                
                if (nameInput) nameInput.value = customConfig.name || '';
                if (focusInput) focusInput.value = Math.round(customConfig.focusTime / 60) || 25;
                if (breakInput) breakInput.value = Math.round(customConfig.breakTime / 60) || 5;
                if (longBreakInput) longBreakInput.value = Math.round(customConfig.longBreakTime / 60) || 0;
                if (cyclesInput) cyclesInput.value = customConfig.cycles || 4;
            } catch (error) {
                console.error('Error loading custom timer for editing:', error);
                // Reset to default values if there's an error
                this.resetCustomTimerForm();
            }
        } else {
            // Reset to default values if no saved timer
            this.resetCustomTimerForm();
        }
        
        this.customTimerModal.style.display = 'flex';
        // Keep dropdown open
        if (this.techniqueDropdown) {
                this.techniqueDropdown.classList.add('open');
            }
        
        // Add real-time validation
        this.setupCustomTimerValidation();
    }

    hideCustomTimerModal() {
        if (!this.customTimerModal) {
            console.warn('customTimerModal not found');
            return;
        }
        this.customTimerModal.style.display = 'none';
        // Keep dropdown open
        if (this.techniqueDropdown) {
                this.techniqueDropdown.classList.add('open');
            }
    }

    resetCustomTimerForm() {
        // Add null checks for legacy form elements
        const nameInput = document.getElementById('customName');
        const focusInput = document.getElementById('focusTime');
        const breakInput = document.getElementById('breakTime');
        const longBreakInput = document.getElementById('longBreakTime');
        const cyclesInput = document.getElementById('cycles');
        
        if (nameInput) nameInput.value = '';
        if (focusInput) focusInput.value = 25;
        if (breakInput) breakInput.value = 5;
        if (longBreakInput) longBreakInput.value = 0;
        if (cyclesInput) cyclesInput.value = 4;
    }

    setupCustomTimerValidation() {
        const customNameInput = document.getElementById('customName');
        const focusTimeInput = document.getElementById('focusTime');
        const breakTimeInput = document.getElementById('breakTime');
        const longBreakTimeInput = document.getElementById('longBreakTime');
        const cyclesInput = document.getElementById('cycles');
        const saveButton = document.getElementById('saveCustomTimer');

        // Skip if legacy form elements don't exist
        if (!focusTimeInput || !breakTimeInput || !cyclesInput || !saveButton) {
            console.warn('Legacy timer form elements not found - skipping validation setup');
            return;
        }

        // Function to check all validations and enable/disable save button
        const validateAll = () => {
            const name = customNameInput ? customNameInput.value.trim() : '';
            const focusTime = parseInt(focusTimeInput.value) || 0;
            const breakTime = parseInt(breakTimeInput.value) || 0;
            const longBreakTime = parseInt(longBreakTimeInput?.value) || 0;
            const cycles = parseInt(cyclesInput.value) || 0;

            const hasErrors = 
                name.length === 0 || name.length > 10 ||
                focusTime < 1 || focusTime > 180 ||
                breakTime < 1 || breakTime > 60 ||
                longBreakTime < 0 || longBreakTime > 60 ||
                cycles < 1 || cycles > 10;

            saveButton.disabled = hasErrors;
        };

        // Custom Name validation (max 10 characters)
        customNameInput.addEventListener('input', (e) => {
            const value = e.target.value;
            const errorElement = document.getElementById('customNameError');
            
            if (value.length > 10) {
                e.target.classList.add('error');
                errorElement.style.display = 'block';
            } else {
                e.target.classList.remove('error');
                errorElement.style.display = 'none';
            }
            validateAll();
        });

        // Focus Time validation (max 180)
        focusTimeInput.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            const errorElement = document.getElementById('focusTimeError');
            
            if (value > 180) {
                e.target.classList.add('error');
                errorElement.style.display = 'block';
            } else {
                e.target.classList.remove('error');
                errorElement.style.display = 'none';
            }
            validateAll();
        });

        // Break Time validation (max 60)
        breakTimeInput.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            const errorElement = document.getElementById('breakTimeError');
            
            if (value > 60) {
                e.target.classList.add('error');
                errorElement.style.display = 'block';
            } else {
                e.target.classList.remove('error');
                errorElement.style.display = 'none';
            }
            validateAll();
        });

        // Long Break Time validation (max 60)
        longBreakTimeInput.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            const errorElement = document.getElementById('longBreakTimeError');
            
            if (value > 60) {
                e.target.classList.add('error');
                errorElement.style.display = 'block';
            } else {
                e.target.classList.remove('error');
                errorElement.style.display = 'none';
            }
            validateAll();
        });

        // Cycles validation (max 10)
        cyclesInput.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            const errorElement = document.getElementById('cyclesError');
            
            if (value > 10) {
                e.target.classList.add('error');
                errorElement.style.display = 'block';
            } else {
                e.target.classList.remove('error');
                errorElement.style.display = 'none';
            }
            validateAll();
        });

        // Initial validation
        validateAll();
    }
    saveCustomTimerConfig() {
        const name = document.getElementById('customName').value.trim();
        const focusTime = parseInt(document.getElementById('focusTime').value);
        const breakTime = parseInt(document.getElementById('breakTime').value);
        const longBreakTime = parseInt(document.getElementById('longBreakTime').value);
        const cycles = parseInt(document.getElementById('cycles').value);

        // Check for validation errors
        const hasErrors = document.querySelectorAll('.form-group input.error').length > 0;
        if (hasErrors) {
            alert('Please fix the validation errors before saving');
            return;
        }

        // Validation
        if (!name) {
            alert('Please enter a timer name');
            return;
        }

        if (name.length > 10) {
            alert('Timer name must be 10 characters or less');
            return;
        }

        if (focusTime < 1 || focusTime > 180) {
            alert('Focus time must be between 1 and 180 minutes');
            return;
        }

        if (breakTime < 1 || breakTime > 60) {
            alert('Break time must be between 1 and 60 minutes');
            return;
        }

        if (longBreakTime < 0 || longBreakTime > 60) {
            alert('Long break time must be between 0 and 60 minutes');
            return;
        }

        if (cycles < 1 || cycles > 10) {
            alert('Number of cycles must be between 1 and 10');
            return;
        }

        // Save custom timer configuration
        const customConfig = {
            name: name,
            focusTime: focusTime * 60, // Convert to seconds
            breakTime: breakTime * 60,
            longBreakTime: longBreakTime * 60,
            cycles: cycles
        };

        localStorage.setItem('customTimer', JSON.stringify(customConfig));

        // Load the custom timer
        this.loadCustomTechnique(customConfig);
        
        // Close modal and dropdown
        this.hideCustomTimerModal();
        this.closeDropdown();
    }

    loadCustomTechnique(config) {
        this.workTime = config.focusTime;
        this.shortBreakTime = config.breakTime;
        this.longBreakTime = config.longBreakTime;
        this.sessionsPerCycle = config.cycles; // Set the number of sessions
        
        // Build cycle sections using the shared helper function
        this.buildCycleSections();

        // Calculate required focus time for complete cycle
        this.calculateRequiredFocusTime();

        // Update UI (sidebar)
        if (this.techniqueTitle) {
            // Preserve the chevron icon when updating the title
            const chevronIcon = this.techniqueTitle.querySelector('svg');
            this.techniqueTitle.innerHTML = config.name;
            if (chevronIcon) {
                this.techniqueTitle.appendChild(chevronIcon);
            }
        }
        
        // Update timer technique button (center top)
        if (this.timerTechniqueName) {
            this.timerTechniqueName.textContent = config.name;
        }
        if (this.techniqueDescription) {
            this.techniqueDescription.textContent = `${config.focusTime/60} min focus, ${config.breakTime/60} min break${this.longBreakTime > 0 ? `, ${this.longBreakTime/60} min long break` : ''}`;
        }
        
        // Update dropdown item to show custom name
        const customItem = document.querySelector('[data-technique="custom"]');
        if (customItem) {
            const titleElement = customItem.querySelector('.item-title');
            const descElement = customItem.querySelector('.item-description');
            if (titleElement) titleElement.textContent = config.name;
            if (descElement) descElement.textContent = `${config.focusTime/60} min focus, ${config.breakTime/60} min break${this.longBreakTime > 0 ? `, ${this.longBreakTime/60} min long break` : ''}`;
        }
        
        // Mark custom timer as selected and unmark others
        this.markTechniqueAsSelected('custom');
        
        // Save custom technique as selected
        localStorage.setItem('selectedTechnique', 'custom');
        
        // Reset to first section
        this.currentSection = 1;
        this.timeLeft = this.cycleSections[0].duration;
        this.isWorkSession = this.cycleSections[0].type === 'work';
        this.isLongBreak = this.cycleSections[0].type === 'long-break';
        
        // Update progress ring and display
        this.updateProgressRing();
        this.updateDisplay();
        this.updateProgress();
        this.updateSections();
        this.updateSessionInfo();
        
        // Close dropdown
        this.closeDropdown();
    }

    markTechniqueAsSelected(technique) {
        // Remove selected class from all dropdown items
        const allItems = document.querySelectorAll('.dropdown-item');
        allItems.forEach(item => item.classList.remove('selected'));
        
        // Add selected class to the specified technique
        const selectedItem = document.querySelector(`[data-technique="${technique}"]`);
        if (selectedItem) {
            selectedItem.classList.add('selected');
        }
    }

    loadSavedCustomTimer() {
        const savedCustomTimer = localStorage.getItem('customTimer');
        if (!savedCustomTimer) return;
        try {
            const customConfig = JSON.parse(savedCustomTimer);
            // Only update the dropdown item's text so the user sees their custom config
            const customItem = document.querySelector('[data-technique="custom"]');
            if (customItem) {
                const titleElement = customItem.querySelector('.item-title');
                const descElement = customItem.querySelector('.item-description');
                if (titleElement) titleElement.textContent = customConfig.name;
                if (descElement) descElement.textContent = `${customConfig.focusTime/60} min focus, ${customConfig.breakTime/60} min break${customConfig.longBreakTime > 0 ? `, ${customConfig.longBreakTime/60} min long break` : ''}`;
            }
            // Do NOT auto-select here. Selection is handled by loadLastSelectedTechnique()
        } catch (error) {
            console.error('Error reading custom timer:', error);
            localStorage.removeItem('customTimer');
        }
    }

    loadLastSelectedTechnique() {
        const lastSelectedTechnique = localStorage.getItem('selectedTechnique');
        const savedCustomTimer = localStorage.getItem('customTimer');
        
        // If the last selected was custom and we have a saved config, load it
        if (lastSelectedTechnique === 'custom') {
            if (savedCustomTimer) {
                try {
                    const customConfig = JSON.parse(savedCustomTimer);
                    this.loadCustomTechnique(customConfig);
                    return;
                } catch (e) {
                    console.error('Invalid custom timer config, defaulting to Pomodoro');
                    localStorage.removeItem('customTimer');
                }
            }
            // If no valid custom config, fall back to default
            this.loadDefaultTechnique();
            return;
        }

        // If the last selected is a built-in technique
        if (lastSelectedTechnique) {
            const techniqueItem = document.querySelector(`[data-technique="${lastSelectedTechnique}"]`);
            if (techniqueItem) {
                this.selectTechnique(techniqueItem);
                return;
            }
        }

        // Default when nothing saved or item not found
        this.loadDefaultTechnique();
    }

    loadDefaultTechnique() {
        const pomodoroItem = document.querySelector('[data-technique="pomodoro"]');
        if (pomodoroItem) {
            this.selectTechnique(pomodoroItem);
        }
    }
    
    setDefaultTechniqueForGuest() {
        // Set Pomodoro as selected in the main technique dropdown for guest users
        if (this.techniqueTitle) {
            this.techniqueTitle.innerHTML = `Pomodoro<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down-icon lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg>`;
        }
        
        // Mark Pomodoro as selected in dropdown items
        if (this.dropdownItems) {
            this.dropdownItems.forEach(item => {
                item.classList.remove('selected');
                if (item.dataset.technique === 'pomodoro') {
                    item.classList.add('selected');
                }
            });
        }
        
        // Set current technique key
        this.currentTechniqueKey = 'pomodoro';
        
        // For guest users, ensure Pomodoro stays active in settings panel
        // Don't remove the active class that's already in the HTML
        console.log('‚úÖ Pomodoro set as default technique for guest user');
    }
    

    pauseSpotify() {
        // Implement logic to pause Spotify playback
        console.log('Spotify paused');
    }

    playSpotifyUri(uri) {
        // Implement logic to play a specific Spotify URI
        console.log('Playing Spotify URI:', uri);
    }

    // Show keyboard shortcut hint (only once per session)
    showKeyboardHint() {
        // Only show hint once per session
        if (sessionStorage.getItem('keyboardHintShown')) return;
        
        // Create hint tooltip
        const hint = document.createElement('div');
        hint.className = 'keyboard-hint';
        hint.innerHTML = `
            <span>üí° Tip: Press <kbd>R</kbd> to reset timer</span>
        `;
        
        document.body.appendChild(hint);
        
        // Function to position hint above Play/Pause button
        const positionHint = () => {
            if (!this.startPauseBtn) return;
            const buttonRect = this.startPauseBtn.getBoundingClientRect();
            const hintRect = hint.getBoundingClientRect();
            
            // Position above the button, centered horizontally
            const left = buttonRect.left + (buttonRect.width / 2) - (hintRect.width / 2);
            const top = buttonRect.top - hintRect.height - 20; // 20px gap above button
            
            hint.style.left = `${left}px`;
            hint.style.top = `${top}px`;
        };
        
        // Position initially
        setTimeout(() => {
            positionHint();
            hint.classList.add('show');
        }, 100);
        
        // Update position on window resize
        const resizeHandler = () => positionHint();
        window.addEventListener('resize', resizeHandler);
        
        // Hide after 4 seconds
        setTimeout(() => {
            hint.classList.remove('show');
            setTimeout(() => {
                hint.remove();
                window.removeEventListener('resize', resizeHandler);
            }, 300);
        }, 4000);
        
        // Mark as shown for this session
        sessionStorage.setItem('keyboardHintShown', 'true');
    }


    // Save timer state to sessionStorage (persists on reload/navigation but not on tab close)
    saveTimerState() {
        // Save state as soon as timer has any progress
        const section = this.cycleSections[this.currentSection - 1];
        if (!section) return;
        
        const sectionDuration = section.duration;
        const timeElapsed = sectionDuration - this.timeLeft;
        
        // Don't save if less than 1 second has elapsed
        if (timeElapsed < 1) return;
        
        // Don't save if in "Ready to focus" state
        const isAtInitialTime = this.timeLeft === sectionDuration;
        if (!this.isRunning && isAtInitialTime && this.isWorkSession) return;
        
        const state = {
            currentSection: this.currentSection,
            timeLeft: this.timeLeft,
            isRunning: this.isRunning, // Save actual running state
            isWorkSession: this.isWorkSession,
            isLongBreak: this.isLongBreak,
            currentTaskIndex: this.currentTaskIndex,
            currentTaskName: this.currentTaskName,
            selectedTechnique: this.selectedTechnique?.name || 'Pomodoro',
            selectedTheme: this.currentTheme || 'lofi', // Save current theme
            timestamp: Date.now(),
            sectionDuration: sectionDuration,
            timeElapsed: timeElapsed
        };
        
        sessionStorage.setItem('timerState', JSON.stringify(state));
    }

    // Load timer state from sessionStorage (persists on reload/navigation but not on tab close)
    loadTimerState() {
        // Only restore session for authenticated users
        if (!this.isAuthenticated) {
            sessionStorage.removeItem('timerState');
            return false;
        }
        
        const savedState = sessionStorage.getItem('timerState');
        if (!savedState) return false;
        
        try {
            const state = JSON.parse(savedState);
            
            // Check if state is recent (within last 30 minutes)
            const timeDiff = Date.now() - state.timestamp;
            if (timeDiff > 30 * 60 * 1000) {
                sessionStorage.removeItem('timerState');
                return false;
            }
            
            // Check if at least 1 second had elapsed when saved
            if (state.timeElapsed < 1) {
                sessionStorage.removeItem('timerState');
                return false;
            }
            
            // Check if window was closed (sessionStorage cleared) vs just refreshed
            const windowClosed = !sessionStorage.getItem('windowActive');
            if (windowClosed) {
                console.log('Window was closed, resetting timer');
                sessionStorage.removeItem('timerState');
                return false;
            }
            
            // Always continue session without modal (window was not closed)
            console.log('Continuing session automatically (window not closed)');
            this.restoreTimerState(state);
            
            return true;
        } catch (error) {
            console.error('Error loading timer state:', error);
            sessionStorage.removeItem('timerState');
            return false;
        }
    }


    // Restore timer state
    restoreTimerState(state) {
        // Restore technique if different
        if (state.selectedTechnique !== this.selectedTechnique?.name) {
            const techniqueItem = Array.from(document.querySelectorAll('.technique-item'))
                .find(item => item.dataset.technique === state.selectedTechnique);
            if (techniqueItem) {
                this.selectTechnique(techniqueItem);
            }
        }
        
        // Restore state
        this.currentSection = state.currentSection;
        this.timeLeft = state.timeLeft;
        this.isWorkSession = state.isWorkSession;
        this.isLongBreak = state.isLongBreak;
        this.currentTaskIndex = state.currentTaskIndex;
        this.currentTaskName = state.currentTaskName;
        
        // Restore theme if it was saved in the state
        if (state.selectedTheme) {
            console.log('üé® Restoring theme from saved state:', state.selectedTheme);
            this.applyTheme(state.selectedTheme);
        }
        
        // Always restore as paused (user decides when to continue)
        this.isRunning = false;
        
        // Update UI
        this.updateDisplay();
        this.updateProgressRing();
        this.updateProgress();
        this.updateSessionInfo();
        this.updateNavigationButtons();
        this.updateCurrentTaskFromQueue();
        
        // Show user that timer was paused due to refresh
        if (state.isRunning) {
            console.log('Timer was running, paused due to refresh - user can resume when ready');
        }
        
        // Clear saved state
        sessionStorage.removeItem('timerState');
        
        console.log('Timer state restored successfully:', {
            section: this.currentSection,
            timeLeft: this.timeLeft,
            technique: state.selectedTechnique,
            wasRunning: state.isRunning,
            restoredAsPaused: true
        });
    }

    // Clear timer state from sessionStorage
    clearTimerState() {
        sessionStorage.removeItem('timerState');
    }

    // Show reset confirmation modal
    showResetConfirmationModal() {
        // Don't show if timer is at initial state
        const section = this.cycleSections[this.currentSection - 1];
        if (!section) return;
        
        const sectionDuration = section.duration;
        const timeElapsed = sectionDuration - this.timeLeft;
        
        // If less than 1 second elapsed, just reset without confirmation
        if (timeElapsed < 1) {
            this.resetTimer();
            return;
        }
        
        const overlay = document.createElement('div');
        overlay.className = 'upgrade-modal-overlay';
        overlay.style.display = 'flex';
        
        const modal = document.createElement('div');
        modal.className = 'upgrade-modal reset-confirmation-modal';
        modal.innerHTML = `
            <button class="close-upgrade-x">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <div class="upgrade-content">
                <div class="upgrade-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                        <path d="M3 3v5h5"/>
                    </svg>
                </div>
                <h3>Reset Timer?</h3>
                <p>Are you sure you want to reset the timer? Your current progress will be lost.</p>
                <div class="upgrade-buttons">
                    <button class="upgrade-btn" id="confirmResetBtn">Yes, Reset</button>
                    <button class="cancel-btn" id="cancelResetBtn">Cancel</button>
                </div>
            </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        // Event listeners
        setTimeout(() => {
            const closeBtn = modal.querySelector('.close-upgrade-x');
            const confirmBtn = modal.querySelector('#confirmResetBtn');
            const cancelBtn = modal.querySelector('#cancelResetBtn');
            
            const close = () => {
                overlay.remove();
            };
            
            const confirmReset = () => {
                this.resetTimer();
                overlay.remove();
            };
            
            if (closeBtn) closeBtn.addEventListener('click', close);
            if (cancelBtn) cancelBtn.addEventListener('click', close);
            if (confirmBtn) confirmBtn.addEventListener('click', confirmReset);
            
            // Close on overlay click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) close();
            });
        }, 100);
    }
    
    // Render tasks in side panel - use exact same logic as showTaskListModal
    renderTasksInSidePanel() {
        console.log('üîµ renderTasksInSidePanel called');
        const panel = document.getElementById('taskSidePanel');
        if (!panel) {
            console.error('‚ùå Panel not found!');
            return;
        }
        console.log('‚úÖ Panel found:', panel);
        
        // Check if user is authenticated and show/hide sections accordingly
        const isFreeUser = this.isAuthenticated && this.user && !this.isPremiumUser();
        const isGuest = !this.isAuthenticated || !this.user;
        
        // Show/hide sections based on user status
        const importSection = document.getElementById('importTodoistSection');
        
        if (importSection) {
            importSection.style.display = (this.isAuthenticated && this.user && this.isPremiumUser()) ? 'block' : 'none';
        }
        
        const listEl = panel.querySelector('#todoistTasksList');
        console.log('üîµ listEl:', listEl);
        
        // Detect current active tab from DOM
        const activeTabEl = panel.querySelector('.task-tab.active');
        let currentTab = activeTabEl ? activeTabEl.dataset.tab : 'todo'; // Default to todo tab
        
        const renderTasks = () => {
            console.log('üîµ renderTasks called, currentTab:', currentTab);
            
            // Clear only task items and headers, preserve the form
            const taskItems = listEl.querySelectorAll('.task-item, .empty-state, .task-source-header');
            taskItems.forEach(item => item.remove());
            
            const allTasks = this.getAllTasks();
            
            // Filter tasks based on current tab
            let filteredTasks = allTasks;
            if (currentTab === 'todo') {
                filteredTasks = allTasks.filter(task => !task.completed);
            } else if (currentTab === 'done') {
                filteredTasks = allTasks.filter(task => task.completed);
            }
            
            if (filteredTasks.length === 0) {
                if (currentTab === 'done') {
                    const emptyState = document.createElement('div');
                    emptyState.className = 'empty-state';
                    emptyState.innerHTML = `
                        <div class="empty-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 12l2 2 4-4"/>
                                <path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"/>
                            </svg>
                        </div>
                        <div class="empty-text">No completed tasks yet</div>
                        <div class="empty-subtext">Complete some tasks to see them here</div>
                    `;
                    listEl.appendChild(emptyState);
                }
                return;
            }
            
            // Group tasks by source
            const tasksBySource = {
                'local': [],
                'todoist': [],
                'notion': []
            };
            
            filteredTasks.forEach(task => {
                const source = task.source || 'local';
                if (tasksBySource[source]) {
                    tasksBySource[source].push(task);
                } else {
                    tasksBySource['local'].push(task);
                }
            });
            
            // Apply saved task order within each source
            const savedOrder = this.getTaskOrder();
            Object.keys(tasksBySource).forEach(source => {
                const tasks = tasksBySource[source];
                if (savedOrder.length > 0 && tasks.length > 0) {
                    const taskMap = new Map(tasks.map(task => [task.id, task]));
                    const orderedTasks = [];
                    savedOrder.forEach(orderItem => {
                        if (taskMap.has(orderItem.id)) {
                            orderedTasks.push(taskMap.get(orderItem.id));
                            taskMap.delete(orderItem.id);
                        }
                    });
                    taskMap.forEach(task => orderedTasks.push(task));
                    tasksBySource[source] = orderedTasks;
                }
            });
            
            // Get the form element to insert before it (if it exists)
            const addTaskFormEl = listEl.querySelector('#addTaskForm');
            
            // Source labels
            const sourceConfig = {
                'local': { label: 'My Tasks' },
                'todoist': { label: 'From Todoist' },
                'notion': { label: 'From Notion' }
            };
            
            // Check how many sources have tasks
            const sourcesWithTasks = Object.keys(tasksBySource).filter(source => tasksBySource[source].length > 0);
            const showHeaders = sourcesWithTasks.length > 1 || (sourcesWithTasks.length === 1 && sourcesWithTasks[0] !== 'local');
            
            // Render tasks grouped by source
            let globalIndex = 0;
            ['local', 'todoist', 'notion'].forEach(source => {
                const tasks = tasksBySource[source];
                if (tasks.length === 0) return;
                
                // Create source header (only if needed)
                if (showHeaders) {
                    const sourceHeader = document.createElement('div');
                    sourceHeader.className = 'task-source-header';
                    const config = sourceConfig[source];
                    sourceHeader.innerHTML = `
                        <span class="source-label">${config.label}</span>
                        <span class="source-count">${tasks.length}</span>
                    `;
                    
                    // Insert before the form if it exists, otherwise append
                    if (addTaskFormEl) {
                        listEl.insertBefore(sourceHeader, addTaskFormEl);
                    } else {
                        listEl.appendChild(sourceHeader);
                    }
                }
                
                // Render tasks for this source
                tasks.forEach((task) => {
                    const item = document.createElement('div');
                    item.className = 'task-item';
                    // Disable drag & drop in Done tab (read-only)
                    item.draggable = currentTab !== 'done';
                    item.dataset.taskId = task.id;
                    item.dataset.index = globalIndex++;
                    item.dataset.source = source;
                    
                    const taskConfig = this.getTaskConfig(task.id);
                    const sessions = taskConfig.sessions || 1;
                    const completedSessions = taskConfig.completedSessions || 0;
                    const totalSessions = taskConfig.sessions || 1;
                    const isCompleted = task.completed || (completedSessions >= totalSessions);
                    
                    // Check if task should be disabled for Guest users
                    const isGuest = !this.isAuthenticated || !this.user;
                    const shouldDisableForGuest = isGuest && globalIndex > 1; // Disable tasks 2+ for guests
                    
                    // Format completed date if task is completed
                    const completedDateHtml = isCompleted && task.completedAt ? 
                        `<div class="task-completed-date">${new Date(task.completedAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' })}</div>` : '';
                    
                    // Disable checkbox in Done tab (read-only)
                    const checkboxDisabled = (currentTab === 'done' || shouldDisableForGuest) ? 'disabled' : '';
                    
                    const itemContent = `
                        <div class="task-checkbox ${(currentTab === 'done' || shouldDisableForGuest) ? 'disabled' : ''}">
                            <input type="checkbox" id="task-${task.id}" ${isCompleted ? 'checked' : ''} ${checkboxDisabled}>
                            <label for="task-${task.id}"></label>
                        </div>
                        <div class="task-content">
                            <div class="task-title" style="${shouldDisableForGuest ? 'opacity: 0.5;' : ''}">
                                ${task.content || '(untitled)'}
                                ${shouldDisableForGuest ? '<span style="font-size: 12px; margin-left: 8px;">(Sign up required)</span>' : ''}
                            </div>
                            ${completedDateHtml}
                        </div>
                        <div class="task-progress">
                            <span class="progress-text" style="${shouldDisableForGuest ? 'opacity: 0.5;' : ''}">${completedSessions}/${totalSessions}</span>
                        </div>
                        ${!isCompleted && !shouldDisableForGuest ? `
                        <div class="task-menu" data-task-id="${task.id}">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="1"/>
                                <circle cx="19" cy="12" r="1"/>
                                <circle cx="5" cy="12" r="1"/>
                            </svg>
                        </div>
                        ` : ''}
                    `;
                    
                    item.innerHTML = itemContent;
                    
                    // Add disabled class for guest users
                    if (shouldDisableForGuest) {
                        item.classList.add('disabled-for-guest');
                    }
                    
                    // Add completed class if task is completed
                    if (isCompleted) {
                        item.classList.add('completed');
                    }
                    
                    // Add read-only class in Done tab
                    if (currentTab === 'done') {
                        item.classList.add('read-only');
                    }
                    
                    // Only apply 'selected' class if task is NOT completed
                    if (taskConfig.selected && !isCompleted) {
                        item.classList.add('selected');
                    }
                    
                    // Insert before the form if it exists, otherwise append
                    if (addTaskFormEl) {
                        listEl.insertBefore(item, addTaskFormEl);
                    } else {
                        listEl.appendChild(item);
                    }
                });
            });
            
            this.setupTaskEventListeners(panel);
            this.setupDragAndDrop(panel);
            
            // Setup task menu (3 dots) click handlers for editing
            const taskMenus = panel.querySelectorAll('.task-menu');
            taskMenus.forEach(menu => {
                menu.replaceWith(menu.cloneNode(true));
            });
            const newTaskMenus = panel.querySelectorAll('.task-menu');
            newTaskMenus.forEach(menu => {
                menu.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('Task menu clicked');
                    const taskId = menu.dataset.taskId;
                    const addTaskForm = panel.querySelector('#addTaskForm');
                    const addTaskBtn = panel.querySelector('#showAddTaskForm');
                    if (!addTaskForm || !addTaskBtn) return;
                    
                    // Get task data
                    const task = this.getLocalTasks().find(t => t.id === taskId);
                    if (!task) return; // Only local tasks can be edited
                    
                    const config = this.getTaskConfig(taskId);
                    const taskItem = menu.closest('.task-item');
                    
                    // Enter edit mode
                    this.editingTaskId = taskId;
                    
                    // Hide the task item being edited
                    if (taskItem) {
                        taskItem.style.display = 'none';
                        // Move form right after the hidden task item
                        taskItem.parentNode.insertBefore(addTaskForm, taskItem.nextSibling);
                    }
                    
                    addTaskForm.style.display = 'block';
                    addTaskBtn.disabled = true;
                    
                    // Fill form with task data
                    const taskInput = addTaskForm.querySelector('#taskDescription');
                    const pomodorosInput = addTaskForm.querySelector('#pomodorosCount');
                    const deleteBtn = addTaskForm.querySelector('#deleteTask');
                    const cancelBtn = addTaskForm.querySelector('#cancelAddTask');
                    
                    if (taskInput) taskInput.value = task.content || '';
                    if (pomodorosInput) pomodorosInput.value = String(config.sessions || 1);
                    if (deleteBtn) deleteBtn.style.display = '';
                    if (cancelBtn) cancelBtn.style.display = '';
                    if (taskInput) taskInput.focus();
                    
                    // Scroll form into view
                    try { 
                        addTaskForm.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); 
                    } catch (_) {}
                });
            });
        };
        
        // Setup add task button
        const addTaskBtn = panel.querySelector('#showAddTaskForm');
        const addTaskForm = panel.querySelector('#addTaskForm');
        if (addTaskBtn && addTaskForm) {
            addTaskBtn.replaceWith(addTaskBtn.cloneNode(true));
            const newAddTaskBtn = panel.querySelector('#showAddTaskForm');
            newAddTaskBtn.addEventListener('click', () => {
                console.log('Add Task button clicked');
                
                // Track Add Task button click in Tasks panel
                this.trackEvent('Add Task Button Clicked', {
                    button_type: 'add_task',
                    source: 'tasks_panel',
                    user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                    task_count: this.getLocalTasks().length,
                    conversion_funnel: 'task_creation'
                });
                
                // Check task limit BEFORE showing the form
                // Guest users cannot create tasks at all - must sign up
                if (!this.isAuthenticated) {
                    this.showTaskLimitModal();
                    return;
                }
                
                // Only count tasks in To-do (not completed), not tasks in Done
                const currentTasks = this.getLocalTasks().filter(task => !task.completed);
                
                // Define limits based on user type
                let taskLimit;
                if (this.isAuthenticated && !this.isPro) {
                    // Free users: 2 tasks
                    taskLimit = 2;
                } else {
                    // Pro users: unlimited
                    taskLimit = Infinity;
                }
                
                if (currentTasks.length >= taskLimit) {
                    this.showTaskLimitModal();
                    return;
                }
                
                this.editingTaskId = null;
                addTaskForm.style.display = 'block';
                newAddTaskBtn.disabled = true;
                const taskInput = addTaskForm.querySelector('#taskDescription');
                const pomodorosInput = addTaskForm.querySelector('#pomodorosCount');
                const deleteBtn = addTaskForm.querySelector('#deleteTask');
                const cancelBtn = addTaskForm.querySelector('#cancelAddTask');
                const saveBtn = addTaskForm.querySelector('#saveTask');
                if (taskInput) taskInput.value = '';
                if (pomodorosInput) pomodorosInput.value = '1';
                if (deleteBtn) deleteBtn.style.display = 'none';
                const count = (this.getAllTasks() || []).length;
                if (cancelBtn) cancelBtn.style.display = count === 0 ? 'none' : '';
                if (saveBtn) saveBtn.disabled = !taskInput || !taskInput.value.trim();
                if (taskInput) taskInput.focus();
            });
        }
        
        // Initial UI state
        if (addTaskBtn && addTaskForm) {
            const initialTasks = this.getAllTasks();
            if (Array.isArray(initialTasks) && initialTasks.length === 0) {
                addTaskForm.style.display = 'block';
                addTaskBtn.disabled = true;
                const cancelBtn0 = addTaskForm.querySelector('#cancelAddTask');
                const saveBtn0 = addTaskForm.querySelector('#saveTask');
                const taskInput0 = addTaskForm.querySelector('#taskDescription');
                if (cancelBtn0) cancelBtn0.style.display = 'none';
                if (saveBtn0) saveBtn0.disabled = true;
                if (taskInput0) taskInput0.focus();
            } else {
                addTaskForm.style.display = 'none';
                addTaskBtn.disabled = false;
            }
        }
        
        // Setup tabs FIRST - remove all old listeners
        const tabs = panel.querySelectorAll('.task-tab');
        console.log('üîµ Found tabs:', tabs.length);
        tabs.forEach(tab => {
            const newTab = tab.cloneNode(true);
            tab.parentNode.replaceChild(newTab, tab);
        });
        
        // Add new listeners to fresh tabs
        const newTabs = panel.querySelectorAll('.task-tab');
        console.log('üîµ Setting up listeners for', newTabs.length, 'tabs');
        newTabs.forEach(tab => {
            tab.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                console.log('Tab clicked:', tab.dataset.tab);
                
                // Update active states
                newTabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentTab = tab.dataset.tab;
                
                const addTaskForm = panel.querySelector('#addTaskForm');
                const addTaskBtn = panel.querySelector('#showAddTaskForm');
                const addTaskSection = panel.querySelector('.add-task-section');
                
                if (currentTab === 'done') {
                    // Hide add task elements in Done tab
                    if (addTaskForm) addTaskForm.style.display = 'none';
                    if (addTaskSection) addTaskSection.style.display = 'none';
                } else {
                    // Show add task elements in To-do tab
                    if (addTaskSection) addTaskSection.style.display = 'block';
                    if (addTaskForm && addTaskBtn) {
                        const tasks = this.getAllTasks();
                        if (Array.isArray(tasks) && tasks.length === 0) {
                            addTaskForm.style.display = 'block';
                            addTaskBtn.disabled = true;
                        } else {
                            addTaskForm.style.display = 'none';
                            addTaskBtn.disabled = false;
                        }
                    }
                }
                
                // Re-render tasks for the selected tab
                renderTasks();
            });
        });
        
        // Setup form controls for the panel
        this.setupAddTaskFormControlsForPanel(panel, renderTasks);
        
        // Setup task options dropdown
        const taskOptionsBtn = panel.querySelector('#taskOptionsBtn');
        const taskOptionsDropdown = panel.querySelector('#taskOptionsDropdown');
        const clearAllBtn = panel.querySelector('#clearAllTasksBtn');
        const clearDoneBtn = panel.querySelector('#clearDoneTasksBtn');
        
        if (taskOptionsBtn && taskOptionsDropdown) {
            taskOptionsBtn.replaceWith(taskOptionsBtn.cloneNode(true));
            const newTaskOptionsBtn = panel.querySelector('#taskOptionsBtn');
            newTaskOptionsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                console.log('Options button clicked');
                const isVisible = taskOptionsDropdown.style.display === 'block';
                taskOptionsDropdown.style.display = isVisible ? 'none' : 'block';
            });
            
            // Close dropdown when clicking outside
            setTimeout(() => {
                const closeDropdown = (e) => {
                    if (!newTaskOptionsBtn.contains(e.target) && !taskOptionsDropdown.contains(e.target)) {
                        taskOptionsDropdown.style.display = 'none';
                    }
                };
                document.addEventListener('click', closeDropdown);
                
                // Store reference to remove later if needed
                if (!panel.dataset.hasOptionsListener) {
                    panel.dataset.hasOptionsListener = 'true';
                }
            }, 100);
        }
        
        if (clearAllBtn) {
            clearAllBtn.replaceWith(clearAllBtn.cloneNode(true));
            const newClearAllBtn = panel.querySelector('#clearAllTasksBtn');
            newClearAllBtn.addEventListener('click', () => {
                this.clearAllTasks();
                renderTasks();
                if (taskOptionsDropdown) taskOptionsDropdown.style.display = 'none';
            });
        }
        
        if (clearDoneBtn) {
            clearDoneBtn.replaceWith(clearDoneBtn.cloneNode(true));
            const newClearDoneBtn = panel.querySelector('#clearDoneTasksBtn');
            newClearDoneBtn.addEventListener('click', () => {
                this.clearCompletedTasks();
                renderTasks();
                if (taskOptionsDropdown) taskOptionsDropdown.style.display = 'none';
            });
        }
        
        // Setup integration buttons
        const todoistBtn = panel.querySelector('#importTodoistMainBtn');
        console.log('üîµ Todoist button found:', todoistBtn);
        console.log('üîµ Panel element:', panel);
        // Integration buttons removed - using local tasks only
        
        
        // Initial render
        console.log('üîµ Calling initial renderTasks');
        renderTasks();
        
        console.log('‚úÖ renderTasksInSidePanel completed successfully');
    }


    async playPreview(type, button) {
        console.log(`üéµ Playing ${type} preview`);
        
        // Stop any existing preview
        if (this.previewAudio) {
            this.previewAudio.pause();
            this.previewAudio.currentTime = 0;
        }
        
        // Remove playing class from all preview buttons
        document.querySelectorAll('.preview-sound-btn').forEach(btn => {
            btn.classList.remove('playing');
        });
        
        // Clear any existing preview timeout
        if (this.previewTimeout) {
            clearTimeout(this.previewTimeout);
        }
        
        // Set the source based on type
        let source = '';
        if (type === 'lofi' && this.lofiShuffledPlaylist.length > 0) {
            source = '/audio/Lofi/' + this.lofiShuffledPlaylist[0];
        }
        
        if (!source) {
            console.error('No preview source available');
            return;
        }
        
        // Add playing class to button
        button.classList.add('playing');
        
        // Set source and volume
        this.previewAudio.src = source;
        this.previewAudio.volume = this.ambientVolume;
        
        try {
            // Play the preview
            await this.previewAudio.play();
            console.log(`‚úÖ Preview playing for 5 seconds`);
            
            // Stop after 5 seconds
            this.previewTimeout = setTimeout(() => {
                if (this.previewAudio) {
                    this.previewAudio.pause();
                    this.previewAudio.currentTime = 0;
                }
                button.classList.remove('playing');
                console.log('‚èπÔ∏è Preview stopped');
            }, 5000);
            
        } catch (error) {
            console.error('Error playing preview:', error);
            button.classList.remove('playing');
        }
    }

    initializeSettingsSidePanel() {
        console.log('‚öôÔ∏è Initializing settings side panel');
        
        // Sync panel with current technique when opening
        const currentTechnique = localStorage.getItem('selectedTechnique');
        if (currentTechnique && currentTechnique !== 'custom' && !currentTechnique.startsWith('custom_')) {
            this.syncSettingsPanelTechnique(currentTechnique);
        } else if (currentTechnique && currentTechnique.startsWith('custom_')) {
            // Custom technique selected - deselect regular techniques
            this.deselectTechniqueInPanel();
            // The custom technique will be highlighted by loadCustomTechniques()
        } else {
            // Custom configuration - deselect all techniques
            this.deselectTechniqueInPanel();
        }
        
        const settingsPanel = document.getElementById('settingsSidePanel');
        if (!settingsPanel) {
            console.error('‚ùå Settings panel not found');
            return;
        }

        // Get current durations
        const pomodoroMin = Math.floor(this.workTime / 60);
        const shortBreakMin = Math.floor(this.shortBreakTime / 60);
        const longBreakMin = Math.floor(this.longBreakTime / 60);

        // Set initial slider values
        const pomodoroSlider = settingsPanel.querySelector('#sidebarPomodoroSlider');
        const shortBreakSlider = settingsPanel.querySelector('#sidebarShortBreakSlider');
        const longBreakSlider = settingsPanel.querySelector('#sidebarLongBreakSlider');
        const pomodoroValue = settingsPanel.querySelector('#sidebarPomodoroValue');
        const shortBreakValue = settingsPanel.querySelector('#sidebarShortBreakValue');
        const longBreakValue = settingsPanel.querySelector('#sidebarLongBreakValue');

        // Disable duration controls for guest users
        if (!this.isAuthenticated) {
            console.log('üîí Disabling duration controls for guest user');
            
            // Disable Focus duration
            const focusOption = document.getElementById('sidebarFocusOption');
            if (focusOption) {
                focusOption.style.opacity = '0.5';
                focusOption.style.cursor = 'not-allowed';
                const focusLabel = focusOption.querySelector('label');
                if (focusLabel) {
                    focusLabel.innerHTML = 'Work <span style="font-size: 0.75rem; color: #888;">(Sign up required)</span>';
                }
            }
            if (pomodoroSlider) {
                pomodoroSlider.disabled = true;
                pomodoroSlider.style.cursor = 'not-allowed';
            }
            
            // Disable Short Break duration
            const shortBreakOption = document.getElementById('sidebarShortBreakOption');
            if (shortBreakOption) {
                shortBreakOption.style.opacity = '0.5';
                shortBreakOption.style.cursor = 'not-allowed';
                const shortBreakLabel = shortBreakOption.querySelector('label');
                if (shortBreakLabel) {
                    shortBreakLabel.innerHTML = 'Short Break <span style="font-size: 0.75rem; color: #888;">(Sign up required)</span>';
                }
            }
            if (shortBreakSlider) {
                shortBreakSlider.disabled = true;
                shortBreakSlider.style.cursor = 'not-allowed';
            }
            
            // Disable Long Break duration
            const longBreakOption = document.getElementById('sidebarLongBreakOption');
            if (longBreakOption) {
                longBreakOption.style.opacity = '0.5';
                longBreakOption.style.cursor = 'not-allowed';
                const longBreakLabel = longBreakOption.querySelector('label');
                if (longBreakLabel) {
                    longBreakLabel.innerHTML = 'Long Break <span style="font-size: 0.75rem; color: #888;">(Sign up required)</span>';
                }
            }
            if (longBreakSlider) {
                longBreakSlider.disabled = true;
                longBreakSlider.style.cursor = 'not-allowed';
            }
        }

        if (pomodoroSlider && pomodoroValue) {
            pomodoroSlider.value = pomodoroMin;
            pomodoroValue.value = pomodoroMin;
            
            pomodoroSlider.addEventListener('input', (e) => {
                // Track Mixpanel event for sidebar slider
                this.trackEvent('Duration Control Changed', {
                    button_type: 'duration_control',
                    control_name: 'pomodoro',
                    value: e.target.value,
                    source: 'sidebar'
                });
                
                pomodoroValue.value = e.target.value;
                this.enableSaveButton();
                // Deselect technique when manually changing duration
                this.deselectTechniqueInPanel();
            });
        }

        if (shortBreakSlider && shortBreakValue) {
            shortBreakSlider.value = shortBreakMin;
            shortBreakValue.value = shortBreakMin;
            
            shortBreakSlider.addEventListener('input', (e) => {
                // Track Mixpanel event for sidebar slider
                this.trackEvent('Duration Control Changed', {
                    button_type: 'duration_control',
                    control_name: 'short_break',
                    value: e.target.value,
                    source: 'sidebar'
                });
                
                shortBreakValue.value = e.target.value;
                this.enableSaveButton();
                // Deselect technique when manually changing duration
                this.deselectTechniqueInPanel();
            });
        }

        if (longBreakSlider && longBreakValue) {
            longBreakSlider.value = longBreakMin;
            longBreakValue.value = longBreakMin;
            
            const longBreakCard = longBreakSlider.closest('.duration-item');
            
            // Disable Long Break card for guest users
            if (!this.isAuthenticated && longBreakCard) {
                longBreakCard.style.opacity = '0.5';
                longBreakCard.style.pointerEvents = 'none';
                longBreakCard.style.cursor = 'not-allowed';
                
                // Show "(Sign up required)" in the label
                const signupText = longBreakCard.querySelector('.signup-required-text');
                if (signupText) {
                    signupText.classList.remove('hidden');
                }
            }
            
            longBreakSlider.addEventListener('input', (e) => {
                if (!this.isAuthenticated) {
                    this.showLoginRequiredModal('longbreak');
                    return;
                }
                
                // Track Mixpanel event for sidebar slider
                this.trackEvent('Duration Control Changed', {
                    button_type: 'duration_control',
                    control_name: 'long_break',
                    value: e.target.value,
                    source: 'sidebar'
                });
                
                longBreakValue.value = e.target.value;
                this.enableSaveButton();
                // Deselect technique when manually changing duration
                this.deselectTechniqueInPanel();
            });
        }

        // Sessions slider
        const sessionsSlider = settingsPanel.querySelector('#sidebarSessionsSlider');
        const sessionsValue = settingsPanel.querySelector('#sidebarSessionsValue');
        const sessionsCard = sessionsSlider?.closest('.duration-item');
        
        if (sessionsSlider && sessionsValue && sessionsCard) {
            sessionsSlider.value = this.sessionsPerCycle;
            sessionsValue.value = this.sessionsPerCycle;
            
            // Disable entire sessions card for guest users
            if (!this.isAuthenticated) {
                sessionsCard.style.opacity = '0.5';
                sessionsCard.style.pointerEvents = 'none';
                sessionsCard.style.cursor = 'not-allowed';
                
                // Show "(Sign up required)" in the label
                const signupText = sessionsCard.querySelector('.signup-required-text');
                if (signupText) {
                    signupText.classList.remove('hidden');
                }
            }
            
            sessionsSlider.addEventListener('input', (e) => {
                if (!this.isAuthenticated) {
                    this.showLoginRequiredModal('sessions');
                    return;
                }
                
                // Track Mixpanel event for sidebar slider
                this.trackEvent('Duration Control Changed', {
                    button_type: 'duration_control',
                    control_name: 'sessions',
                    value: e.target.value,
                    source: 'sidebar'
                });
                
                sessionsValue.value = e.target.value;
                this.enableSaveButton();
                // Deselect technique when manually changing duration
                this.deselectTechniqueInPanel();
            });
        }

        // Setup editable duration inputs for sidebar
        this.setupEditableDurationInputs(settingsPanel);

        // Techniques presets
        const techniquePresets = settingsPanel.querySelectorAll('.technique-preset');
        techniquePresets.forEach(preset => {
            const technique = preset.dataset.technique;
            
            // Remove any existing event listeners to prevent duplicates
            const newPreset = preset.cloneNode(true);
            preset.parentNode.replaceChild(newPreset, preset);
            
            // For guest users, ensure Pomodoro has active class
            if (technique === 'pomodoro' && !this.isAuthenticated) {
                newPreset.classList.add('active');
                console.log('‚úÖ Pomodoro marked as active for guest user');
            }
            
            newPreset.addEventListener('click', () => {
                const technique = newPreset.dataset.technique;
                
                // Check if preset is disabled (opacity 0.5 means disabled)
                if (getComputedStyle(newPreset).opacity === '0.5' || newPreset.style.opacity === '0.5') {
                    // Check if it requires authentication (Flow, Marathon, Deep Work require login)
                    const proTechniques = ['flow', 'marathon', 'deepwork'];
                    if (proTechniques.includes(technique) && !this.isAuthenticated) {
                        // Guest users must login first
                        this.showLoginRequiredModal(technique);
                        return;
                    }
                    // Check if it requires authentication
                    if (technique !== 'pomodoro' && !this.isAuthenticated) {
                        // Show signup modal or do nothing (already disabled)
                        return;
                    }
                    return; // Don't do anything if preset is disabled
                }
                
                // Check if technique requires authentication (Flow, Marathon, Deep Work require login for free users)
                const proTechniques = ['flow', 'marathon', 'deepwork'];
                if (proTechniques.includes(technique) && !this.isAuthenticated) {
                    // Guest users must login first
                    this.showLoginRequiredModal(technique);
                    return;
                }
                
                // Check if technique requires authentication (Sprint, Focus for guests)
                if (technique !== 'pomodoro' && !this.isAuthenticated) {
                    return; // Don't show modal, preset is already disabled
                }
                
                this.trackEvent('Technique Selected', {
                    modal_type: 'timer_sidebar',
                    button_type: 'technique_preset',
                    technique_name: technique,
                    source: 'timer_sidebar',
                    user_type: this.isAuthenticated ? (this.isPro ? 'pro' : 'free') : 'guest',
                    conversion_funnel: 'technique_exploration'
                });
                
                // Get fresh reference to all presets after cloning
                const currentTechniquePresets = settingsPanel.querySelectorAll('.technique-preset');
                // Remove active class from all presets
                currentTechniquePresets.forEach(p => p.classList.remove('active'));
                
                // Remove active class from all custom cards
                const allCustomCards = document.querySelectorAll('.custom-card');
                allCustomCards.forEach(card => card.classList.remove('active'));
                
                // Add active class to clicked preset
                newPreset.classList.add('active');
                
                // Apply technique settings
                this.applySidebarTechniquePreset(technique, pomodoroSlider, shortBreakSlider, longBreakSlider, sessionsSlider);
                
                // Apply immediately for all users
                const techniqueObj = {
                    workMinutes: parseInt(pomodoroSlider.value),
                    shortBreakMinutes: parseInt(shortBreakSlider.value),
                    longBreakMinutes: parseInt(longBreakSlider.value),
                    sessions: parseInt(sessionsSlider.value),
                    name: technique
                };
                this.applyTechniqueImmediately(techniqueObj);
            });
        });

        // Save button handler (hidden for all users - immediate application enabled)
        const saveBtn = settingsPanel.querySelector('#sidebarSaveSettings');
        if (saveBtn) {
            // Hide save button for all users (immediate application enabled for everyone)
            saveBtn.style.display = 'none';
            console.log('üîí Save button hidden for all users (immediate application enabled)');
        }
        
    }


    applyBackground(backgroundName) {
        // Don't apply background if immersive theme is active
        if (this.currentImmersiveTheme && this.currentImmersiveTheme !== 'none') {
            console.log(`üé® Background change blocked - immersive theme '${this.currentImmersiveTheme}' is active`);
            return;
        }
        
        const timerSection = document.querySelector('.timer-section');
        if (!timerSection) {
            console.error('‚ùå Timer section not found');
            return;
        }
        
        // Remove all background classes
        timerSection.classList.remove('theme-minimalist', 'theme-woman', 'theme-man');
        
        // Add new background class
        timerSection.classList.add(`theme-${backgroundName}`);
        
        // Winter visit button removed - no longer needed
        
        // Save preference to localStorage
        localStorage.setItem('selectedBackground', backgroundName);
        this.currentBackground = backgroundName;
        
        // üéØ Track Background Changed event to Mixpanel
        if (window.mixpanelTracker) {
            window.mixpanelTracker.trackCustomEvent('Background Changed', { background_name: backgroundName });
            console.log('üìä Background changed event tracked to Mixpanel');
        }
        
        console.log(`üé® Background changed to: ${backgroundName}`);
    }

    // Immersive Theme Functions
    async loadTronAssets() {
        try {
            console.log('üé® Loading Tron assets...');
            
            // Load single Tron image
            this.tronImage = '/themes/Tron/1395234.jpg';
            
            
            console.log('üé® Tron assets loaded successfully');
            console.log('üé® Image:', this.tronImage);
        } catch (error) {
            console.error('‚ùå Failed to load Tron assets:', error);
        }
    }

    initializeImmersiveThemePanel() {
        console.log('üé® Initializing theme panel');
        
        // Get current theme from localStorage or default to 'lofi'
        // Load last selected theme for both authenticated and guest users
        const lastSelectedTheme = localStorage.getItem('lastSelectedTheme');
        const savedTheme = lastSelectedTheme || 'lofi';
        
        this.currentTheme = savedTheme;
        
        // Initialize volume control
        this.initializeVolumeControl();
        
        // Get all theme options
        const themeOptions = document.querySelectorAll('.theme-option[data-theme]');
        
        themeOptions.forEach(option => {
            const themeName = option.dataset.theme;
            
            // Set initial active state
            if (themeName === savedTheme) {
                option.classList.add('active');
            }
            
            // Set up click handler
            option.addEventListener('click', (e) => {
                e.preventDefault();
                
                // Don't trigger if clicking edit/delete buttons on custom vibes
                if (e.target.closest('.edit-cassette-btn') || e.target.closest('.delete-cassette-btn')) {
                    return;
                }
                
                this.trackEvent('Vibe Selected', {
                    button_type: 'cassette',
                    vibe_name: themeName,
                    source: 'cassettes_panel'
                });
                
                // Check if theme requires authentication
                const requiresAuth = option.dataset.requiresAuth === 'true';
                if (requiresAuth && !this.isAuthenticated) {
                    // Show modal with theme info
                    this.showTronInfoModal();
                    return;
                }
                
                // Remove active from all preset themes
                themeOptions.forEach(opt => {
                    opt.classList.remove('active');
                });
                
                // Remove active from all custom vibes
                document.querySelectorAll('.custom-cassette').forEach(opt => {
                    opt.classList.remove('active');
                });
                
                // Remove active from all public vibes
                document.querySelectorAll('.public-cassette').forEach(opt => {
                    opt.classList.remove('active');
                });
                
                // Add active to clicked option
                option.classList.add('active');
                
                // Apply the selected theme
                this.applyTheme(themeName);
                
                // Save to localStorage (for both authenticated and guest users)
                localStorage.setItem('lastSelectedTheme', themeName);
                this.currentTheme = themeName;
            });
        });
        
        // Don't reapply theme when opening sidebar - just update visual state
        this.updateThemeActiveState(savedTheme);
        
        // Update theme authentication state
        this.updateThemeAuthState();
        
        // Initialize My Vibes section for Pro users
        this.initializeMyCassettes();
        
        console.log('üé® Theme panel initialized - no music reset');
    }

    initializeCassetteMetadataExtraction() {
        let spotifyInput = document.getElementById('cassetteSpotifyUrl');
        let imageUrlInput = document.getElementById('cassetteImageUrl');
        const titleInput = document.getElementById('cassetteTitle');
        const descriptionInput = document.getElementById('cassetteDescription');

        if (!imageUrlInput) return;

        const handleUrlChange = async (e) => {
            const inputElement = e.target;
            const url = (inputElement.value || '').trim();
            if (!url) return;
            
            // Determine if we should fetch metadata
            // 1. If input is website/spotify, fetch if image is empty
            // 2. If input IS image input, fetch if it doesn't look like a direct image file
            const isImageInput = inputElement === imageUrlInput;
            const shouldFetch = isImageInput 
                ? !url.match(/\.(jpeg|jpg|gif|png|webp|svg|bmp)$/i) && !url.includes('images.unsplash.com') && !url.includes('i.imgur.com')
                : (!imageUrlInput.value || imageUrlInput.value.trim() === '');

            if (!shouldFetch) return;

            try {
                // Show loading indicator
                if (isImageInput) {
                    // For image input, we are "validating/fixing" the URL
                    const originalValue = imageUrlInput.value;
                    imageUrlInput.value = 'Searching for image...';
                    imageUrlInput.disabled = true;
                    
                    const response = await fetch(`/api/extract-metadata?url=${encodeURIComponent(url)}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.image) {
                            imageUrlInput.value = data.image;
                            console.log('üé® Auto-corrected image URL from webpage');
                        } else {
                            // If no image found, revert to original (user might be right)
                            imageUrlInput.value = originalValue;
                        }
                    } else {
                        imageUrlInput.value = originalValue;
                    }
                    imageUrlInput.disabled = false;
                } else {
                    // For other inputs, we are filling empty fields
                    const originalPlaceholder = imageUrlInput.placeholder;
                    imageUrlInput.placeholder = 'Fetching image...';
                    imageUrlInput.classList.add('loading-input');
                    
                    const response = await fetch(`/api/extract-metadata?url=${encodeURIComponent(url)}`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success) {
                            if (data.image && (!imageUrlInput.value || imageUrlInput.value.trim() === '')) {
                                imageUrlInput.value = data.image;
                                console.log('üé® Auto-filled cassette image from URL');
                            }
                            
                            if (data.title && (!titleInput.value || titleInput.value.trim() === '')) {
                                titleInput.value = data.title.substring(0, 50);
                            }
                            
                            if (data.description && (!descriptionInput.value || descriptionInput.value.trim() === '')) {
                                descriptionInput.value = data.description.substring(0, 35);
                            }
                        }
                    }
                    imageUrlInput.placeholder = originalPlaceholder;
                    imageUrlInput.classList.remove('loading-input');
                }
            } catch (error) {
                console.error('Error fetching metadata:', error);
                if (isImageInput) {
                    imageUrlInput.value = url; // Revert on error
                    imageUrlInput.disabled = false;
                } else {
                    imageUrlInput.placeholder = 'https://example.com/image.jpg';
                    imageUrlInput.classList.remove('loading-input');
                }
            }
        };

        // Add listeners
        const inputs = [spotifyInput, imageUrlInput];
        
        inputs.forEach(input => {
            if (input && !input.dataset.metadataInitialized) {
                const newInput = input.cloneNode(true);
                input.parentNode.replaceChild(newInput, input);
                newInput.addEventListener('blur', handleUrlChange);
                newInput.dataset.metadataInitialized = 'true';
                
                // Update local references so closure uses the active DOM elements
                if (input === spotifyInput) spotifyInput = newInput;
                if (input === imageUrlInput) imageUrlInput = newInput;
            }
        });
        
        // Add real-time validation for image URL
        this.initializeImageUrlValidation();
    }
    
    initializeImageUrlValidation() {
        // Simple validation: only title is required, image is optional
        // Always get fresh DOM references to avoid stale closures
        
        const updateSaveButton = () => {
        const saveBtn = document.getElementById('saveCassetteBtn');
            const titleInput = document.getElementById('cassetteTitle');
        
            if (!saveBtn || !titleInput) return;
            
            const hasTitle = titleInput.value.trim().length > 0;
        
            // Only title is required - enable button if title exists
            saveBtn.disabled = !hasTitle;
            saveBtn.style.opacity = hasTitle ? '1' : '0.5';
            saveBtn.style.cursor = hasTitle ? 'pointer' : 'not-allowed';
        };
        
        // Add listeners to title input
        const titleInput = document.getElementById('cassetteTitle');
        if (titleInput) {
            // Save the current value before cloning (cloneNode doesn't copy .value)
            const currentValue = titleInput.value;
            
            // Remove old listeners by replacing element
                const newTitleInput = titleInput.cloneNode(true);
                titleInput.parentNode.replaceChild(newTitleInput, titleInput);
            
            // Restore the value after cloning
            newTitleInput.value = currentValue;
            
            newTitleInput.addEventListener('input', updateSaveButton);
            newTitleInput.addEventListener('change', updateSaveButton);
            newTitleInput.addEventListener('keyup', updateSaveButton);
        }
        
        // Initial state update
        updateSaveButton();
    }

    initializeMyCassettes() {
        const createCassetteSection = document.getElementById('createCassetteSection');
        const createCassetteBtn = document.getElementById('createCassetteBtn');
        const recoverDeletedCassettesBtn = document.getElementById('recoverDeletedCassettesBtn');
        const cancelCassetteBtn = document.getElementById('cancelCassetteBtn');
        const saveCassetteBtn = document.getElementById('saveCassetteBtn');
        
        // Show create button for ALL users (similar to Create timer)
        if (createCassetteSection) {
            createCassetteSection.style.display = 'block';
        }
        
        // Initialize search functionality for all users
        this.initializeCassetteSearch();
        
        // Initialize metadata extraction listeners
        this.initializeCassetteMetadataExtraction();
        
        // Load and render custom cassettes (show for all users, disabled if not authenticated)
        this.loadCustomCassettes();
        this.refreshRecoverDeletedCassettesButton();
        
        // Load and render public cassettes (for all users, with restriction for Guest)
        // Moved to openImmersiveThemePanel to ensure refresh on open
        // this.loadPublicCassettes(false);
        
        // Add create button event (remove existing listeners first to avoid duplicates)
        if (createCassetteBtn) {
            // Clone and replace to remove all event listeners
            const newBtn = createCassetteBtn.cloneNode(true);
            createCassetteBtn.parentNode.replaceChild(newBtn, createCassetteBtn);
            
            // Add single event listener
            newBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.showCassetteForm();
            });
        }

        if (recoverDeletedCassettesBtn) {
            const newRecoverBtn = recoverDeletedCassettesBtn.cloneNode(true);
            recoverDeletedCassettesBtn.parentNode.replaceChild(newRecoverBtn, recoverDeletedCassettesBtn);
            newRecoverBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.showRecoverDeletedCassettesModal();
            });
        }
        
        // Cancel button (only for Pro users who can see the form)
        if (cancelCassetteBtn) {
            cancelCassetteBtn.addEventListener('click', () => {
                this.hideCassetteForm();
            });
        }
        
        // Save button (only for Pro users who can see the form)
        if (saveCassetteBtn) {
            // Remove existing listeners by cloning
            const newSaveBtn = saveCassetteBtn.cloneNode(true);
            // CRITICAL: Clear any leftover editingId from previous clone
            delete newSaveBtn.dataset.editingId;
            saveCassetteBtn.parentNode.replaceChild(newSaveBtn, saveCassetteBtn);
            
            newSaveBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                // Prevent saving if button is disabled
                if (newSaveBtn.disabled) {
                    return;
                }
                
                const cassetteId = newSaveBtn.dataset.editingId || null;
                console.log('üíæ Save button clicked, editingId:', cassetteId);
                await this.saveCassetteFromForm(cassetteId);
            });
        }
    }
    
    initializeCassetteSearch() {
        const searchInput = document.getElementById('cassetteSearchInput');
        if (!searchInput) return;
        
        // Remove existing listeners to avoid duplicates
        const newSearchInput = searchInput.cloneNode(true);
        searchInput.parentNode.replaceChild(newSearchInput, searchInput);
        
        // Add search event listener
        newSearchInput.addEventListener('input', (e) => {
            const searchQuery = (e.target.value || '').trim().toLowerCase();
            this.filterCassettes(searchQuery);
        });
    }
    
    filterCassettes(searchQuery) {
        // Filter presets
        const presetOptions = document.querySelectorAll('.theme-option[data-theme]');
        presetOptions.forEach(option => {
            const title = option.querySelector('h4')?.textContent?.toLowerCase() || '';
            const description = option.querySelector('p')?.textContent?.toLowerCase() || '';
            const matches = !searchQuery || title.includes(searchQuery) || description.includes(searchQuery);
            option.style.display = matches ? 'flex' : 'none';
        });
        
        // Filter custom vibes (only public ones are searchable)
        const customCassettes = document.querySelectorAll('.custom-cassette');
        customCassettes.forEach(cassette => {
            // For now, we'll search all visible cassettes (public vibes will be loaded async)
            const title = cassette.querySelector('h4')?.textContent?.toLowerCase() || '';
            const description = cassette.querySelector('p')?.textContent?.toLowerCase() || '';
            const matches = !searchQuery || title.includes(searchQuery) || description.includes(searchQuery);
            cassette.style.display = matches ? 'flex' : 'none';
        });
        
        // Filter public vibes
        const publicCassettes = document.querySelectorAll('.public-cassette');
        publicCassettes.forEach(cassette => {
            const title = cassette.querySelector('h4')?.textContent?.toLowerCase() || '';
            const description = cassette.querySelector('p')?.textContent?.toLowerCase() || '';
            const matches = !searchQuery || title.includes(searchQuery) || description.includes(searchQuery);
            cassette.style.display = matches ? 'flex' : 'none';
        });
        
        // Count visible results
        const visiblePresets = Array.from(presetOptions).filter(opt => opt.style.display !== 'none');
        const visiblePublicCassettes = Array.from(publicCassettes).filter(c => c.style.display !== 'none');
        
        // Handle section visibility based on search results
        const publicCassettesSection = document.getElementById('publicCassettesSection');
        const cassettePresetsSection = document.getElementById('cassettePresetsSection');
        
        if (searchQuery) {
            // During search: show only the section with results, hide the other
            if (publicCassettesSection) {
                publicCassettesSection.style.display = visiblePublicCassettes.length > 0 ? 'block' : 'none';
            }
            if (cassettePresetsSection) {
                cassettePresetsSection.style.display = visiblePresets.length > 0 ? 'block' : 'none';
            }
        } else {
            // No search: show sections normally based on their content
            if (publicCassettesSection) {
                publicCassettesSection.style.display = visiblePublicCassettes.length > 0 ? 'block' : 'none';
            }
            if (cassettePresetsSection) {
                cassettePresetsSection.style.display = 'block';
            }
        }
    }

    loadCustomCassettes() {
        const customCassettesList = document.getElementById('customCassettesList');
        if (!customCassettesList) return;
        
        const customCassettes = this.getCustomCassettes();
        this.refreshRecoverDeletedCassettesButton();
        
        // Filter out public vibes - only show private cassettes in "My Vibes"
        const privateCassettes = customCassettes.filter(c => !c.isPublic || c.isPublic === false);
        
        if (privateCassettes.length === 0) {
            customCassettesList.innerHTML = '';
            this.refreshRecoverDeletedCassettesButton();
            return;
        }
        
        // Check if user is authenticated - show disabled style if not
        const isDisabled = !this.isAuthenticated;
        const disabledStyle = isDisabled ? 'opacity: 0.5; pointer-events: none;' : '';
        const signupText = isDisabled ? '<span class="signup-required-text">(Sign up required)</span>' : '';
        
        customCassettesList.innerHTML = privateCassettes.map(cassette => {
            // Escape URL for CSS: escape single quotes and wrap in quotes
            const escapedImageUrl = cassette.imageUrl ? cassette.imageUrl.replace(/'/g, "\\'").replace(/"/g, '\\"') : '';
            const previewStyle = cassette.imageUrl 
                ? `background-image: url('${escapedImageUrl}'); background-size: cover; background-position: center;`
                : 'background: #0a0a0a;';
            
            return `
                <div class="theme-option custom-cassette" data-cassette-id="${cassette.id}" style="position: relative; ${disabledStyle}">
                    <div class="theme-preview" style="${previewStyle}"></div>
                    <div class="theme-info">
                        <h4>${cassette.title} ${signupText}</h4>
                        <p>${cassette.description || 'Custom focus environment'}</p>
                    </div>
                    <div style="position: absolute; top: 8px; right: 8px; z-index: 10;">
                        <button class="cassette-options-btn" data-cassette-id="${cassette.id}" title="Vibe options" onclick="event.stopPropagation();">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="1"/>
                                <circle cx="19" cy="12" r="1"/>
                                <circle cx="5" cy="12" r="1"/>
                            </svg>
                        </button>
                        <div class="cassette-options-dropdown" id="cassetteOptionsDropdown${cassette.id}" style="display: none;">
                            <div class="cassette-options-menu">
                                <button class="cassette-option-item edit-cassette-option" data-cassette-id="${cassette.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                                    </svg>
                                    Edit
                                </button>
                                <button class="cassette-option-item delete-cassette-option" data-cassette-id="${cassette.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="3 6 5 6 21 6"/>
                                        <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
                                        <line x1="10" y1="11" x2="10" y2="17"/>
                                        <line x1="14" y1="11" x2="14" y2="17"/>
                                    </svg>
                                    Delete
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
        
        // Add event listeners for custom vibes
        privateCassettes.forEach(cassette => {
            const cassetteOption = document.querySelector(`[data-cassette-id="${cassette.id}"]`);
            if (cassetteOption) {
                cassetteOption.addEventListener('click', (e) => {
                    // Don't trigger if clicking options button or dropdown
                    if (e.target.closest('.cassette-options-btn') || e.target.closest('.cassette-options-dropdown')) {
                        return;
                    }
                    
                    this.selectCustomCassette(cassette.id);
                });
            }
            
            // Options button (3 dots)
            const optionsBtn = document.querySelector(`.cassette-options-btn[data-cassette-id="${cassette.id}"]`);
            const optionsDropdown = document.getElementById(`cassetteOptionsDropdown${cassette.id}`);
            
            if (optionsBtn && optionsDropdown) {
                optionsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isVisible = optionsDropdown.style.display === 'block';
                    // Close all other dropdowns first
                    document.querySelectorAll('.cassette-options-dropdown').forEach(dropdown => {
                        dropdown.style.display = 'none';
                    });
                    optionsDropdown.style.display = isVisible ? 'none' : 'block';
                });
            }
            
            // Edit option
            const editOption = document.querySelector(`.edit-cassette-option[data-cassette-id="${cassette.id}"]`);
            if (editOption) {
                editOption.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (optionsDropdown) optionsDropdown.style.display = 'none';
                    this.showCassetteForm(cassette.id);
                });
            }
            
            // Delete option
            const deleteOption = document.querySelector(`.delete-cassette-option[data-cassette-id="${cassette.id}"]`);
            if (deleteOption) {
                deleteOption.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (optionsDropdown) optionsDropdown.style.display = 'none';
                    this.deleteCustomCassette(cassette.id);
                    this.showResourceShareToast('Cassette moved to deleted');
                });
            }
        });
        
        // Close dropdown when clicking outside
        setTimeout(() => {
            const closeDropdowns = (e) => {
                if (!e.target.closest('.cassette-options-btn') && !e.target.closest('.cassette-options-dropdown')) {
                    document.querySelectorAll('.cassette-options-dropdown').forEach(dropdown => {
                        dropdown.style.display = 'none';
                    });
                }
            };
            document.addEventListener('click', closeDropdowns);
        }, 100);
    }

    getCustomCassettes() {
        try {
            const cassettes = JSON.parse(localStorage.getItem('customCassettes') || '[]');
            return cassettes;
        } catch {
            return [];
        }
    }

    getDeletedCassettesTrash() {
        try {
            const deleted = JSON.parse(localStorage.getItem('deletedCassettesTrash') || '[]');
            return Array.isArray(deleted) ? deleted : [];
        } catch {
            return [];
        }
    }

    saveDeletedCassettesTrash(deletedCassettes) {
        try {
            localStorage.setItem('deletedCassettesTrash', JSON.stringify(deletedCassettes));
        } catch (error) {
            console.error('Error saving deleted cassette trash:', error);
        }
    }

    getFreeCassetteOwnershipCount() {
        try {
            const ownedCassetteIds = new Set();
            this.getCustomCassettes().forEach((cassette) => ownedCassetteIds.add(cassette.id));
            this.getDeletedCassettesTrash().forEach((cassette) => ownedCassetteIds.add(cassette.id));
            return ownedCassetteIds.size;
        } catch (error) {
            console.error('Error calculating free cassette ownership count:', error);
            return 0;
        }
    }

    refreshRecoverDeletedCassettesButton() {
        const recoverBtn = document.getElementById('recoverDeletedCassettesBtn');
        if (!recoverBtn) return;
        recoverBtn.style.display = this.getDeletedCassettesTrash().length > 0 ? 'block' : 'none';
    }

    showRecoverDeletedCassettesModal() {
        const deletedCassettes = this.getDeletedCassettesTrash();
        if (deletedCassettes.length === 0) {
            this.showResourceShareToast('No deleted cassettes to recover', true);
            this.refreshRecoverDeletedCassettesButton();
            return;
        }
        const isPremium = this.isPremiumUser();

        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';

        const modal = document.createElement('div');
        modal.className = 'logout-modal';
        modal.style.cssText = 'max-width: 520px; padding: 32px; position: relative;';

        const deletedRows = deletedCassettes.map((cassette) => {
            const escapedImageUrl = cassette.imageUrl
                ? cassette.imageUrl.replace(/'/g, "\\'").replace(/"/g, '\\"')
                : '';
            const previewStyle = cassette.imageUrl
                ? `background-image: url('${escapedImageUrl}'); background-size: cover; background-position: center;`
                : 'background: #0a0a0a;';

            return `
                <div style="display: flex; justify-content: space-between; align-items: center; gap: 12px; padding: 10px 12px; border-radius: 8px; background: rgba(255,255,255,0.04);">
                    <div style="width: 52px; height: 52px; border-radius: 8px; flex-shrink: 0; ${previewStyle}"></div>
                    <div style="min-width: 0; flex: 1;">
                        <div style="font-size: 14px; font-weight: 600; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${this.escapeHtml(cassette.title || 'Untitled cassette')}</div>
                        <div style="font-size: 13px; color: rgba(255,255,255,0.6); margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${this.escapeHtml(cassette.description || 'Custom focus environment')}</div>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                        <button class="logout-modal-btn logout-modal-btn-secondary recover-cassette-btn" data-cassette-id="${cassette.id}" style="width: auto; min-width: 118px; flex-shrink: 0; padding: 7px 12px; font-size: 13px;">
                            Recover
                        </button>
                        ${isPremium ? `
                            <button class="logout-modal-btn delete-forever-cassette-btn" data-cassette-id="${cassette.id}" aria-label="Delete forever" title="Delete forever" style="width: auto; min-width: auto; padding: 7px 9px; background: rgba(239, 68, 68, 0.18); color: #fda4af; border: 1px solid rgba(239, 68, 68, 0.35); display: inline-flex; align-items: center; justify-content: center;">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M3 6h18"/>
                                    <path d="M8 6V4c0-1.1.9-2 2-2h4c1.1 0 2 .9 2 2v2"/>
                                    <path d="M19 6v14c0 1.1-.9 2-2 2H7c-1.1 0-2-.9-2-2V6"/>
                                    <path d="M10 11v6"/>
                                    <path d="M14 11v6"/>
                                </svg>
                            </button>
                        ` : ''}
                    </div>
                </div>
            `;
        }).join('');

        modal.innerHTML = `
            <button class="close-modal-x" id="closeRecoverCassetteModal" style="position: absolute; top: 16px; right: 16px; background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 8px; display: flex; align-items: center; justify-content: center;">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 8px; color: #fff; text-align: left;">Recover deleted cassettes</h3>
            <p style="font-size: 13px; color: rgba(255,255,255,0.7); margin-bottom: 18px; text-align: left;">Pick one cassette to restore it to your list.</p>
            <div style="display: flex; flex-direction: column; gap: 8px; max-height: 300px; overflow-y: auto;">
                ${deletedRows}
            </div>
        `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        const close = () => {
            try { document.body.removeChild(overlay); } catch (_) {}
        };

        modal.querySelector('#closeRecoverCassetteModal')?.addEventListener('click', close);
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) close();
        });

        modal.querySelectorAll('.recover-cassette-btn').forEach((btn) => {
            btn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                const cassetteId = btn.getAttribute('data-cassette-id');
                await this.restoreDeletedCassette(cassetteId);
                close();
            });
        });

        modal.querySelectorAll('.delete-forever-cassette-btn').forEach((btn) => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const cassetteId = btn.getAttribute('data-cassette-id');
                this.permanentlyDeleteDeletedCassette(cassetteId);
                close();
            });
        });
    }

    permanentlyDeleteDeletedCassette(cassetteId) {
        const deletedCassettes = this.getDeletedCassettesTrash();
        const updatedDeleted = deletedCassettes.filter((cassette) => cassette.id !== cassetteId);
        this.saveDeletedCassettesTrash(updatedDeleted);
        this.refreshRecoverDeletedCassettesButton();
        this.showResourceShareToast('Cassette deleted forever');
    }

    async restoreDeletedCassette(cassetteId) {
        const deletedCassettes = this.getDeletedCassettesTrash();
        const cassetteToRestore = deletedCassettes.find((cassette) => cassette.id === cassetteId);
        if (!cassetteToRestore) {
            this.showResourceShareToast('Cassette not found in deleted list', true);
            this.refreshRecoverDeletedCassettesButton();
            return;
        }

        const activeCassettes = this.getCustomCassettes();
        if (!this.isPremiumUser() && activeCassettes.length >= 1) {
            this.showResourceShareToast('Free users can only keep 1 cassette active at a time', true);
            return;
        }

        const updatedCassettes = [...activeCassettes, cassetteToRestore];
        const updatedDeleted = deletedCassettes.filter((cassette) => cassette.id !== cassetteId);
        localStorage.setItem('customCassettes', JSON.stringify(updatedCassettes));
        this.saveDeletedCassettesTrash(updatedDeleted);

        this.loadCustomCassettes();
        this.refreshRecoverDeletedCassettesButton();
        this.loadPublicCassettes(true).catch((err) => {
            console.error('Error reloading public vibes after cassette restore:', err);
        });

        if (this.isAuthenticated && this.user?.id) {
            const stats = this.getFocusStats();
            fetch('/api/sync-cassettes', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-clerk-userid': this.user.id
                },
                body: JSON.stringify({ cassettes: updatedCassettes })
            }).catch((err) => {
                console.error('Error syncing cassettes after restore:', err);
            });

            fetch('/api/sync-stats', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-clerk-userid': this.user.id
                },
                body: JSON.stringify({
                    totalHours: stats?.totalHours || 0,
                    customCassettes: updatedCassettes
                })
            }).catch((err) => {
                console.error('Error syncing cassette backup after restore:', err);
            });
        }

        this.showResourceShareToast('Cassette recovered');
    }

    async loadPublicCassettesFromAPI(forceRefresh = false) {
        const cacheKey = 'publicCassettesCache';
        const cacheChecksumKey = 'publicCassettesChecksum';

        if (!forceRefresh) {
            try {
                const checkResponse = await fetch('/api/public-cassettes-check', {
                    method: 'GET',
                    headers: this.user?.id ? {
                        'x-clerk-userid': this.user.id
                    } : {}
                });

                if (checkResponse.ok) {
                    const checkData = await checkResponse.json();
                    if (checkData.success && checkData.checksum) {
                        const cachedChecksum = localStorage.getItem(cacheChecksumKey);
                        const cachedData = localStorage.getItem(cacheKey);

                        if (cachedChecksum === checkData.checksum && cachedData) {
                            console.log('üì¶ Using cached public vibes (no changes detected)');
                            return JSON.parse(cachedData);
                        }

                        console.log('üîÑ Changes detected, fetching updated public vibes...');
                        const fullResponse = await fetch('/api/public-cassettes', {
                            method: 'GET',
                            headers: this.user?.id ? {
                                'x-clerk-userid': this.user.id
                            } : {}
                        });

                        if (fullResponse.ok) {
                            const fullData = await fullResponse.json();
                            if (fullData.success && Array.isArray(fullData.publicCassettes)) {
                                localStorage.setItem(cacheKey, JSON.stringify(fullData.publicCassettes));
                                localStorage.setItem('publicCassettesCacheTimestamp', Date.now().toString());
                                localStorage.setItem(cacheChecksumKey, checkData.checksum);
                                console.log(`‚úÖ Loaded ${fullData.publicCassettes.length} public vibes from API (updated)`);
                                return fullData.publicCassettes;
                            }
                        }
                    }
                }
            } catch (e) {
                console.error('Error checking public vibes:', e);
                const cachedData = localStorage.getItem(cacheKey);
                if (cachedData) {
                    console.log('‚ö†Ô∏è Check failed, using cached data as fallback');
                    return JSON.parse(cachedData);
                }
            }
        }

        try {
            const response = await fetch('/api/public-cassettes', {
                method: 'GET',
                headers: this.user?.id ? {
                    'x-clerk-userid': this.user.id
                } : {}
            });

            if (response.ok) {
                const data = await response.json();
                if (data.success && Array.isArray(data.publicCassettes)) {
                    localStorage.setItem(cacheKey, JSON.stringify(data.publicCassettes));
                    localStorage.setItem('publicCassettesCacheTimestamp', Date.now().toString());
                    if (!forceRefresh && data.checksum) {
                        localStorage.setItem(cacheChecksumKey, data.checksum);
                    } else if (forceRefresh) {
                        localStorage.removeItem(cacheChecksumKey);
                    }
                    console.log(`‚úÖ Loaded ${data.publicCassettes.length} public vibes from API (${forceRefresh ? 'forced' : 'fallback'})`);
                    return data.publicCassettes;
                }
            }
        } catch (e) {
            console.error('Error loading public vibes from API:', e);
        }

        return [];
    }
    
    // Method to invalidate public vibes cache
    invalidatePublicCassettesCache() {
        localStorage.removeItem('publicCassettesCache');
        localStorage.removeItem('publicCassettesChecksum');
        console.log('üóëÔ∏è Public vibes cache invalidated');
    }
    
    // Method to remove a specific cassette from the public vibes cache
    removeCassetteFromPublicCache(cassetteId) {
        const cacheKey = 'publicCassettesCache';
        const cachedData = localStorage.getItem(cacheKey);
        
        if (cachedData) {
            try {
                const cassettes = JSON.parse(cachedData);
                const filtered = cassettes.filter(c => c.id !== cassetteId);
                localStorage.setItem(cacheKey, JSON.stringify(filtered));
                console.log(`üóëÔ∏è Removed cassette ${cassetteId} from public vibes cache`);
            } catch (e) {
                console.error('Error removing cassette from cache:', e);
            }
        }
    }

    async getCustomCassettesWithPublic() {
        const localCassettes = this.getCustomCassettes();
        
        // Load public vibes from API in background
        const publicCassettes = await this.loadPublicCassettesFromAPI();
        
        // Merge with local cassettes, avoiding duplicates
        const existingIds = new Set(localCassettes.map(c => c.id));
        const mergedCassettes = [...localCassettes];
        
        publicCassettes.forEach(publicCassette => {
            if (!existingIds.has(publicCassette.id)) {
                mergedCassettes.push(publicCassette);
            }
        });
        
        return mergedCassettes;
    }

    async loadPublicCassettes(forceRefresh = false) {
        // Prevent duplicate concurrent calls
        if (this.isLoadingPublicCassettes) {
            console.log('‚è≥ Public vibes already loading, skipping duplicate call');
            return;
        }
        
        const publicCassettesList = document.getElementById('publicCassettesList');
        const publicCassettesSection = document.getElementById('publicCassettesSection');
        
        if (!publicCassettesList || !publicCassettesSection) {
            this.isLoadingPublicCassettes = false;
            return;
        }
        
        // Mark as loading
        this.isLoadingPublicCassettes = true;
        
        const isGuest = !this.isAuthenticated;
        
        // Get user's own public vibes from localStorage immediately
        const userPublicCassettes = this.getCustomCassettes().filter(c => c.isPublic === true);
        
        // Add creator info to user's public vibes
        const userPublicCassettesWithCreator = userPublicCassettes.map(c => ({
            ...c,
            creatorName: this.user?.username || this.user?.emailAddresses?.[0]?.emailAddress?.split('@')[0] || 'You',
            creatorId: this.user?.id
        }));
        
        // Step 1: Render immediately from cache + user's public vibes (optimistic rendering)
        const cacheKey = 'publicCassettesCache';
        const cachedData = localStorage.getItem(cacheKey);
        let cachedCassettes = [];
        
        if (cachedData) {
            try {
                cachedCassettes = JSON.parse(cachedData);
            } catch (e) {
                console.error('Error parsing cached data:', e);
            }
        }
        
        // Merge user's public vibes with cached cassettes (user's cassettes take priority)
        // Only update/add user's cassettes that belong to the current user
        const existingIds = new Set(cachedCassettes.map(c => c.id));
        const mergedForDisplay = [...cachedCassettes];
        
        userPublicCassettesWithCreator.forEach(userCassette => {
            const existingIndex = mergedForDisplay.findIndex(c => c.id === userCassette.id);
            if (existingIndex >= 0) {
                // Update existing with user's version only if it's the user's own cassette
                const existingCassette = mergedForDisplay[existingIndex];
                if (existingCassette.creatorId === this.user?.id || !existingCassette.creatorId) {
                    // Preserve views and viewedBy from cache (cache has server data with views)
                    // Server is source of truth for views, always prefer cache/server views
                    mergedForDisplay[existingIndex] = {
                        ...userCassette,
                        views: existingCassette.views !== undefined && existingCassette.views !== null ? existingCassette.views : (userCassette.views !== undefined && userCassette.views !== null ? userCassette.views : 0),
                        viewedBy: existingCassette.viewedBy || userCassette.viewedBy || []
                    };
                }
            } else {
                // Add new user's cassette
                mergedForDisplay.push(userCassette);
            }
        });
        
        // Remove duplicates by ID before rendering (keep first occurrence)
        const seenIdsForDisplay = new Set();
        const uniqueMergedForDisplay = mergedForDisplay.filter(cassette => {
            if (seenIdsForDisplay.has(cassette.id)) {
                return false; // Duplicate, skip it
            }
            seenIdsForDisplay.add(cassette.id);
            return true;
        });
        
        // Track if we rendered from cache (to avoid double state application)
        let renderedFromCache = false;
        
        if (uniqueMergedForDisplay.length > 0) {
            // Render immediately from merged cache + user's cassettes
            this.renderPublicCassettes(uniqueMergedForDisplay, isGuest);
            console.log('üì¶ Rendered public vibes from cache + user cassettes immediately');
            renderedFromCache = true;
            // Ensure section is visible
            if (publicCassettesSection) {
                publicCassettesSection.style.display = 'block';
            }
            // Reset active state tracking when re-rendering to allow fresh application
            this._lastAppliedActiveCassette = null;
            // Apply active state after rendering from cache
            setTimeout(() => {
                this.applyActiveStateToPublicCassettes();
            }, 100);
        } else {
            // No cache available - show loading indicator
            if (publicCassettesList) {
                publicCassettesList.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; padding: 2rem; color: rgba(255,255,255,0.5); font-size: 0.9rem;">
                        <span>Loading vibes...</span>
                    </div>
                `;
                publicCassettesSection.style.display = 'block';
            }
        }
        
        // Step 2: Check for updates in background
        try {
            const publicCassettes = await this.loadPublicCassettesFromAPI(forceRefresh);
            
            // Merge user's public vibes with server cassettes (user's cassettes take priority)
            // Only add user's cassettes that are NOT already in the server response
            // This prevents duplicates when the server already has the cassette
            const serverExistingIds = new Set(publicCassettes.map(c => c.id));
            const mergedCassettes = [...publicCassettes];
            
            userPublicCassettesWithCreator.forEach(userCassette => {
                const existingIndex = mergedCassettes.findIndex(c => c.id === userCassette.id);
                if (existingIndex >= 0) {
                    // Update existing with user's version (has latest data)
                    // But only if it's the user's own cassette (same creatorId)
                    const existingCassette = mergedCassettes[existingIndex];
                    if (existingCassette.creatorId === this.user?.id) {
                        // Preserve views and viewedBy from server (server is source of truth for views)
                        // Always prefer server views over localStorage views
                        mergedCassettes[existingIndex] = {
                            ...userCassette,
                            views: existingCassette.views !== undefined && existingCassette.views !== null ? existingCassette.views : (userCassette.views !== undefined && userCassette.views !== null ? userCassette.views : 0),
                            viewedBy: existingCassette.viewedBy || userCassette.viewedBy || []
                        };
                    }
                } else {
                    // Add new user's cassette only if it's not in the server response
                    // This handles cases where the cassette was just created and not yet synced
                    if (!serverExistingIds.has(userCassette.id)) {
                        mergedCassettes.push(userCassette);
                    }
                }
            });
            
            // Remove duplicates by ID (keep first occurrence)
            const seenIds = new Set();
            const filteredPublicCassettes = mergedCassettes.filter(cassette => {
                if (seenIds.has(cassette.id)) {
                    return false; // Duplicate, skip it
                }
                seenIds.add(cassette.id);
                return true;
            });
            
            if (filteredPublicCassettes.length === 0) {
                publicCassettesSection.style.display = 'none';
                return;
            }
            
            // Always re-render with fresh data from API + user's cassettes to ensure consistency
            // This ensures that when one user creates a cassette, other users see it immediately
            // And user's own cassettes appear immediately even before server sync
            const cacheKeyForCompare = 'publicCassettesCache';
            const cachedDataForCompare = localStorage.getItem(cacheKeyForCompare);
            const cachedCassettesForCompare = cachedDataForCompare ? JSON.parse(cachedDataForCompare) : [];
            
            // Compare by IDs and updatedAt to detect changes
            // Also compare title, description, and imageUrl to detect content changes
            const currentData = filteredPublicCassettes.map(c => ({ 
                id: c.id, 
                updatedAt: c.updatedAt,
                title: c.title,
                description: c.description,
                imageUrl: c.imageUrl
            })).sort((a, b) => a.id.localeCompare(b.id));
            
            const cachedData = cachedCassettesForCompare.map(c => ({ 
                id: c.id, 
                updatedAt: c.updatedAt,
                title: c.title,
                description: c.description,
                imageUrl: c.imageUrl
            })).sort((a, b) => a.id.localeCompare(b.id));
            
            const hasChanges = JSON.stringify(currentData) !== JSON.stringify(cachedData);
            
            // Determine if we need to render
            // - Always render if we didn't render from cache (new users)
            // - Render if there are changes in the data
            const shouldRender = !renderedFromCache || hasChanges;
            
            if (shouldRender && filteredPublicCassettes.length > 0) {
                this.renderPublicCassettes(filteredPublicCassettes, isGuest);
                // Show section after rendering
                publicCassettesSection.style.display = 'block';
                console.log('üîÑ Updated public vibes UI with fresh data', !renderedFromCache ? '(first load)' : '(changes detected)');
                
                // Apply active state if we didn't already render from cache
                if (!renderedFromCache) {
                    this._lastAppliedActiveCassette = null;
                    setTimeout(() => {
                        this.applyActiveStateToPublicCassettes();
                    }, 100);
                }
            } else if (renderedFromCache) {
                // If we rendered from cache and no changes, make sure section is visible
                publicCassettesSection.style.display = 'block';
            }
            // If rendered from cache and no changes, keep current selection
        } catch (e) {
            console.error('Error loading public vibes:', e);
            // If error and no cache was rendered, hide section
            if (!renderedFromCache && userPublicCassettesWithCreator.length === 0) {
                publicCassettesSection.style.display = 'none';
            }
        } finally {
            // Always reset loading flag when done
            this.isLoadingPublicCassettes = false;
        }
    }
    
    // Format views count: 458, 1K, 1.9K, 1M, etc.
    formatViewsCount(views) {
        if (!views || views === 0) return '0';
        if (views < 1000) return views.toString();
        if (views < 1000000) {
            const thousands = views / 1000;
            if (thousands < 10) {
                // Show one decimal for numbers < 10K (e.g., 1.9K)
                return `${thousands.toFixed(1)}K`.replace(/\.0K$/, 'K');
            }
            // Show whole numbers for >= 10K (e.g., 10K, 99K)
            return `${Math.floor(thousands)}K`;
        }
        // Millions
        const millions = views / 1000000;
        if (millions < 10) {
            return `${millions.toFixed(1)}M`.replace(/\.0M$/, 'M');
        }
        return `${Math.floor(millions)}M`;
    }

    renderPublicCassettes(filteredPublicCassettes, isGuest) {
        const publicCassettesList = document.getElementById('publicCassettesList');
        const publicCassettesSection = document.getElementById('publicCassettesSection');
        
        if (!publicCassettesList || !publicCassettesSection) return;
        
        if (filteredPublicCassettes.length === 0) {
            publicCassettesSection.style.display = 'none';
            return;
        }
        
        // Show section
        publicCassettesSection.style.display = 'block';
        
        // Sort by creation date: newest first (most recent at the top)
        const sortedCassettes = [...filteredPublicCassettes].sort((a, b) => {
            const dateA = new Date(a.createdAt || a.updatedAt || 0);
            const dateB = new Date(b.createdAt || b.updatedAt || 0);
            return dateB - dateA; // Descending order (newest first)
        });
        
        // Render public vibes
        publicCassettesList.innerHTML = sortedCassettes.map(cassette => {
            // Check if this cassette belongs to the current user
            const isOwnCassette = this.user?.id && cassette.creatorId === this.user.id;
            // Escape URL for CSS: escape single quotes and wrap in quotes
            const escapedImageUrl = cassette.imageUrl ? cassette.imageUrl.replace(/'/g, "\\'").replace(/"/g, '\\"') : '';
            const previewStyle = cassette.imageUrl 
                ? `background-image: url('${escapedImageUrl}'); background-size: cover; background-position: center;`
                : 'background: #0a0a0a;';
            
            // Add restriction for guest users
            const requiresAuth = isGuest;
            const signupText = requiresAuth ? '<span class="signup-required-text">(Sign up required)</span>' : '';
            
            // Format views count
            const views = cassette.views || 0;
            const formattedViews = this.formatViewsCount(views);
            
            return `
                <div class="theme-option public-cassette ${requiresAuth ? '' : 'authenticated'}" 
                     data-cassette-id="${cassette.id}" 
                     data-requires-auth="${requiresAuth}"
                     data-is-own="${isOwnCassette}"
                     style="position: relative;">
                    <div class="theme-preview" style="${previewStyle}"></div>
                    <div class="theme-info">
                        <h4>${cassette.title} ${signupText}</h4>
                        <p>${cassette.description || 'Public focus environment'}</p>
                        ${cassette.creatorName ? `<p style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-top: 4px;">created by ${cassette.creatorName}</p>` : ''}
                    </div>
                    <!-- Views counter in bottom right -->
                    <div class="views-counter" style="position: absolute; bottom: 8px; right: 8px; z-index: 10; display: flex; align-items: center; gap: 4px; background: rgba(0, 0, 0, 0.6); padding: 4px 8px; border-radius: 12px; backdrop-filter: blur(4px);">
                        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: rgba(255, 255, 255, 0.8);">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>
                        <span style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.9); font-weight: 500;">${formattedViews}</span>
                    </div>
                    ${isOwnCassette ? `
                    <div style="position: absolute; top: 8px; right: 8px; z-index: 10;">
                        <button class="cassette-options-btn" data-cassette-id="${cassette.id}" title="Vibe options" onclick="event.stopPropagation();">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="1"/>
                                <circle cx="19" cy="12" r="1"/>
                                <circle cx="5" cy="12" r="1"/>
                            </svg>
                        </button>
                        <div class="cassette-options-dropdown" id="publicCassetteOptionsDropdown${cassette.id}" style="display: none;">
                            <div class="cassette-options-menu">
                                <button class="cassette-option-item edit-public-cassette-option" data-cassette-id="${cassette.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                                    </svg>
                                    Edit
                                </button>
                                <button class="cassette-option-item delete-public-cassette-option" data-cassette-id="${cassette.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="3 6 5 6 21 6"/>
                                        <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
                                        <line x1="10" y1="11" x2="10" y2="17"/>
                                        <line x1="14" y1="11" x2="14" y2="17"/>
                                    </svg>
                                    Delete
                                </button>
                            </div>
                        </div>
                    </div>
                    ` : ''}
                </div>
            `;
        }).join('');
        
        // Apply active state will be called separately after rendering
        
        // Add event listeners for public vibes (same approach as private cassettes)
        filteredPublicCassettes.forEach(cassette => {
            const cassetteOption = document.querySelector(`.public-cassette[data-cassette-id="${cassette.id}"]`);
            if (!cassetteOption) return;
            
            const isOwnCassette = this.user?.id && cassette.creatorId === this.user.id;
            const requiresAuth = isGuest;
            
            // Options button (3 dots) - only for own cassettes
            if (isOwnCassette) {
                const optionsBtn = document.querySelector(`.cassette-options-btn[data-cassette-id="${cassette.id}"]`);
                const optionsDropdown = document.getElementById(`publicCassetteOptionsDropdown${cassette.id}`);
                
                if (optionsBtn && optionsDropdown) {
                    optionsBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isVisible = optionsDropdown.style.display === 'block';
                        // Close all other dropdowns first
                        document.querySelectorAll('.cassette-options-dropdown').forEach(dropdown => {
                            dropdown.style.display = 'none';
                        });
                        optionsDropdown.style.display = isVisible ? 'none' : 'block';
                    });
                }
                
                // Edit option
                const editOption = document.querySelector(`.edit-public-cassette-option[data-cassette-id="${cassette.id}"]`);
                if (editOption) {
                    editOption.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (optionsDropdown) optionsDropdown.style.display = 'none';
                        // Find cassette in localStorage to edit
                        const localCassettes = this.getCustomCassettes();
                        const localCassette = localCassettes.find(c => c.id === cassette.id);
                        if (localCassette) {
                            this.showCassetteForm(cassette.id);
                        } else {
                            // If not found in localStorage, use cassette from cache
                            console.warn('Cassette not found in localStorage, using API data');
                            this.showCassetteForm(cassette.id);
                        }
                    });
                }
                
                // Delete option
                const deleteOption = document.querySelector(`.delete-public-cassette-option[data-cassette-id="${cassette.id}"]`);
                if (deleteOption) {
                    deleteOption.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (optionsDropdown) optionsDropdown.style.display = 'none';
                        this.deleteCustomCassette(cassette.id);
                        this.showResourceShareToast('Cassette moved to deleted');
                    });
                }
            }
            
            // Handle cassette selection (only if not clicking on options)
            if (!requiresAuth) {
                cassetteOption.addEventListener('click', (e) => {
                    // Don't trigger if clicking options button or dropdown
                    if (e.target.closest('.cassette-options-btn') || e.target.closest('.cassette-options-dropdown')) {
                        return;
                    }
                    
                    // Remove active from all preset themes
                    document.querySelectorAll('.theme-option[data-theme]').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    
                    // Remove active from all custom vibes
                    document.querySelectorAll('.custom-cassette').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    
                    // Remove active from all public vibes
                    document.querySelectorAll('.public-cassette').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    
                    // Add active to selected cassette
                    cassetteOption.classList.add('active');
                    
                    // Apply the public cassette directly
                    this.applyCustomCassette(cassette);
                    
                    // Save to localStorage
                    const themeName = `custom_${cassette.id}`;
                    localStorage.setItem('lastSelectedTheme', themeName);
                    this.currentTheme = themeName;
                    
                    // Increment views count when cassette is clicked
                    this.incrementCassetteViews(cassette.id, cassetteOption);
                    
                    // Track event
                    this.trackEvent('Vibe Selected', {
                        button_type: 'cassette',
                        vibe_name: cassette.title,
                        cassette_type: 'public',
                        source: 'cassettes_panel'
                    });
                });
            }
        });
        
        // Apply styles for guest users (disabled state)
        filteredPublicCassettes.forEach(cassette => {
            const cassetteOption = document.querySelector(`.public-cassette[data-cassette-id="${cassette.id}"]`);
            if (cassetteOption) {
                const requiresAuth = cassetteOption.getAttribute('data-requires-auth') === 'true';
                if (requiresAuth) {
                    // Disable for guest users
                    cassetteOption.style.opacity = '0.5';
                    cassetteOption.style.cursor = 'not-allowed';
                    cassetteOption.style.pointerEvents = 'none';
                }
            }
        });
        
        // Close dropdown when clicking outside (only add listener once)
        if (!this.publicCassettesDropdownListenerAdded) {
            setTimeout(() => {
                const closeDropdowns = (e) => {
                    if (!e.target.closest('.cassette-options-btn') && !e.target.closest('.cassette-options-dropdown')) {
                        document.querySelectorAll('.cassette-options-dropdown').forEach(dropdown => {
                            dropdown.style.display = 'none';
                        });
                    }
                };
                document.addEventListener('click', closeDropdowns);
                this.publicCassettesDropdownListenerAdded = true;
            }, 100);
        }
    }

    // Increment views count for a public cassette (unique views per user)
    async incrementCassetteViews(cassetteId, cassetteElement) {
        // Only increment for authenticated users
        if (!this.isAuthenticated || !this.user?.id) {
            return; // Guest users don't count views
        }
        
        try {
            const response = await fetch('/api/increment-cassette-views', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-clerk-userid': this.user.id
                },
                body: JSON.stringify({ cassetteId })
            });

            if (response.ok) {
                const data = await response.json();
                if (data.success && data.views !== undefined) {
                    // Update the views count in the UI immediately
                    const viewsSpan = cassetteElement?.querySelector('.views-counter span');
                    if (viewsSpan) {
                        viewsSpan.textContent = this.formatViewsCount(data.views);
                    }
                    
                    // Also update the cassette in cache and localStorage for future loads
                    const cacheKey = 'publicCassettesCache';
                    const cachedData = localStorage.getItem(cacheKey);
                    if (cachedData) {
                        try {
                            const cachedCassettes = JSON.parse(cachedData);
                            const cassetteIndex = cachedCassettes.findIndex(c => c.id === cassetteId);
                            if (cassetteIndex >= 0) {
                                cachedCassettes[cassetteIndex].views = data.views;
                                cachedCassettes[cassetteIndex].viewedBy = data.viewedBy || cachedCassettes[cassetteIndex].viewedBy || [];
                                localStorage.setItem(cacheKey, JSON.stringify(cachedCassettes));
                            }
                        } catch (e) {
                            console.error('Error updating cache:', e);
                        }
                    }
                    
                    // Also update views in localStorage cassette for consistency
                    const localCassettes = this.getCustomCassettes();
                    const localCassetteIndex = localCassettes.findIndex(c => c.id === cassetteId);
                    if (localCassetteIndex >= 0) {
                        localCassettes[localCassetteIndex].views = data.views;
                        localCassettes[localCassetteIndex].viewedBy = data.viewedBy || localCassettes[localCassetteIndex].viewedBy || [];
                        localStorage.setItem('customCassettes', JSON.stringify(localCassettes));
                    }
                }
            }
        } catch (error) {
            console.error('Error incrementing cassette views:', error);
            // Don't show error to user, just log it
        }
    }

    
    applyActiveStateToPublicCassettes() {
        // Check if current theme is a public cassette and mark it as active
        const currentTheme = localStorage.getItem('lastSelectedTheme') || this.currentTheme;
        if (currentTheme && currentTheme.startsWith('custom_')) {
            const cassetteId = currentTheme.replace('custom_', '');
            
            // Track if active state has been applied to prevent duplicate calls
            if (this._lastAppliedActiveCassette === cassetteId) {
                // Already applied, skip to avoid redundant work
                return;
            }
            
            // Try multiple times with increasing delays to ensure DOM is ready
            let applied = false;
            const tryApplyActive = (attempt = 0) => {
                // If already applied, cancel any pending attempts
                if (applied) return;
                
                const activeOption = document.querySelector(`.public-cassette[data-cassette-id="${cassetteId}"]`);
                if (activeOption) {
                    // Remove active from all other options
                    document.querySelectorAll('.theme-option[data-theme]').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    document.querySelectorAll('.custom-cassette').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    document.querySelectorAll('.public-cassette').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    // Add active to current cassette
                    activeOption.classList.add('active');
                    applied = true;
                    this._lastAppliedActiveCassette = cassetteId;
                    console.log('‚úÖ Applied active state to public cassette:', cassetteId);
                } else if (attempt < 3) {
                    // Try again after a delay if not found and haven't exceeded attempts
                    setTimeout(() => tryApplyActive(attempt + 1), 100 * (attempt + 1));
                } else if (attempt === 3) {
                    // Last attempt failed, log warning
                    console.log('‚ö†Ô∏è Public cassette not found in DOM for active state:', cassetteId);
                }
            };
            
            // Start trying immediately
            tryApplyActive(0);
        } else {
            // Not a public cassette, reset tracking
            this._lastAppliedActiveCassette = null;
        }
    }

    async saveCustomCassette(cassette) {
        try {
            const cassettes = this.getCustomCassettes();
            const existingIndex = cassettes.findIndex(c => c.id === cassette.id);
            
            // Check if this is a new cassette (not editing existing)
            const isNewCassette = existingIndex < 0;
            
            console.log('üíæ saveCustomCassette called:', {
                cassetteId: cassette.id,
                cassetteTitle: cassette.title,
                isNewCassette: isNewCassette,
                existingIndex: existingIndex,
                currentCassettesCount: cassettes.length,
                currentCassettes: cassettes.map(c => ({ id: c.id, title: c.title }))
            });
            
            // Free users can only own 1 cassette total (active or deleted)
            if (isNewCassette && !this.isPremiumUser()) {
                const ownedCassettesCount = this.getFreeCassetteOwnershipCount();
                if (ownedCassettesCount >= 1) {
                    alert('Free users can create only 1 cassette. You can edit, delete, and recover that same cassette, or upgrade to Premium for unlimited cassettes.');
                    throw new Error('Total cassette limit reached for free users');
                }
            }
            
            if (existingIndex >= 0) {
                console.log('üìù Updating existing cassette at index:', existingIndex);
                cassettes[existingIndex] = cassette;
            } else {
                console.log('‚ûï Adding new cassette to array');
                cassettes.push(cassette);
                
                // Increment lifetime creation counter (for all users, permanent tracking)
                this.incrementLifetimeCassettesCreated();
            }
            
            console.log('üíæ Saving cassettes to localStorage:', cassettes.map(c => ({ id: c.id, title: c.title })));
            localStorage.setItem('customCassettes', JSON.stringify(cassettes));
            
            // Sync all cassettes to Clerk when authenticated
            if (this.isAuthenticated && this.user?.id) {
                const allCassettes = this.getCustomCassettes();
                try {
                    // Sync public cassettes via dedicated endpoint
                    const response = await fetch('/api/sync-cassettes', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-clerk-userid': this.user.id
                        },
                        body: JSON.stringify({ cassettes: allCassettes })
                    });
                    if (!response.ok) {
                        console.error('‚ùå Error syncing public cassettes to Clerk:', response.statusText);
                    } else {
                        console.log('‚úÖ Public cassettes synced to Clerk');
                    }
                    
                    // Also backup ALL cassettes (including private) via sync-stats
                    const stats = this.getFocusStats();
                    await fetch('/api/sync-stats', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'x-clerk-userid': this.user.id
                        },
                        body: JSON.stringify({ 
                            totalHours: stats?.totalHours || 0,
                            customCassettes: allCassettes
                        })
                    });
                    console.log('‚úÖ All cassettes (including private) backed up to Clerk');
                } catch (err) {
                    console.error('‚ùå Error syncing cassettes to Clerk:', err);
                }
            }
            
            return cassette;
        } catch (error) {
            console.error('Error saving custom cassette:', error);
            throw error;
        }
    }

    // Show delete cassette confirmation modal
    showDeleteCassetteConfirmation(cassetteId, cassetteName) {
        const isPremium = this.isPremiumUser();
        
        // Escape the cassette name to prevent XSS
        const escapedName = this.escapeHtml(cassetteName);
        
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'focus-stats-overlay';
        overlay.style.display = 'flex';
        
        // Create modal
        const modal = document.createElement('div');
        modal.className = 'logout-modal';
        modal.style.cssText = 'max-width: 440px; padding: 32px; position: relative;';
        
        // Warning message differs for free vs premium
        const warningMessage = !isPremium
            ? 'You can recover this cassette later from "Recover deleted cassettes".'
            : 'You can recover this cassette later from "Recover deleted cassettes".';
        
        modal.innerHTML = `
            <button class="close-modal-x" id="closeDeleteCassetteModal" style="position: absolute; top: 16px; right: 16px; background: none; border: none; color: rgba(255,255,255,0.6); cursor: pointer; padding: 8px; display: flex; align-items: center; justify-content: center;">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
            
            <h3 style="font-size: 20px; font-weight: 600; margin-bottom: 16px; color: white; line-height: 1.3; text-align: left;">
                Delete cassette?
            </h3>
            <p style="font-size: 14px; color: rgba(255,255,255,0.7); margin-bottom: 32px; line-height: 1.5; text-align: left;">
                ${warningMessage}
            </p>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button class="logout-modal-btn logout-modal-btn-secondary" id="cancelDeleteCassette">Cancel</button>
                <button class="logout-modal-btn logout-modal-btn-primary" id="confirmDeleteCassette">Delete</button>
            </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        const close = () => {
            try { document.body.removeChild(overlay); } catch (_) {}
        };
        
        // Close X button
        modal.querySelector('#closeDeleteCassetteModal').addEventListener('click', close);
        
        // Cancel button
        modal.querySelector('#cancelDeleteCassette').addEventListener('click', close);
        
        // Confirm button
        modal.querySelector('#confirmDeleteCassette').addEventListener('click', () => {
            this.deleteCustomCassette(cassetteId);
            close();
        });
    }

    async deleteCustomCassette(cassetteId) {
        try {
            const cassettes = this.getCustomCassettes();
            const cassetteToDelete = cassettes.find(c => c.id === cassetteId);
            if (cassetteToDelete) {
                const deletedCassettes = this.getDeletedCassettesTrash();
                const dedupedDeleted = deletedCassettes.filter(c => c.id !== cassetteId);
                const updatedDeleted = [cassetteToDelete, ...dedupedDeleted].slice(0, 20);
                this.saveDeletedCassettesTrash(updatedDeleted);
            }

            const filtered = cassettes.filter(c => c.id !== cassetteId);
            localStorage.setItem('customCassettes', JSON.stringify(filtered));
            
            // Immediately remove the cassette from the DOM for instant UI feedback
            const customCassetteElement = document.querySelector(`.custom-cassette[data-cassette-id="${cassetteId}"]`);
            if (customCassetteElement) {
                customCassetteElement.remove();
            }
            const publicCassetteElement = document.querySelector(`.public-cassette[data-cassette-id="${cassetteId}"]`);
            if (publicCassetteElement) {
                publicCassetteElement.remove();
            }
            
            // Remove the cassette from the public vibes cache immediately
            this.removeCassetteFromPublicCache(cassetteId);
            
            // Sync cassettes to Clerk after deletion
            if (this.isAuthenticated && this.user?.id) {
                const allCassettes = this.getCustomCassettes();
                
                // Sync public cassettes via dedicated endpoint
                fetch('/api/sync-cassettes', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-clerk-userid': this.user.id
                    },
                    body: JSON.stringify({ cassettes: allCassettes })
                }).then(response => {
                    if (response.ok) {
                        console.log('‚úÖ Public cassettes synced to Clerk after deletion');
                    } else {
                        console.error('‚ùå Error syncing public cassettes to Clerk:', response.statusText);
                    }
                }).catch(err => {
                    console.error('‚ùå Error syncing public cassettes to Clerk:', err);
                });
                
                // Also sync ALL cassettes (including private) to backup via sync-stats
                const stats = this.getFocusStats();
                fetch('/api/sync-stats', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-clerk-userid': this.user.id
                    },
                    body: JSON.stringify({ 
                        totalHours: stats?.totalHours || 0,
                        customCassettes: allCassettes
                    })
                }).then(response => {
                    if (response.ok) {
                        console.log('‚úÖ All cassettes (including private) backed up to Clerk after deletion');
                    }
                }).catch(err => {
                    console.error('‚ùå Error backing up cassettes:', err);
                });
            }
            
            // If this was the active theme, switch to lofi
            if (this.currentTheme === `custom_${cassetteId}`) {
                this.applyTheme('lofi');
            }
            
            // Reload custom vibes (synchronous)
            this.loadCustomCassettes();
            this.refreshRecoverDeletedCassettesButton();
            
            // Reload public vibes in background - the cassette is already removed from DOM and cache
            // so even if API still returns it, the cache update will handle it correctly
            this.loadPublicCassettes(true).catch(err => {
                console.error('Error reloading public vibes after deletion:', err);
            });
        } catch (error) {
            console.error('Error deleting custom cassette:', error);
        }
    }

    selectCustomCassette(cassetteId) {
        const cassettes = this.getCustomCassettes();
        const cassette = cassettes.find(c => c.id === cassetteId);
        
        if (!cassette) return;
        
        // Reset active cassette tracking when selecting a new cassette
        if (this._lastAppliedActiveCassette !== cassetteId) {
            this._lastAppliedActiveCassette = null;
        }
        
        // Remove active from all preset themes
        document.querySelectorAll('.theme-option[data-theme]').forEach(opt => {
            opt.classList.remove('active');
        });
        
        // Remove active from all custom vibes
        document.querySelectorAll('.custom-cassette').forEach(opt => {
            opt.classList.remove('active');
        });
        
        // Remove active from all public vibes
        document.querySelectorAll('.public-cassette').forEach(opt => {
            opt.classList.remove('active');
        });
        
        // Add active to selected cassette
        const cassetteOption = document.querySelector(`[data-cassette-id="${cassetteId}"]`);
        if (cassetteOption) {
            cassetteOption.classList.add('active');
        }
        
        // Apply the custom vibe
        this.applyCustomCassette(cassette);
        
        // Save to localStorage
        const themeName = `custom_${cassetteId}`;
        localStorage.setItem('lastSelectedTheme', themeName);
        this.currentTheme = themeName;
        
        // Track event
        this.trackEvent('Vibe Selected', {
            button_type: 'cassette',
            vibe_name: cassette.title,
            cassette_type: 'custom',
            source: 'cassettes_panel'
        });
    }

    applyCustomCassette(cassette) {
        const timerSection = document.querySelector('.timer-section');
        if (!timerSection) return;
        
        // If this is a public cassette, try to get latest data from server cache
        if (cassette.isPublic && cassette.id) {
            const cacheKey = 'publicCassettesCache';
            const cachedData = localStorage.getItem(cacheKey);
            if (cachedData) {
                try {
                    const cachedCassettes = JSON.parse(cachedData);
                    const serverCassette = cachedCassettes.find(c => c.id === cassette.id);
                    if (serverCassette) {
                        // Update cassette with server data (server is source of truth)
                        if (serverCassette.views !== undefined) {
                            cassette.views = serverCassette.views;
                        }
                        if (serverCassette.viewedBy !== undefined) {
                            cassette.viewedBy = serverCassette.viewedBy || [];
                        }
                    }
                } catch (e) {
                    console.error('Error parsing cache when applying cassette:', e);
                }
            }
        }
        
        // Pause timer when changing cassettes
        if (this.isRunning) {
            this.pauseTimer();
        }
        
        // Stop other music and disable Lofi
        this.stopLofiPlaylist();
        this.lofiEnabled = false;
        if (this.isAuthenticated) {
            localStorage.setItem('lofiEnabled', 'false');
        }
        
        // Stop Tron theme if active
        if (this.currentImmersiveTheme === 'tron') {
            this.deactivateImmersiveTheme();
        }
        
        // Remove all background classes
        timerSection.classList.remove('theme-minimalist', 'theme-woman', 'theme-man');
        
        // Remove custom Spotify widget from previous custom vibe only if URL is different
        const existingWidget = document.getElementById('customSpotifyWidget');
        if (existingWidget) {
            // Check if we need to recreate the widget (only if URL changed)
            if (cassette.spotifyUrl && this.currentSpotifyUrl === cassette.spotifyUrl) {
                // Same Spotify URL, keep the existing widget
                console.log('üéµ Spotify widget already exists with same URL, keeping it');
            } else {
                // Different or no Spotify URL, remove existing widget
                existingWidget.remove();
                this.currentSpotifyUrl = null;
            }
        }
        
        // Remove custom website link from previous custom vibe
        const existingLink = document.getElementById('customWebsiteLink');
        if (existingLink) {
            existingLink.remove();
        }
        
        // Set background image if provided
        if (cassette.imageUrl) {
            console.log('üé® Setting custom vibe background image:', cassette.imageUrl);
            
            // Escape URL for CSS: escape single quotes
            const escapedImageUrl = cassette.imageUrl.replace(/'/g, "\\'").replace(/"/g, '\\"');
            
            // Apply background image directly - CSS handles loading gracefully
            // No need for CORS image test which causes errors with many image hosts (Pinterest, etc.)
            timerSection.style.setProperty('background-image', `url('${escapedImageUrl}')`, 'important');
            timerSection.style.setProperty('background-size', 'cover', 'important');
            timerSection.style.setProperty('background-position', 'center', 'important');
            timerSection.style.setProperty('background-repeat', 'no-repeat', 'important');
            timerSection.style.setProperty('background-color', 'transparent', 'important');
            
            console.log('üé® Applied background styles:', {
                backgroundImage: timerSection.style.backgroundImage,
                backgroundSize: timerSection.style.backgroundSize,
                backgroundPosition: timerSection.style.backgroundPosition
            });
        } else {
            // Remove all background properties
            timerSection.style.removeProperty('background-image');
            timerSection.style.removeProperty('background-size');
            timerSection.style.removeProperty('background-position');
            timerSection.style.removeProperty('background-repeat');
            timerSection.style.removeProperty('background-color');
            timerSection.style.setProperty('background', '#0a0a0a', 'important');
        }
        
        // Create Spotify widget if URL provided and different from current
        if (cassette.spotifyUrl && this.currentSpotifyUrl !== cassette.spotifyUrl) {
            this.createCustomSpotifyWidget(cassette.spotifyUrl);
        } else if (!cassette.spotifyUrl && this.currentSpotifyUrl) {
            // If no Spotify URL but one exists, remove it
            const widgetToRemove = document.getElementById('customSpotifyWidget');
            if (widgetToRemove) {
                widgetToRemove.remove();
            }
            this.currentSpotifyUrl = null;
        }
        
        
        // Save as current theme
        const themeName = `custom_${cassette.id}`;
        localStorage.setItem('lastSelectedTheme', themeName);
        this.currentTheme = themeName;
        
        // Update visual active state
        this.updateThemeActiveState(themeName);
        
        console.log('üé® Custom vibe applied:', cassette.title);
    }


    createCustomSpotifyWidget(spotifyUrl) {
        // Check if widget already exists with same URL
        const existingWidget = document.getElementById('customSpotifyWidget');
        if (existingWidget && this.currentSpotifyUrl === spotifyUrl) {
            console.log('üéµ Spotify widget already exists with same URL, skipping recreation');
            return;
        }
        
        // Remove existing custom Spotify widget if URL is different
        if (existingWidget) {
            existingWidget.remove();
        }
        
        // Save current Spotify URL
        this.currentSpotifyUrl = spotifyUrl;
        
        // Extract Spotify track/playlist/album ID from URL
        const spotifyId = this.extractSpotifyId(spotifyUrl);
        if (!spotifyId) {
            console.error('Invalid Spotify URL');
            return;
        }
        
        // Create Spotify iframe (same format as Tron)
        const widget = document.createElement('iframe');
        widget.id = 'customSpotifyWidget';
        widget.src = `https://open.spotify.com/embed/${spotifyId.type}/${spotifyId.id}?utm_source=generator`;
        widget.width = '100%';
        widget.height = '352';
        widget.frameBorder = '0';
        widget.allowTransparency = 'true';
        widget.setAttribute('title', 'Spotify Music Player');
        widget.setAttribute('aria-label', 'Spotify Music Player');
        widget.setAttribute('referrerpolicy', 'no-referrer');
        widget.setAttribute('data-testid', 'embed-iframe');
        widget.allow = 'autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture';
        widget.loading = 'lazy';
        
        // Style the widget (same as Tron)
        widget.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 352px;
            z-index: 1000;
            border-radius: 12px;
            border: none;
            pointer-events: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
            opacity: 0.8;
        `;
        
        // Create login instructions message
        // Remove any existing instructions modal first
        const existingInstructions = document.getElementById('spotifyWidgetInstructions');
        if (existingInstructions) {
            existingInstructions.remove();
        }
        
        // Show instructions only the first time
        const hasSeenInstructions = localStorage.getItem('spotify_widget_instructions_seen') === 'true';
        if (!hasSeenInstructions) {
            const instructionsDiv = document.createElement('div');
            instructionsDiv.id = 'spotifyWidgetInstructions';
            instructionsDiv.style.cssText = `
                position: fixed;
                bottom: 392px;
                right: 20px;
                width: 300px;
                background: rgba(0, 0, 0, 0.95);
                color: #ffffff;
                padding: 16px;
                border-radius: 12px;
                border: none;
                z-index: 1001;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                font-size: 13px;
                line-height: 1.5;
                box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            `;
            instructionsDiv.innerHTML = `
                <div style="display: flex; align-items: flex-start; gap: 12px;">
                    <div style="color: #1db954; font-size: 20px; flex-shrink: 0;">üéµ</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #ffffff;">Listen to full songs</div>
                        <div style="color: rgba(255, 255, 255, 0.9); margin-bottom: 12px;">
                            Click on the Spotify logo inside the widget to log in and listen to full songs instead of just preview. Make sure third-party cookies are enabled in your browser settings.
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button id="spotifyLoggedInBtn" style="
                                background: #1db954;
                                color: #000000;
                                border: none;
                                border-radius: 6px;
                                padding: 8px 16px;
                                font-size: 12px;
                                font-weight: 600;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                flex: 1;
                            ">I'm logged in</button>
                            <button id="spotifyInstructionsClose" style="
                                background: rgba(255, 255, 255, 0.1);
                                color: #ffffff;
                                border: 1px solid rgba(255, 255, 255, 0.2);
                                border-radius: 6px;
                                padding: 8px 12px;
                                font-size: 12px;
                                cursor: pointer;
                                transition: all 0.2s ease;
                            ">Close</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(instructionsDiv);
            
            // Add direct event listeners to buttons for better reliability
            // Use setTimeout to ensure DOM is fully ready
            setTimeout(() => {
                const closeBtn = instructionsDiv.querySelector('#spotifyInstructionsClose');
                const loggedInBtn = instructionsDiv.querySelector('#spotifyLoggedInBtn');
                
                let isClosing = false;
                
                if (closeBtn) {
                    const closeHandler = (e) => {
                        if (isClosing) {
                            e.preventDefault();
                            e.stopPropagation();
                            e.stopImmediatePropagation();
                            return;
                        }
                        isClosing = true;
                        
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        
                        // Remove the modal completely instead of just hiding it
                        if (instructionsDiv && instructionsDiv.parentNode) {
                            instructionsDiv.parentNode.removeChild(instructionsDiv);
                        }
                        // Save to localStorage so message doesn't show again
                        localStorage.setItem('spotify_widget_instructions_seen', 'true');
                    };
                    
                    closeBtn.addEventListener('click', closeHandler, { once: true, capture: true });
                }
                
                if (loggedInBtn) {
                    loggedInBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        
                        // Reload widget by removing and recreating it
                        widget.remove();
                        instructionsDiv.style.display = 'none';
                        // Save to localStorage so message doesn't show again
                        localStorage.setItem('spotify_widget_instructions_seen', 'true');
                        // Recreate widget after a short delay
                        setTimeout(() => {
                            this.createCustomSpotifyWidget(spotifyUrl);
                        }, 500);
                    }, { once: true, capture: true });
                }
            }, 0);
        }
        
        // Set up timeout handling (same as Tron)
        let loadTimeout;
        let isLoaded = false;
        
        const handleLoad = () => {
            if (isLoaded) return;
            isLoaded = true;
            clearTimeout(loadTimeout);
            
            widget.style.opacity = '1';
            console.log('üéµ Custom Spotify widget loaded successfully');
        };
        
        const handleError = () => {
            if (isLoaded) return;
            isLoaded = true;
            clearTimeout(loadTimeout);
            
            console.error('‚ùå Custom Spotify widget failed to load');
            widget.style.opacity = '0.7';
        };
        
        const handleTimeout = () => {
            if (isLoaded) return;
            isLoaded = true;
            clearTimeout(loadTimeout);
            
            console.warn('‚ö†Ô∏è Custom Spotify widget loading timeout');
            widget.style.opacity = '0.7';
        };
        
        // Set timeout for 10 seconds
        loadTimeout = setTimeout(handleTimeout, 10000);
        
        // Add event listeners
        widget.addEventListener('load', handleLoad);
        widget.addEventListener('error', handleError);
        
        document.body.appendChild(widget);
        
        console.log('üéµ Custom Spotify widget created');
    }

    extractSpotifyId(url) {
        // Extract type and ID from Spotify URL
        // Format: https://open.spotify.com/track/... or /playlist/... or /album/...
        const match = url.match(/open\.spotify\.com\/(track|playlist|album)\/([a-zA-Z0-9]+)/);
        if (match) {
            return {
                type: match[1],
                id: match[2]
            };
        }
        return null;
    }

    showCassetteForm(cassetteId = null) {
        // Guest users must login first
        if (!this.isAuthenticated) {
            this.trackEvent('Login Required Modal Shown', {
                feature: 'custom_cassettes',
                source: 'create_cassette_button',
                user_type: 'guest',
                modal_type: 'login_required'
            });
            
            this.showCassetteLoginModal();
            return;
        }
        
        // Free users can own only 1 cassette total (active or deleted), Premium users unlimited
        if (!this.isPremiumUser() && !cassetteId) {
            const ownedCassetteCount = this.getFreeCassetteOwnershipCount();

            if (ownedCassetteCount >= 1) {
                this.trackEvent('Pro Feature Modal Shown', {
                    feature: 'custom_cassettes',
                    source: 'create_cassette_button',
                    user_type: 'free',
                    modal_type: 'upgrade_prompt',
                    owned_cassettes_count: ownedCassetteCount,
                    reason: 'total_cassette_limit_reached'
                });
                
                this.showCassetteProModal('Free users can create only 1 custom cassette. You can edit, delete, and recover that same cassette. Upgrade to Premium for unlimited cassettes and personalize your focus environment.');
                return;
            }
            // Free user has no owned cassette yet - continue to form
        }
        
        // Pro users can create cassettes
        const form = document.getElementById('cassetteForm');
        const createBtn = document.getElementById('createCassetteBtn');
        const saveBtn = document.getElementById('saveCassetteBtn');
        
        if (!form || !createBtn) return;
        
        // Load cassette data if editing
        if (cassetteId) {
            let cassette = null;
            
            // First try to find in localStorage
            const cassettes = this.getCustomCassettes();
            cassette = cassettes.find(c => c.id === cassetteId);
            
            // If not found in localStorage, try to find in public vibes cache
            if (!cassette) {
                const cacheKey = 'publicCassettesCache';
                const cachedData = localStorage.getItem(cacheKey);
                if (cachedData) {
                    try {
                        const cachedCassettes = JSON.parse(cachedData);
                        cassette = cachedCassettes.find(c => c.id === cassetteId);
                        // Check if it's the user's own cassette
                        if (cassette && this.user?.id && cassette.creatorId === this.user.id) {
                            console.log('üì¶ Found cassette in public cache for editing');
                        } else {
                            cassette = null; // Not user's own cassette
                        }
                    } catch (e) {
                        console.error('Error parsing cached public vibes:', e);
                    }
                }
            }
            
            if (cassette) {
                document.getElementById('cassetteTitle').value = cassette.title || '';
                document.getElementById('cassetteDescription').value = cassette.description || '';
                document.getElementById('cassetteImageUrl').value = cassette.imageUrl || '';
                document.getElementById('cassetteSpotifyUrl').value = cassette.spotifyUrl || '';
                const isPublicCheckbox = document.getElementById('cassetteIsPublic');
                if (isPublicCheckbox) {
                    isPublicCheckbox.checked = cassette.isPublic === true;
                }
                
                // Store editing ID in save button
                if (saveBtn) {
                    saveBtn.dataset.editingId = cassetteId;
                    saveBtn.textContent = 'Update';
                }
            } else {
                console.error('Cassette not found for editing:', cassetteId);
                alert('Error: Cassette not found. Please try again.');
                return;
            }
        } else {
            // Clear form for new cassette
            document.getElementById('cassetteTitle').value = '';
            document.getElementById('cassetteDescription').value = '';
            document.getElementById('cassetteImageUrl').value = '';
            document.getElementById('cassetteSpotifyUrl').value = '';
            const isPublicCheckbox = document.getElementById('cassetteIsPublic');
            if (isPublicCheckbox) {
                isPublicCheckbox.checked = false;
            }
            
            if (saveBtn) {
                delete saveBtn.dataset.editingId;
                saveBtn.textContent = 'Save';
            }
        }
        
        // Show form and hide button
        form.style.display = 'block';
        createBtn.style.display = 'none';
        
        // Initialize validation listeners for the form
        setTimeout(() => {
            this.initializeImageUrlValidation();
        }, 50);
        
        // Focus on title input
        const titleInput = document.getElementById('cassetteTitle');
        if (titleInput) {
            setTimeout(() => titleInput.focus(), 100);
        }
    }
    
    hideCassetteForm() {
        const form = document.getElementById('cassetteForm');
        const createBtn = document.getElementById('createCassetteBtn');
        const saveBtn = document.getElementById('saveCassetteBtn');
        
        if (!form || !createBtn) return;
        
        // Hide warning message when hiding form
        const warningElement = document.getElementById('imageUrlWarning');
        if (warningElement) {
            warningElement.style.display = 'none';
        }
        
        // Reset save button state when hiding form
        if (saveBtn) {
            saveBtn.disabled = true;
            saveBtn.style.opacity = '0.5';
            saveBtn.style.cursor = 'not-allowed';
        }
        
        // Hide form and show button
        form.style.display = 'none';
        createBtn.style.display = 'block';
        
        // Clear editing ID
        if (saveBtn) {
            delete saveBtn.dataset.editingId;
            saveBtn.textContent = 'Save';
        }
        
        // Clear form
        document.getElementById('cassetteTitle').value = '';
        document.getElementById('cassetteDescription').value = '';
        document.getElementById('cassetteImageUrl').value = '';
        document.getElementById('cassetteSpotifyUrl').value = '';
        const isPublicCheckbox = document.getElementById('cassetteIsPublic');
        if (isPublicCheckbox) {
            isPublicCheckbox.checked = false;
        }
    }

    extractImageUrl(url) {
        if (!url) return '';
        
        // If it's a Google Images URL, extract the actual image URL
        if (url.includes('google.com/url') && url.includes('url=')) {
            try {
                // Extract the URL parameter from the query string
                const urlObj = new URL(url);
                const actualUrl = urlObj.searchParams.get('url');
                if (actualUrl) {
                    const decodedUrl = decodeURIComponent(actualUrl);
                    console.log('üé® Extracted URL from Google Images link:', decodedUrl);
                    
                    // Check if the extracted URL is actually an image URL
                    // If it's not an image URL (ends with .jpg, .png, .gif, .webp, etc.), return empty
                    // This means the user needs to get the direct image URL
                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp'];
                    const isImageUrl = imageExtensions.some(ext => 
                        decodedUrl.toLowerCase().includes(ext) || 
                        decodedUrl.toLowerCase().includes('image') ||
                        decodedUrl.includes('i.imgur.com') ||
                        decodedUrl.includes('cdn.') ||
                        decodedUrl.includes('/images/')
                    );
                    
                    if (!isImageUrl) {
                        console.warn('‚ö†Ô∏è Extracted URL is not a direct image URL:', decodedUrl);
                        return ''; // Return empty to trigger the error message
                    }
                    
                    return decodedUrl;
                }
            } catch (e) {
                console.error('Error extracting URL from Google Images link:', e);
                // Try manual parsing as fallback
                const match = url.match(/url=([^&]+)/);
                if (match) {
                    try {
                        const decodedUrl = decodeURIComponent(match[1]);
                        // Check if it's an image URL
                        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp'];
                        const isImageUrl = imageExtensions.some(ext => 
                            decodedUrl.toLowerCase().includes(ext) || 
                            decodedUrl.toLowerCase().includes('image') ||
                            decodedUrl.includes('i.imgur.com') ||
                            decodedUrl.includes('cdn.')
                        );
                        
                        if (!isImageUrl) {
                            return '';
                        }
                        
                        return decodedUrl;
                    } catch (e2) {
                        console.error('Error decoding URL:', e2);
                    }
                }
            }
        }
        
        return url;
    }

    async saveCassetteFromForm(cassetteId = null) {
        // Get cassetteId from save button if not provided
        const saveBtn = document.getElementById('saveCassetteBtn');
        if (!cassetteId && saveBtn && saveBtn.dataset.editingId) {
            cassetteId = saveBtn.dataset.editingId;
        }
        
        const titleEl = document.getElementById('cassetteTitle');
        const descriptionEl = document.getElementById('cassetteDescription');
        const imageUrlEl = document.getElementById('cassetteImageUrl');
        const spotifyUrlEl = document.getElementById('cassetteSpotifyUrl');
        const isPublicCheckbox = document.getElementById('cassetteIsPublic');
        
        if (!titleEl || !descriptionEl || !imageUrlEl || !spotifyUrlEl) {
            console.error('Form elements not found', {
                titleEl: !!titleEl,
                descriptionEl: !!descriptionEl,
                imageUrlEl: !!imageUrlEl,
                spotifyUrlEl: !!spotifyUrlEl
            });
            alert('Error: Form elements not found. Please try again.');
            return false;
        }
        
        // Get values with debug logging
        const title = titleEl ? (titleEl.value || titleEl.textContent || '').trim() : '';
        const description = descriptionEl ? (descriptionEl.value || descriptionEl.textContent || '').trim() : '';
        let imageUrl = imageUrlEl ? (imageUrlEl.value || imageUrlEl.textContent || '').trim() : '';
        const spotifyUrl = spotifyUrlEl ? (spotifyUrlEl.value || spotifyUrlEl.textContent || '').trim() : '';
        const isPublic = isPublicCheckbox ? isPublicCheckbox.checked : false;
        
        console.log('üíæ Saving cassette:', { 
            title: title, 
            cassetteId: cassetteId, 
            isEditing: !!cassetteId,
            formData: { title, description, imageUrl: imageUrl?.substring(0, 50), spotifyUrl: spotifyUrl?.substring(0, 50), isPublic }
        });
        
        // Validate title (only required field)
        if (!title || title.trim().length === 0) {
            alert('Title is required');
            if (titleEl) titleEl.focus();
            return false;
        }
        
        // Extract actual image URL if it's a Google Images redirect
        if (imageUrl) {
            const originalUrl = imageUrl;
            imageUrl = this.extractImageUrl(imageUrl);
            console.log('üé® Original URL:', originalUrl);
            console.log('üé® Final image URL:', imageUrl);
            
            const trimmedUrl = imageUrl.trim().toLowerCase();

            // Check for Google Images redirect (these are invalid)
            const isGoogleRedirect = trimmedUrl.includes('google.com/url') || trimmedUrl.includes('google.com/imgres');
            if (isGoogleRedirect) {
                alert('‚ö†Ô∏è Error: Google Search results are not direct images.\n\nPlease right-click the image and select "Copy Image Address".');
                if (imageUrlEl) imageUrlEl.focus();
                return false;
            }

            // Trusted image hosting services (these don't need extensions)
            const trustedHosts = [
                'i.imgur.com',
                'images.unsplash.com',
                'cdn.unsplash.com',
                'images.pexels.com',
                'cdn.pexels.com',
                'imgur.com/a/',
                'imgur.com/gallery/',
                'unsplash.com/photos/',
                'pexels.com/photo/',
                'drive.google.com/uc', // Google Drive direct links
                'pbs.twimg.com/media/' // Twitter images
            ];
            const isTrustedHost = trustedHosts.some(host => trimmedUrl.includes(host));
            
            if (!isTrustedHost) {
                // Remove query parameters for extension check
                const urlWithoutQuery = trimmedUrl.split('?')[0].split('#')[0];
                
                // List of valid image extensions
                const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp', '.tiff', '.ico', '.avif'];
                const hasImageExtension = imageExtensions.some(ext => urlWithoutQuery.endsWith(ext));
                
                if (!hasImageExtension) {
                    // Show warning but allow user to continue
                    const proceed = confirm('‚ö†Ô∏è Warning: This might not be a direct image URL.\n\nThe image might not display correctly.\n\nüí° Tip: Right-click the image and select "Copy image address"\n\nDo you want to save anyway?');
                    if (!proceed) {
                        if (imageUrlEl) imageUrlEl.focus();
                        return false;
                    }
                    // User chose to proceed - continue with save
                    console.log('‚ö†Ô∏è User chose to save with potentially invalid image URL:', imageUrl);
                }
            }
        }
        
        // Get previous cassette state if editing
        const previousCassette = cassetteId ? this.getCustomCassettes().find(c => c.id === cassetteId) : null;
        const wasPublic = previousCassette?.isPublic === true;
        const isNowPublic = isPublic === true;
        const changedFromPublicToPrivate = wasPublic && !isNowPublic;
        const changedFromPrivateToPublic = !wasPublic && isNowPublic;
        
        // Get views and viewedBy from server if available (server is source of truth)
        // This preserves historical data when changing from private to public or editing a public cassette
        let serverViews = 0;
        let serverViewedBy = [];
        
        // Check if cassette was previously public or is being changed to public
        if (cassetteId && (previousCassette?.isPublic || isNowPublic)) {
            // Try to get data from server cache first
            const cacheKey = 'publicCassettesCache';
            const cachedData = localStorage.getItem(cacheKey);
            if (cachedData) {
                try {
                    const cachedCassettes = JSON.parse(cachedData);
                    const serverCassette = cachedCassettes.find(c => c.id === cassetteId);
                    if (serverCassette) {
                        if (serverCassette.views !== undefined && serverCassette.views !== null) {
                            serverViews = serverCassette.views;
                        }
                        if (serverCassette.viewedBy !== undefined) {
                            serverViewedBy = serverCassette.viewedBy || [];
                        }
                    }
                } catch (e) {
                    console.error('Error parsing cache:', e);
                }
            }
            
            // Also check if previous cassette had historical data
            if (previousCassette) {
                // Preserve views if they exist in previous cassette (might be from Clerk)
                if (previousCassette.views !== undefined && previousCassette.views !== null && previousCassette.views > serverViews) {
                    serverViews = previousCassette.views;
                }
                if (previousCassette.viewedBy && previousCassette.viewedBy.length > serverViewedBy.length) {
                    serverViewedBy = previousCassette.viewedBy;
                }
            }
        }
        
        const cassette = {
            id: cassetteId || `cassette_${Date.now()}`,
            title: title,
            description: description || '',
            imageUrl: imageUrl || '',
            spotifyUrl: spotifyUrl || '',
            isPublic: isPublic,
            // Preserve views from server if available (server is source of truth for views)
            // When changing from private to public, preserve historical data from Clerk
            views: (serverViews > 0 || (previousCassette?.views !== undefined && previousCassette.views !== null)) 
                ? Math.max(serverViews, previousCassette?.views || 0) 
                : 0,
            // Preserve viewedBy from server if available (server is source of truth for viewedBy)
            viewedBy: (serverViewedBy.length > 0 || (previousCassette?.viewedBy && previousCassette.viewedBy.length > 0))
                ? (serverViewedBy.length >= (previousCassette?.viewedBy?.length || 0) ? serverViewedBy : previousCassette.viewedBy)
                : [],
            createdAt: cassetteId ? previousCassette?.createdAt || new Date().toISOString() : new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        try {
            const savedCassette = await this.saveCustomCassette(cassette);
            
            if (!savedCassette) {
                alert('Error saving cassette. Please try again.');
                return false;
            }
            
            // Hide form immediately for better UX (no delay)
            this.hideCassetteForm();
            
            // Update UI and handle async operations in background
            const handleSuccess = async () => {
                // The cassette is already saved to localStorage in saveCustomCassette
                // Now we need to update the UI immediately
                
                // Update the UI immediately from localStorage (no delay)
                this.loadCustomCassettes();
                
                // If cassette changed from public to private, remove it from public list immediately
                if (changedFromPublicToPrivate) {
                    // Remove the cassette from the public vibes list in the UI immediately
                    const publicCassetteElement = document.querySelector(`.public-cassette[data-cassette-id="${cassette.id}"]`);
                    if (publicCassetteElement) {
                        publicCassetteElement.remove();
                        console.log('üóëÔ∏è Removed cassette from public list:', cassette.id);
                    }
                    
                    // Invalidate cache to remove the cassette from public list
                    this.invalidatePublicCassettesCache();
                    // Reload public vibes in background (don't wait for it)
                    this.loadPublicCassettes(true).catch(err => console.error('Error reloading public vibes:', err));
                } else if (isNowPublic || changedFromPrivateToPublic || (cassetteId && cassette.isPublic)) {
                    // If it's a public cassette or changed to public, or editing an existing public cassette
                    
                    // If changed from private to public, remove from custom vibes list immediately
                    if (changedFromPrivateToPublic) {
                        const customCassetteElement = document.querySelector(`.custom-cassette[data-cassette-id="${cassette.id}"]`);
                        if (customCassetteElement) {
                            customCassetteElement.remove();
                            console.log('üîÑ Moved cassette from custom to public list:', cassette.id);
                        }
                    }
                    
                    // Check if cassette element already exists in public vibes
                    const existingPublicElement = document.querySelector(`.public-cassette[data-cassette-id="${cassette.id}"]`);
                    
                    if (existingPublicElement) {
                        // Update existing card immediately with new data
                        const previewDiv = existingPublicElement.querySelector('.theme-preview');
                        const titleH4 = existingPublicElement.querySelector('.theme-info h4');
                        const descriptionP = existingPublicElement.querySelector('.theme-info p:first-of-type');
                        
                        if (previewDiv) {
                            previewDiv.style.backgroundImage = cassette.imageUrl 
                                ? `url('${cassette.imageUrl}')` 
                                : 'none';
                            previewDiv.style.backgroundSize = 'cover';
                            previewDiv.style.backgroundPosition = 'center';
                            if (!cassette.imageUrl) {
                                previewDiv.style.background = '#0a0a0a';
                            }
                        }
                        if (titleH4) {
                            const signupText = titleH4.querySelector('.signup-required-text')?.outerHTML || '';
                            titleH4.innerHTML = `${cassette.title} ${signupText}`;
                        }
                        if (descriptionP) {
                            descriptionP.textContent = cassette.description || 'Public focus environment';
                        }
                        console.log('‚úÖ Updated public cassette card immediately:', cassette.id);
                    } else if ((!cassetteId && isNowPublic) || changedFromPrivateToPublic) {
                        // NEW public cassette OR changed from private to public - add it to the UI immediately
                        const publicCassettesList = document.getElementById('publicCassettesList');
                        const publicCassettesSection = document.getElementById('publicCassettesSection');
                        
                        if (publicCassettesList && publicCassettesSection) {
                            // Show the section if it was hidden
                            publicCassettesSection.style.display = 'block';
                            
                            // Create the cassette card HTML
                            const creatorName = this.user?.username || this.user?.emailAddresses?.[0]?.emailAddress?.split('@')[0] || 'You';
                            const escapedImageUrl = cassette.imageUrl ? cassette.imageUrl.replace(/'/g, "\\'").replace(/"/g, '\\"') : '';
                            const previewStyle = cassette.imageUrl 
                                ? `background-image: url('${escapedImageUrl}'); background-size: cover; background-position: center;`
                                : 'background: #0a0a0a;';
                            
                            const newCassetteHTML = `
                                <div class="theme-option public-cassette" data-cassette-id="${cassette.id}" style="position: relative;">
                                    <div class="theme-preview" style="${previewStyle}"></div>
                                    <div class="theme-info">
                                        <h4>${cassette.title}</h4>
                                        <p>${cassette.description || 'Public focus environment'}</p>
                                        <p style="font-size: 0.75rem; color: rgba(255, 255, 255, 0.5); margin-top: 4px;">
                                            created by ${creatorName}
                                            <span style="margin-left: 12px;">üëÅ ${cassette.views || 0}</span>
                                        </p>
                                    </div>
                                    <div style="position: absolute; top: 8px; right: 8px; z-index: 10;">
                                        <button class="cassette-options-btn" data-cassette-id="${cassette.id}" title="Vibe options" onclick="event.stopPropagation();">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <circle cx="12" cy="12" r="1"/>
                                                <circle cx="19" cy="12" r="1"/>
                                                <circle cx="5" cy="12" r="1"/>
                                            </svg>
                                        </button>
                                        <div class="cassette-options-dropdown" id="publicCassetteOptionsDropdown${cassette.id}" style="display: none;">
                                            <div class="cassette-options-menu">
                                                <button class="cassette-option-item edit-public-cassette-option" data-cassette-id="${cassette.id}">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/>
                                                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/>
                                                    </svg>
                                                    Edit
                                                </button>
                                                <button class="cassette-option-item delete-public-cassette-option" data-cassette-id="${cassette.id}">
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                        <polyline points="3 6 5 6 21 6"/>
                                                        <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"/>
                                                        <line x1="10" y1="11" x2="10" y2="17"/>
                                                        <line x1="14" y1="11" x2="14" y2="17"/>
                                                    </svg>
                                                    Delete
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                            
                            // Insert at the beginning of the list (newest first)
                            publicCassettesList.insertAdjacentHTML('afterbegin', newCassetteHTML);
                            
                            // Add event listeners for the new cassette
                            const newCassetteElement = document.querySelector(`.public-cassette[data-cassette-id="${cassette.id}"]`);
                            if (newCassetteElement) {
                                // Click to select
                                newCassetteElement.addEventListener('click', (e) => {
                                    if (e.target.closest('.cassette-options-btn') || e.target.closest('.cassette-options-dropdown')) {
                                        return;
                                    }
                                    this.selectCustomCassette(cassette.id);
                                });
                                
                                // Options button
                                const optionsBtn = newCassetteElement.querySelector(`.cassette-options-btn[data-cassette-id="${cassette.id}"]`);
                                const optionsDropdown = document.getElementById(`publicCassetteOptionsDropdown${cassette.id}`);
                                
                                if (optionsBtn && optionsDropdown) {
                                    optionsBtn.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        const isVisible = optionsDropdown.style.display === 'block';
                                        document.querySelectorAll('.cassette-options-dropdown').forEach(dropdown => {
                                            dropdown.style.display = 'none';
                                        });
                                        optionsDropdown.style.display = isVisible ? 'none' : 'block';
                                    });
                                }
                                
                                // Edit option
                                const editOption = newCassetteElement.querySelector(`.edit-public-cassette-option[data-cassette-id="${cassette.id}"]`);
                                if (editOption) {
                                    editOption.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        if (optionsDropdown) optionsDropdown.style.display = 'none';
                                        this.showCassetteForm(cassette.id);
                                    });
                                }
                                
                                // Delete option
                                const deleteOption = newCassetteElement.querySelector(`.delete-public-cassette-option[data-cassette-id="${cassette.id}"]`);
                                if (deleteOption) {
                                    deleteOption.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        if (optionsDropdown) optionsDropdown.style.display = 'none';
                                        this.deleteCustomCassette(cassette.id);
                                        this.showResourceShareToast('Cassette moved to deleted');
                                    });
                                }
                            }
                            
                            console.log('‚úÖ Added new public cassette to UI immediately:', cassette.id);
                        }
                    }
                    
                    // Then update public vibes section in background
                    // Force refresh from server to ensure consistency across users
                    // Don't invalidate cache before loading - keep other users' cassettes visible
                    // The cache will be updated with fresh data from server, and user's cassettes will be merged in
                    this.loadPublicCassettes(true).catch(err => console.error('Error reloading public vibes:', err));
                }
                
                // If editing an existing cassette, check if it's currently selected
                if (cassetteId) {
                    const currentTheme = localStorage.getItem('lastSelectedTheme') || this.currentTheme;
                    const isCurrentlySelected = currentTheme === `custom_${cassetteId}`;
                    
                    if (isCurrentlySelected) {
                        // Re-apply the updated cassette immediately with the latest data
                        console.log('üîÑ Re-applying updated cassette:', cassette.title);
                        // Use the cassette object directly (already has latest data)
                        this.applyCustomCassette(cassette);
                    }
                } else {
                    // If this is a new cassette (not editing), select it automatically
                    // Reduced delay for better UX
                    const delay = cassette.isPublic ? 200 : 50;
                    setTimeout(() => {
                        console.log('üîÑ Selecting new cassette:', cassette.id);
                        if (cassette.isPublic) {
                            // For public vibes, try to select and apply active state
                            this.selectCustomCassette(cassette.id);
                            // Also ensure the active state is applied to public vibes
                            setTimeout(() => {
                                this.applyActiveStateToPublicCassettes();
                            }, 100);
                        } else {
                            // For private cassettes, just select normally
                            this.selectCustomCassette(cassette.id);
                        }
                    }, delay);
                }
                
                // Track event
                this.trackEvent('Custom Cassette Created', {
                    feature: 'custom_cassettes',
                    cassette_title: cassette.title,
                    has_image: !!cassette.imageUrl,
                    has_spotify: !!cassette.spotifyUrl,
                    user_type: 'pro',
                    is_edit: !!cassetteId
                });
                
                console.log('‚úÖ Custom vibe saved:', cassette);
            };
            
            // Execute in background (don't wait)
            handleSuccess().catch(err => console.error('Error in handleSuccess:', err));
            return true;
        } catch (error) {
            console.error('Error saving cassette:', error);
            alert('Error saving cassette: ' + (error.message || 'Unknown error'));
            return false;
        }
    }
    
    initializeVolumeControl() {
        const volumeSlider = document.getElementById('sidebarAmbientVolume');
        const volumeValue = document.getElementById('sidebarVolumeValue');
        
        if (volumeSlider && volumeValue) {
            // Set initial volume
            volumeSlider.value = this.lofiVolume * 100;
            volumeValue.textContent = Math.round(this.lofiVolume * 100) + '%';
            
            // Add event listener
            volumeSlider.addEventListener('input', (e) => {
                const newVolume = e.target.value / 100;
                this.lofiVolume = newVolume;
                volumeValue.textContent = e.target.value + '%';
                
                // Update audio volume if playing
                const audio = document.getElementById('backgroundAudio');
                if (audio) {
                    audio.volume = newVolume;
                }
                
                // Save to localStorage
                localStorage.setItem('lofiVolume', newVolume.toString());
            });
        }
    }

    applyTheme(themeName) {
        console.log(`üé® Applying theme: ${themeName}`);
        
        // Check if this is a custom vibe
        if (themeName && themeName.startsWith('custom_')) {
            const cassetteId = themeName.replace('custom_', '');
            const cassettes = this.getCustomCassettes();
            let cassette = cassettes.find(c => c.id === cassetteId);
            
            if (cassette) {
                // Found in local cassettes, apply it
                this.applyCustomCassette(cassette);
                return;
            }
            
            // Not found in local cassettes, try cache first (instant) before API
            const cachedData = localStorage.getItem('publicCassettesCache');
            if (cachedData) {
                try {
                    const cachedCassettes = JSON.parse(cachedData);
                    const cachedCassette = cachedCassettes.find(c => c.id === cassetteId);
                    if (cachedCassette) {
                        console.log('üì¶ Found cassette in cache, applying instantly');
                        this.applyCustomCassette(cachedCassette);
                        return;
                    }
                } catch (e) {
                    console.error('Error parsing cached cassettes:', e);
                }
            }
            
            // Not in cache either, load from API (async)
            const themeBeingLoaded = themeName;
            
            this.loadPublicCassettesFromAPI().then(publicCassettes => {
                // IMPORTANT: Check if user has changed theme while we were loading
                // If currentTheme is different from what we started loading, don't override
                if (this.currentTheme !== themeBeingLoaded) {
                    console.log(`‚ö†Ô∏è User changed theme during load (${themeBeingLoaded} ‚Üí ${this.currentTheme}), skipping`);
                    return; // User already selected a different theme, don't override
                }
                
                const publicCassette = publicCassettes.find(c => c.id === cassetteId);
                if (publicCassette) {
                    // Update active state visually
                    document.querySelectorAll('.theme-option[data-theme]').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    document.querySelectorAll('.custom-cassette').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    document.querySelectorAll('.public-cassette').forEach(opt => {
                        opt.classList.remove('active');
                    });
                    const cassetteOption = document.querySelector(`.public-cassette[data-cassette-id="${cassetteId}"]`);
                    if (cassetteOption) {
                        cassetteOption.classList.add('active');
                    }
                    this.applyCustomCassette(publicCassette);
                } else {
                    // Not found in public vibes either, fallback to lofi
                    console.warn('Custom vibe not found in local or public vibes, falling back to lofi');
                    this.applyTheme('lofi');
                }
            }).catch(err => {
                console.error('Error loading public vibes:', err);
                // On error, fallback to lofi
                this.applyTheme('lofi');
            });
            // Return early since we're handling async
            return;
        }
        
        // Pause timer when changing cassettes for better UX
        if (this.isRunning) {
            this.pauseTimer();
            console.log('üé® Timer paused due to cassette change');
        }
        
        const timerSection = document.querySelector('.timer-section');
        if (!timerSection) {
            console.error('‚ùå Timer section not found');
            return;
        }
        
        // Remove all background classes
        timerSection.classList.remove('theme-minimalist', 'theme-woman', 'theme-man');
        
        // Remove custom Spotify widget if switching from custom vibe
        const existingWidget = document.getElementById('customSpotifyWidget');
        if (existingWidget) {
            existingWidget.remove();
            this.currentSpotifyUrl = null; // Clear Spotify URL tracking
        }
        
        // Remove custom website link if switching from custom vibe
        const existingLink = document.getElementById('customWebsiteLink');
        if (existingLink) {
            existingLink.remove();
        }
        
        // Remove custom vibe background image styles
        timerSection.style.removeProperty('background-image');
        timerSection.style.removeProperty('background-size');
        timerSection.style.removeProperty('background-position');
        timerSection.style.removeProperty('background-repeat');
        timerSection.style.removeProperty('background-color');
        
        if (themeName === 'simple') {
            // Simple theme: black background, no music
            // Stop Tron music first if active
            if (this.currentImmersiveTheme === 'tron') {
                this.deactivateImmersiveTheme();
            }
            
            timerSection.classList.add('theme-minimalist');
            this.stopLofiPlaylist();
            this.lofiEnabled = false;
            if (this.isAuthenticated) {
                localStorage.setItem('lofiEnabled', 'false');
            }
            
            // Always stop music for Simple theme (whether timer is running or not)
            console.log('üé® Simple theme applied - black background, no music');
            
        } else if (themeName === 'lofi') {
            // Lofi theme: Garden Study background + lofi music
            // Stop Tron music first if active
            if (this.currentImmersiveTheme === 'tron') {
                this.deactivateImmersiveTheme();
            }
            
            timerSection.classList.add('theme-woman');
            this.lofiEnabled = true;
            if (this.isAuthenticated) {
                localStorage.setItem('lofiEnabled', 'true');
            }
            
            // If timer is running, start music immediately
            if (this.isRunning) {
                this.playLofiPlaylist().catch(err => console.log('Lofi start error:', err));
                console.log('üé® Lofi theme applied - Garden Study background + lofi music (music started because timer is running)');
            } else {
                console.log('üé® Lofi theme applied - Garden Study background + lofi music (music will start when timer starts)');
            }
            
        } else if (themeName === 'tron') {
            // Tron theme: slideshow + tron music
            // Stop Lofi music first
            this.stopLofiPlaylist();
            this.lofiEnabled = false;
            if (this.isAuthenticated) {
                localStorage.setItem('lofiEnabled', 'false');
            }
            
            // Only deactivate if not already Tron theme
            if (this.currentImmersiveTheme !== 'tron') {
            this.deactivateImmersiveTheme();
            }
            
            this.applyImmersiveTheme('tron');
            
            // Check if user is authenticated for Tron theme
            if (!this.isAuthenticated) {
                console.log('üé® Tron theme requires authentication');
                alert('Tron theme requires an account. Sign up for free to unlock all immersive themes!');
                // Revert to default theme
                this.applyTheme('lofi');
                return;
            }
            
            // Create Spotify widget for Tron theme (only if not already created)
            if (!this.tronSpotifyWidget) {
                this.createTronSpotifyWidget();
                console.log('üé® Tron theme applied - Spotify widget created');
            } else if (this.tronSpotifyWidgetReady) {
                console.log('üé® Tron theme applied - Spotify widget already ready');
            }
            
        }
        
        // Save theme preference (for both authenticated and guest users)
        localStorage.setItem('lastSelectedTheme', themeName);
        this.currentTheme = themeName;
        
        // Update visual active state
        this.updateThemeActiveState(themeName);
        
        // Track theme change
        if (window.mixpanelTracker) {
            window.mixpanelTracker.trackCustomEvent('Theme Changed', { theme_name: themeName });
            console.log('üìä Theme changed event tracked to Mixpanel');
        }
    }
    
    updateThemeActiveState(themeName) {
        // Handle custom vibes
        if (themeName && themeName.startsWith('custom_')) {
            const cassetteId = themeName.replace('custom_', '');
            const cassetteOption = document.querySelector(`[data-cassette-id="${cassetteId}"]`);
            if (cassetteOption) {
                cassetteOption.classList.add('active');
                const radio = cassetteOption.querySelector('input[type="radio"]');
                if (radio) radio.checked = true;
            }
            // Remove active from preset themes
            document.querySelectorAll('.theme-option[data-theme]').forEach(opt => {
                opt.classList.remove('active');
                const radio = opt.querySelector('input[type="radio"]');
                if (radio) radio.checked = false;
            });
            // Remove active from other custom vibes
            document.querySelectorAll('.custom-cassette').forEach(opt => {
                if (opt !== cassetteOption) {
                    opt.classList.remove('active');
                    const radio = opt.querySelector('input[type="radio"]');
                    if (radio) radio.checked = false;
                }
            });
            console.log(`üé® Theme active state updated to: ${themeName}`);
            return;
        }
        
        // Get all theme options
        const themeOptions = document.querySelectorAll('.theme-option[data-theme]');
        
        themeOptions.forEach(option => {
            const radio = option.querySelector('input[type="radio"]');
            const optionThemeName = option.dataset.theme;
            
            // Remove active from all options
            option.classList.remove('active');
            if (radio) radio.checked = false;
            
            // Add active to the selected theme
            if (optionThemeName === themeName) {
                option.classList.add('active');
                if (radio) radio.checked = true;
            }
        });
        
        // Remove active from custom vibes
        document.querySelectorAll('.custom-cassette').forEach(opt => {
            opt.classList.remove('active');
            const radio = opt.querySelector('input[type="radio"]');
            if (radio) radio.checked = false;
        });
        
        console.log(`üé® Theme active state updated to: ${themeName}`);
    }

    applyImmersiveTheme(themeName) {
        console.log(`üé® Applying immersive theme: ${themeName}`);
        
        if (themeName === 'tron') {
            this.activateTronTheme();
        } else {
            console.log(`üé® Unknown immersive theme: ${themeName}`);
        }
    }

    activateTronTheme() {
        console.log('üé® Activating Tron theme...');
        console.log('üé® Tron image available:', this.tronImage);
        
        const timerSection = document.querySelector('.timer-section');
        if (!timerSection) {
            console.error('‚ùå Timer section not found');
            return;
        }
        
        if (!this.tronImage) {
            console.error('‚ùå Tron image not loaded, loading assets first...');
            this.loadTronAssets();
        }
        
        console.log('üé® Timer section found, setting Tron background...');
        
        // Remove ALL background classes and set Tron background
        timerSection.classList.remove('theme-minimalist', 'theme-woman', 'theme-man');
        
        // Force Tron background with !important to override CSS
        timerSection.style.setProperty('background-image', `url('${this.tronImage}')`, 'important');
        timerSection.style.setProperty('background-size', 'cover', 'important');
        timerSection.style.setProperty('background-position', 'center', 'important');
        timerSection.style.setProperty('background-repeat', 'no-repeat', 'important');
        timerSection.style.setProperty('background-color', 'transparent', 'important');
        
        console.log('üé® Tron background set:', this.tronImage);
        console.log('üé® Applied styles:', {
            backgroundImage: timerSection.style.backgroundImage,
            backgroundSize: timerSection.style.backgroundSize,
            backgroundPosition: timerSection.style.backgroundPosition
        });
        
        // Clear Music and Background selections when Tron is active
        this.clearMusicAndBackgroundSelections();
        
        // Switch to Tron music (will start when timer starts)
        // Ensure lofi is not playing anymore
        this.stopLofiPlaylist();
        
        // Save preference only if user is authenticated
        if (this.isAuthenticated) {
            localStorage.setItem('selectedImmersiveTheme', 'tron');
        }
        this.currentImmersiveTheme = 'tron';
        
        console.log('üé® Tron theme activated successfully');
    }

    clearMusicAndBackgroundSelections() {
        // Clear Music panel selections
        const musicOptions = document.querySelectorAll('.music-option');
        musicOptions.forEach(option => {
            option.classList.remove('active');
            const radio = option.querySelector('input[type="radio"]');
            if (radio) radio.checked = false;
        });
        
        // Clear Background panel selections
        const backgroundOptions = document.querySelectorAll('.theme-option[data-background]');
        backgroundOptions.forEach(option => {
            option.classList.remove('active');
            const radio = option.querySelector('input[type="radio"]');
            if (radio) radio.checked = false;
        });
        
        console.log('üé® Cleared Music and Background selections for Tron theme');
    }

    deactivateImmersiveTheme() {
        const timerSection = document.querySelector('.timer-section');
        if (!timerSection) return;
        
        // Remove Tron background
        timerSection.style.removeProperty('background-image');
        timerSection.style.removeProperty('background-size');
        timerSection.style.removeProperty('background-position');
        timerSection.style.removeProperty('background-repeat');
        timerSection.style.removeProperty('background-color');
        
        // Tron theme deactivated - remove Spotify widget
        if (this.currentImmersiveTheme === 'tron') {
            this.removeTronSpotifyWidget();
            this.tronSpotifyWidgetReady = false;
            this.tronSpotifyWidgetActivated = false;
            console.log('üé® Tron theme deactivated - background + Spotify widget removed');
        }
        
        // Save preference only if user is authenticated
        if (this.isAuthenticated) {
            localStorage.setItem('selectedImmersiveTheme', 'none');
        }
        this.currentImmersiveTheme = 'none';
        
        // Don't close the panel automatically - let user control it
        
        console.log('üé® Immersive theme deactivated');
        
        // Restore the current theme background
        setTimeout(() => {
            this.applyTheme(this.currentTheme);
        }, 100);
    }


    



    applyOverlay(opacity) {
        const timerSection = document.querySelector('.timer-section');
        if (!timerSection) {
            console.error('‚ùå Timer section not found');
            return;
        }
        
        // Find or create overlay element
        let overlayElement = timerSection.querySelector('.theme-overlay');
        
        if (!overlayElement) {
            // Create overlay element if it doesn't exist
            overlayElement = document.createElement('div');
            overlayElement.className = 'theme-overlay';
            timerSection.insertBefore(overlayElement, timerSection.firstChild);
        }
        
        // Apply opacity directly to the overlay
        overlayElement.style.backgroundColor = `rgba(0, 0, 0, ${opacity})`;
        
        console.log(`üé® Overlay opacity set to: ${Math.round(opacity * 100)}%`);
    }


    // Tron Spotify Widget Methods
    createTronSpotifyWidget() {
        console.log('üéµ Creating Tron Spotify widget...');
        console.log('üéµ Spotify URL:', this.tronSpotifyEmbedUrl);

        // Remove any existing widget first
        this.removeTronSpotifyWidget();

        // Create the iframe element
        const widget = document.createElement('iframe');
        widget.id = 'tron-spotify-widget';
        widget.src = this.tronSpotifyEmbedUrl;
        widget.width = '100%';
        widget.height = '352';
        widget.frameBorder = '0';
        widget.allowTransparency = 'true';
        widget.setAttribute('title', 'Spotify Music Player');
        widget.setAttribute('aria-label', 'Spotify Music Player for Tron theme');
        widget.setAttribute('referrerpolicy', 'no-referrer');
        widget.setAttribute('data-testid', 'embed-iframe');
        widget.allow = 'autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture';
        widget.loading = 'lazy';
        
        // Style the widget
        widget.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 352px;
            z-index: 1000;
            border-radius: 12px;
            border: none;
            pointer-events: auto;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: opacity 0.3s ease;
            opacity: 0.8; /* Show loading state */
        `;

        // Set up timeout handling
        let loadTimeout;
        let isLoaded = false;

        const handleLoad = () => {
            if (isLoaded) return;
            isLoaded = true;
            clearTimeout(loadTimeout);
            
            this.tronSpotifyWidgetReady = true;
            widget.style.opacity = '1';
            console.log('üéµ Spotify widget loaded successfully');
        };

        const handleError = () => {
            if (isLoaded) return;
            isLoaded = true;
            clearTimeout(loadTimeout);
            
            console.warn('‚ö†Ô∏è TRON: Ares Soundtrack failed to load - this may be a temporary Spotify server issue');
            widget.style.opacity = '0.5';
            // Show a message to user about the issue
            this.showSpotifyErrorMessage();
        };

        const handleTimeout = () => {
            if (isLoaded) return;
            isLoaded = true;
            clearTimeout(loadTimeout);
            
            console.warn('‚ö†Ô∏è TRON: Ares Soundtrack loading timeout - Spotify servers may be slow');
            widget.style.opacity = '0.7';
            // Message removed per user request
        };

        // Set timeout for 10 seconds
        loadTimeout = setTimeout(handleTimeout, 10000);

        // Add event listeners
        widget.addEventListener('load', handleLoad);
        widget.addEventListener('error', handleError);

        // Append to body
        document.body.appendChild(widget);
        this.tronSpotifyWidget = widget;
        
        // Create the image button
        this.createTronImageButton();
        
        console.log('üéµ Tron Spotify widget created with timeout handling');
    }

    showSpotifyErrorMessage() {
        // Show a temporary message about Spotify loading issue
        const message = document.createElement('div');
        message.id = 'spotify-error-message';
        message.innerHTML = `
            <div style="
                position: fixed;
                bottom: 380px;
                right: 20px;
                background: rgba(255, 0, 0, 0.9);
                color: white;
                padding: 12px 16px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 1001;
                max-width: 280px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            ">
                ‚ö†Ô∏è TRON soundtrack temporarily unavailable<br>
                <small>Spotify servers may be experiencing issues</small>
            </div>
        `;
        
        document.body.appendChild(message);
        
        // Remove message after 5 seconds
        setTimeout(() => {
            if (message.parentNode) {
                message.parentNode.removeChild(message);
            }
        }, 5000);
    }


    removeTronSpotifyWidget() {
        console.log('üéµ Removing Tron Spotify widget...');
        
        if (this.tronSpotifyWidget) {
            this.tronSpotifyWidget.remove();
            this.tronSpotifyWidget = null;
            this.tronSpotifyWidgetReady = false;
            console.log('üéµ Tron Spotify widget removed');
        }
        
        // Remove image button
        if (this.tronImageButton) {
            this.tronImageButton.remove();
            this.tronImageButton = null;
            console.log('üñºÔ∏è Tron image button removed');
        }
        
        // Also remove any error/timeout messages
        const errorMsg = document.getElementById('spotify-error-message');
        const timeoutMsg = document.getElementById('spotify-timeout-message');
        if (errorMsg) errorMsg.remove();
        if (timeoutMsg) timeoutMsg.remove();
    }

    showSpotifyLoading() {
        console.log('üéµ Showing Spotify loading state...');
        // No need to affect the Start/Pause button
    }

    createTronImageButton() {
        // Create background image button
        const imageButton = document.createElement('div');
        imageButton.id = 'tron-image-button';
        imageButton.innerHTML = `
            <div class="tron-image-content">
                <div class="tron-image-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-square-arrow-out-up-right-icon lucide-square-arrow-out-up-right">
                        <path d="M21 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h6"/>
                        <path d="m21 3-9 9"/>
                        <path d="M15 3h6v6"/>
                    </svg>
                </div>
                <div class="tron-image-text">Visit Website</div>
            </div>
        `;
        
        // Styles are handled by CSS - no inline styles needed
        
        // Hover effects are now handled by CSS
        
        // Add click handler
        imageButton.addEventListener('click', () => {
            this.trackEvent('Tron Image Button Clicked', {
                button_type: 'tron_image',
                source: 'tron_theme',
                destination: 'wallpaper_site'
            });
            
            // Open the wallpaper site in a new tab
            window.open('https://wall.alphacoders.com/big.php?i=1395234', '_blank');
        });
        
        // Append to timer section instead of body
        const timerSection = document.querySelector('.timer-section');
        if (timerSection) {
            timerSection.appendChild(imageButton);
        } else {
            document.body.appendChild(imageButton);
        }
        this.tronImageButton = imageButton;
        
        console.log('üñºÔ∏è Tron image button created');
    }

    // No button disabling needed - widget is visible and ready


    loadLastSelectedTheme() {
        // Load last selected theme from localStorage (works for both authenticated and guest users)
        const lastSelectedTheme = localStorage.getItem('lastSelectedTheme');
        if (lastSelectedTheme && lastSelectedTheme !== 'lofi') {
            // Check if Tron theme requires authentication
            if (lastSelectedTheme === 'tron' && !this.isAuthenticated) {
                console.log('üé® Tron theme requires authentication, using default lofi');
            return;
        }
        
            // Only restore if it's not the default lofi theme
            console.log('üé® Restoring last selected theme:', lastSelectedTheme);
            // Apply the theme after a short delay to ensure DOM is ready
            setTimeout(() => {
                this.applyTheme(lastSelectedTheme);
            }, 100);
        } else {
            console.log('üé® Using default lofi theme for new user');
        }
    }

    showTronInfoModal() {
        const modal = document.getElementById('tronInfoModal');
        if (modal) {
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }
    }

    closeTronInfoModal() {
        const modal = document.getElementById('tronInfoModal');
        if (modal) {
            modal.style.display = 'none';
            document.body.style.overflow = '';
        }
    }

    updateThemeAuthState() {
        // Update theme options based on authentication state
        const themeOptions = document.querySelectorAll('.theme-option[data-requires-auth="true"]');
        themeOptions.forEach(option => {
            const signupText = option.querySelector('.signup-required-text');
            
            if (this.isAuthenticated) {
                option.classList.add('authenticated');
                option.style.pointerEvents = 'auto';
                option.style.opacity = '1';
                if (signupText) signupText.style.display = 'none';
            } else {
                option.classList.remove('authenticated');
                option.style.pointerEvents = 'none';
                option.style.opacity = '0.5';
                if (signupText) signupText.style.display = 'inline';
            }
        });
    }


    // Spotify control methods removed - will be reimplemented



}

// Global functions for modal
function closeTronInfoModal() {
    if (window.pomodoroTimer) {
        window.pomodoroTimer.closeTronInfoModal();
    }
}

function handleSignup() {
    if (window.pomodoroTimer) {
        window.pomodoroTimer.handleSignup();
    }
}

// Mixpanel Tracker Class
class MixpanelTracker {
    constructor() {
        this.isInitialized = false;
    }

    init() {
        if (window.mixpanel && window.mixpanel.track) {
            this.isInitialized = true;
            console.log('üéØ MixpanelTracker initialized successfully');
        } else {
            console.warn('‚ö†Ô∏è Mixpanel not available for tracking');
        }
    }

    // Generic track method for any event
    track(eventName, properties = {}) {
        if (!this.isInitialized) {
            console.warn('‚ö†Ô∏è Mixpanel not initialized, cannot track:', eventName);
            return;
        }
        
        try {
            const eventData = {
                ...properties,
                timestamp: new Date().toISOString()
            };
            
            window.mixpanel.track(eventName, eventData);
            console.log('‚úÖ Mixpanel event tracked:', eventName, eventData);
        } catch (error) {
            console.error('‚ùå Error tracking Mixpanel event:', eventName, error);
        }
    }

    trackTimerComplete(sessionType, completed) {
        if (!this.isInitialized) {
            console.warn('‚ö†Ô∏è MixpanelTracker not initialized');
            return;
        }

        const eventData = {
            session_type: sessionType,
            completed: completed,
            timestamp: new Date().toISOString(),
            user_agent: navigator.userAgent,
            page_url: window.location.href
        };

        // Track the session completion event
        window.mixpanel.track('Timer Session Completed', eventData);
        
        // Also track specific session type events for easier analysis
        const specificEventName = `Session ${sessionType.charAt(0).toUpperCase() + sessionType.slice(1)} Completed`;
        window.mixpanel.track(specificEventName, eventData);

        console.log(`üìä Tracked session completion: ${sessionType}`, eventData);
        console.log(`üìä Event sent to Mixpanel: "Timer Session Completed" and "${specificEventName}"`);
    }

    trackCycleComplete(technique, cycleDuration, workSessions, shortBreaks, longBreaks) {
        if (!this.isInitialized) {
            console.warn('‚ö†Ô∏è MixpanelTracker not initialized');
            return;
        }

        const eventData = {
            technique: technique,
            cycle_duration_seconds: cycleDuration,
            cycle_duration_minutes: Math.round(cycleDuration / 60),
            work_sessions: workSessions,
            short_breaks: shortBreaks,
            long_breaks: longBreaks,
            total_sessions: workSessions + shortBreaks + longBreaks,
            timestamp: new Date().toISOString(),
            user_agent: navigator.userAgent,
            page_url: window.location.href
        };

        // Track the cycle completion event
        window.mixpanel.track('Cycle Completed', eventData);
        
        // Also track technique-specific cycle events for easier analysis
        const techniqueEventName = `Cycle ${technique.charAt(0).toUpperCase() + technique.slice(1)} Completed`;
        window.mixpanel.track(techniqueEventName, eventData);

        console.log(`üìä Tracked cycle completion: ${technique}`, eventData);
        console.log(`üìä Event sent to Mixpanel: "Cycle Completed" and "${techniqueEventName}"`);
    }

    trackUserLogin(method) {
        if (!this.isInitialized) return;
        
        window.mixpanel.track('User Login', {
            method: method,
            timestamp: new Date().toISOString()
        });
    }

    trackUserLogout() {
        if (!this.isInitialized) return;
        
        window.mixpanel.track('User Logout', {
            timestamp: new Date().toISOString()
        });
    }

    trackCustomEvent(eventName, properties) {
        if (!this.isInitialized) return;
        
        window.mixpanel.track(eventName, {
            ...properties,
            timestamp: new Date().toISOString()
        });
    }

    trackModalOpened(modalType) {
        if (!this.isInitialized) return;
        
        window.mixpanel.track('Modal Opened', {
            modal_type: modalType,
            timestamp: new Date().toISOString()
        });
    }

    trackSidebarPanelOpened(panelType) {
        if (!this.isInitialized) return;
        
        window.mixpanel.track('Sidebar Panel Opened', {
            panel_type: panelType,
            timestamp: new Date().toISOString()
        });
    }

    trackTimerStart(sessionType, duration, taskName) {
        if (!this.isInitialized) return;
        
        window.mixpanel.track('Timer Started', {
            session_type: sessionType,
            duration: duration,
            task_name: taskName,
            timestamp: new Date().toISOString()
        });
    }

    trackTimerPause() {
        if (!this.isInitialized) return;
        
        window.mixpanel.track('Timer Paused', {
            timestamp: new Date().toISOString()
        });
    }

    trackTimerSkip(sessionType, reason) {
        if (!this.isInitialized) return;
        
        window.mixpanel.track('Timer Skipped', {
            session_type: sessionType,
            reason: reason,
            timestamp: new Date().toISOString()
        });
    }

    trackTaskCreated(description, pomodoros) {
        if (!this.isInitialized) return;
        
        window.mixpanel.track('Task Created', {
            description: description,
            pomodoros: pomodoros,
            timestamp: new Date().toISOString()
        });
    }

    trackUserSignup(method) {
        if (!this.isInitialized) return;
        
        window.mixpanel.track('User Signup', {
            method: method,
            timestamp: new Date().toISOString()
        });
    }

    trackSubscriptionUpgrade(plan, value = null) {
        if (!this.isInitialized) {
            console.warn('‚ö†Ô∏è Mixpanel not initialized, cannot track subscription upgrade');
            return;
        }
        
        const eventData = {
            plan: plan,
            timestamp: new Date().toISOString()
        };
        
        if (value !== null) {
            eventData.value = value;
            eventData.currency = 'USD';
        }
        
        window.mixpanel.track('Subscription Upgrade', eventData);
        console.log('‚úÖ Subscription Upgrade tracked to Mixpanel:', eventData);
    }
}

// Initialize Mixpanel Tracker
window.mixpanelTracker = new MixpanelTracker();

// Initialize the timer when the page loads
document.addEventListener('DOMContentLoaded', () => {
    const timer = new PomodoroTimer();
    window.pomodoroTimer = timer; // Make it globally accessible
    
    // Listen for messages from pricing page
    window.addEventListener('message', (event) => {
        // Only accept messages from same origin
        if (event.origin !== window.location.origin) return;
        
        if (event.data && event.data.action === 'openPricingModal') {
            console.log('üì¨ Message received: opening pricing modal');
            timer.showPricingPlansModal();
        }
    });
    
    // Check if we should open pricing modal on load
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('showPricingModal')) {
        setTimeout(() => {
            console.log('üéØ Opening pricing modal from URL param');
            timer.showPricingPlansModal();
        }, 500);
    }
    
    // üß™ Testing function for Share on X modal
    // Usage: testShareModal() or testShareModal(45, 3, "Study for exam")
    window.testShareModal = (minutes = 25, sessions = 4, taskName = "Study for final exam") => {
        console.log('üß™ Testing Cycle Stats Modal with Share on X...');
        timer._lastTaskName = taskName; // Set task name for sharing
        timer.showCycleStatsModal({
            cycleDuration: minutes * 60,
            workSessions: sessions
        });
        console.log(`‚úÖ Modal: ${minutes} min, ${sessions} sessions, task: "${taskName}"`);
    };
    console.log('üí° testShareModal(min, sessions, "task") to preview Share on X');
    
    // Initialize Mixpanel tracking
    if (window.mixpanelTracker) {
        window.mixpanelTracker.init();
    }
    
    // Theme is applied inside constructor via applyTheme(this.currentTheme).
    // Avoid re-applying a stale background here to prevent flashes or mismatches.
    timer.applyOverlay(timer.overlayOpacity);
    
    // Pre-load public vibes in background so they're ready when user opens the panel
    // Start immediately - these are needed for a good first experience
    if (timer.loadPublicCassettesFromAPI) {
        timer.loadPublicCassettesFromAPI(false).then(() => {
            console.log('üì¶ Public vibes pre-loaded in background');
        }).catch(() => {
            // Silently ignore errors - user will see fresh data when opening panel
        });
    }
    
    // Mobile menu toggle - Handled by bottom sheet system below (line ~22747)
    // This old code is disabled to prevent conflicts with the new bottom sheet navigation
    /*
    const mobileMenuToggle = document.getElementById('mobileMenuToggle');
    const sidebar = document.getElementById('sidebar');
    
    if (mobileMenuToggle && sidebar) {
        mobileMenuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
        });
        
        // Close sidebar when clicking outside
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 768) {
                if (!sidebar.contains(e.target) && !mobileMenuToggle.contains(e.target)) {
                    sidebar.classList.remove('open');
                }
            }
        });
        
        // Close sidebar when clicking on a nav item
        const navItems = sidebar.querySelectorAll('.nav-item');
        navItems.forEach(item => {
            item.addEventListener('click', () => {
                if (window.innerWidth <= 768) {
                    sidebar.classList.remove('open');
                }
            });
        });
    }
    */
    
    // Show timer header auth buttons for guest users
    const timerHeaderAuth = document.getElementById('timerHeaderAuth');
    const timerLoginBtn = document.getElementById('timerLoginBtn');
    const timerSignupBtn = document.getElementById('timerSignupBtn');
    
    if (timerHeaderAuth) {
        if (!timer.isAuthenticated) {
            timerHeaderAuth.style.display = 'block';
            
            if (timerLoginBtn) {
                timerLoginBtn.addEventListener('click', () => {
                    // Track Timer header Login click
                    timer.trackEvent('Login Clicked', {
                        button_type: 'login',
                        source: 'timer_header',
                        user_type: 'guest'
                    });
                    
                    window.location.href = 'https://accounts.superfocus.live/sign-in?redirect_url=https%3A%2F%2Fwww.superfocus.live%2F';
                });
            }
            
            if (timerSignupBtn) {
                timerSignupBtn.addEventListener('click', () => {
                    // Track Timer header Sign up click
                    timer.trackEvent('Sign Up Clicked', {
                        modal_type: 'timer_header',
                        button_type: 'signup',
                        source: 'timer_header',
                        user_type: 'guest'
                    });
                    
                    timer.handleSignup();
                });
            }
        } else {
            // Hide buttons when user is authenticated
            timerHeaderAuth.style.display = 'none';
        }
    }
    
    // Only show loader for Lighthouse or explicit query param
    const shouldShowLoader = () => {
        try {
            const params = new URLSearchParams(window.location.search);
            if (params.get('loader') === '1' || params.get('lh') === '1') return true;
            const ua = navigator.userAgent || '';
            return /Lighthouse|Chrome-Lighthouse/i.test(ua);
        } catch (_) {
            return false;
        }
    };
    
    if (shouldShowLoader()) {
        timer.showLoadingScreen();
        const tryHide = () => {
            if (!timer.isLoading) return;
            if (!timer.checkIfStillLoading()) {
                timer.hideLoadingScreen();
                return;
            }
            setTimeout(tryHide, 100);
        };
        setTimeout(tryHide, 200);
        setTimeout(() => timer.hideLoadingScreen(), 4000);
    }
    
    // Initialize Premium Welcome Modal
    initPremiumWelcome(timer);
});


// Premium Welcome Modal
function initPremiumWelcome(timer) {
    const welcomeModal = document.getElementById('premiumWelcomeModal');
    const closeBtn = document.getElementById('closePremiumWelcomeBtn');
    const ctaBtn = document.getElementById('startPremiumBtn');
    
    if (!welcomeModal) return;
    
    // Check if this is a premium upgrade
    const urlParams = new URLSearchParams(window.location.search);
    const isPremiumSuccess = urlParams.get('premium') === 'success' || urlParams.get('trial') === 'success';
    const hasSeenPremiumWelcome = localStorage.getItem('hasSeenPremiumWelcome');
    
    // Function to check if user just became premium (subscription less than 2 minutes old)
    async function isNewPremium() {
        if (!timer.isAuthenticated || !window.Clerk?.user) return false;
        
        try {
            const user = window.Clerk.user;
            const publicMetadata = user.publicMetadata || {};
            
            // Check if user has premium status
            if (!publicMetadata.subscriptionStatus || publicMetadata.subscriptionStatus !== 'active') {
                return false;
            }
            
            // Check if subscription was created recently (less than 2 minutes ago)
            const subscriptionCreatedAt = publicMetadata.subscriptionCreatedAt;
            if (!subscriptionCreatedAt) return false;
            
            const now = new Date().getTime();
            const subscriptionTime = new Date(subscriptionCreatedAt).getTime();
            const twoMinutes = 2 * 60 * 1000;
            
            const isNew = (now - subscriptionTime) < twoMinutes;
            console.log('üîç Premium subscription check:', {
                subscriptionCreatedAt: new Date(subscriptionCreatedAt).toISOString(),
                ageInSeconds: Math.floor((now - subscriptionTime) / 1000),
                isNew: isNew
            });
            
            return isNew;
        } catch (error) {
            console.error('Error checking if premium is new:', error);
            return false;
        }
    }
    
    // Wait for auth to load, then check conditions
    setTimeout(async () => {
        if (!timer.isAuthenticated) {
            console.log('‚è≠Ô∏è User not authenticated, skipping premium welcome modal');
            return;
        }
        
        if (hasSeenPremiumWelcome === 'true') {
            console.log('‚è≠Ô∏è User has already seen premium welcome modal');
            return;
        }
        
        // Check if:
        // 1. URL has premium=success or trial=success parameter, OR
        // 2. User subscription was created less than 2 minutes ago (new premium)
        const urlHasPremiumSuccess = isPremiumSuccess;
        const userIsNewPremium = await isNewPremium();
        
        console.log('üîç Premium welcome modal conditions:', {
            urlHasPremiumSuccess,
            userIsNewPremium,
            isAuthenticated: timer.isAuthenticated,
            hasSeenPremiumWelcome
        });
        
        if ((urlHasPremiumSuccess || userIsNewPremium) && timer.isAuthenticated && hasSeenPremiumWelcome !== 'true') {
            showPremiumWelcome();
        } else {
            console.log('‚è≠Ô∏è Conditions not met for showing premium welcome modal');
        }
    }, 1500); // Wait 1.5 seconds for Clerk to fully load
    
    function showPremiumWelcome() {
        welcomeModal.style.display = 'flex';
        
        // Track in Mixpanel
        if (window.mixpanelTracker && typeof window.mixpanelTracker.track === 'function') {
            window.mixpanelTracker.track('Premium Welcome Shown', {
                user_id: timer.user?.id || 'unknown',
                timestamp: new Date().toISOString()
            });
        }
        
        // Clean up URL (remove premium/trial parameter)
        if (window.history && window.history.replaceState) {
            const url = new URL(window.location);
            url.searchParams.delete('premium');
            url.searchParams.delete('trial');
            window.history.replaceState({}, '', url.toString());
        }
    }
    
    function closePremiumWelcome() {
        localStorage.setItem('hasSeenPremiumWelcome', 'true');
        welcomeModal.style.display = 'none';
        
        // Track dismissal
        if (window.mixpanelTracker && typeof window.mixpanelTracker.track === 'function') {
            window.mixpanelTracker.track('Premium Welcome Closed', {
                user_id: timer.user?.id || 'unknown',
                method: 'manual'
            });
        }
    }
    
    // Close button
    if (closeBtn) {
        closeBtn.addEventListener('click', closePremiumWelcome);
    }
    
    // CTA button - Start Using Premium
    if (ctaBtn) {
        ctaBtn.addEventListener('click', () => {
            // Track CTA click
            if (window.mixpanelTracker && typeof window.mixpanelTracker.track === 'function') {
                window.mixpanelTracker.track('Premium Welcome CTA Clicked', {
                    user_id: timer.user?.id || 'unknown',
                    button: 'start_using_premium'
                });
            }
            
            closePremiumWelcome();
        });
    }
    
    // Close on overlay click
    welcomeModal.addEventListener('click', (e) => {
        if (e.target === welcomeModal) {
            if (window.mixpanelTracker && typeof window.mixpanelTracker.track === 'function') {
                window.mixpanelTracker.track('Premium Welcome Closed', {
                    user_id: timer.user?.id || 'unknown',
                    method: 'overlay_click'
                });
            }
            closePremiumWelcome();
        }
    });
}


// Sidebar functionality
class SidebarManager {
    constructor() {
        this.sidebar = document.getElementById('sidebar');
        this.mainContent = document.getElementById('mainContent');
        this.mobileMenuToggle = document.getElementById('mobileMenuToggle');
        this.sidebarOverlay = document.getElementById('sidebarOverlay');
        this.navItems = document.querySelectorAll('.nav-item');
        this.taskSidePanel = document.getElementById('taskSidePanel');
        this.taskPanelOverlay = document.getElementById('taskPanelOverlay');
        this.settingsSidePanel = document.getElementById('settingsSidePanel');
        this.settingsPanelOverlay = document.getElementById('settingsPanelOverlay');
        this.immersiveThemeSidePanel = document.getElementById('immersiveThemeSidePanel');
        this.immersiveThemePanelOverlay = document.getElementById('immersiveThemePanelOverlay');
        this.leaderboardSidePanel = document.getElementById('leaderboardSidePanel');
        this.leaderboardPanelOverlay = document.getElementById('leaderboardPanelOverlay');
        this.reportSidePanel = document.getElementById('reportSidePanel');
        this.reportPanelOverlay = document.getElementById('reportPanelOverlay');
        this.resourcesSidePanel = document.getElementById('resourcesSidePanel');
        this.resourcesPanelOverlay = document.getElementById('resourcesPanelOverlay');
        this.coachSidePanel = document.getElementById('coachSidePanel');
        this.coachPanelOverlay = document.getElementById('coachPanelOverlay');
        
        this.isCollapsed = true; // Always collapsed by default
        this.isHidden = false;
        this.isMobile = window.innerWidth <= 768;
        this.isTablet = window.innerWidth > 768 && window.innerWidth <= 1200;
        this.isTaskPanelOpen = false;
        this.isSettingsPanelOpen = false;
        this.isImmersiveThemePanelOpen = false;
        this.isLeaderboardPanelOpen = false;
        this.isReportPanelOpen = false;
        this.isResourcesPanelOpen = false;
        this.isCoachPanelOpen = false;
        
        this.init();
    }
    
    init() {
        this.bindEvents();
        this.setupResponsive();
        this.setupTaskPanelScrollBehavior();
        this.setupPanelA11yState();
        // Don't set any nav item as active by default
        
        // Auto-open task panel for guest users - DISABLED
        // Keep task panel closed by default, user can open it manually
        // this.checkAndOpenForGuest();
    }
    
    checkAndOpenForGuest() {
        // Wait for pomodoroTimer to be initialized
        setTimeout(() => {
            if (window.pomodoroTimer) {
                const isGuest = !window.pomodoroTimer.isAuthenticated || !window.pomodoroTimer.user;
                
                if (isGuest) {
                    console.log('üéØ Guest user detected, opening task panel automatically');
                    this.openTaskPanel();
                }
            }
        }, 500); // Small delay to ensure pomodoroTimer is initialized
    }

    setupPanelA11yState() {
        this.a11yPanels = [
            this.taskSidePanel,
            this.settingsSidePanel,
            this.immersiveThemeSidePanel,
            this.leaderboardSidePanel,
            this.reportSidePanel,
            this.resourcesSidePanel,
            this.coachSidePanel
        ].filter(Boolean);

        // Ensure main landmark isn't aria-hidden by default
        [this.sidebar, this.mainContent].forEach((element) => {
            if (!element) return;
            if (element.getAttribute('aria-hidden') === 'true') {
                element.removeAttribute('aria-hidden');
            }
            if (element.inert) {
                element.inert = false;
            }
        });

        // Initialize closed panels as aria-hidden and inert
        this.a11yPanels.forEach((panel) => {
            this.setPanelA11yState(panel, false);
        });

        // Keep inert in sync if aria-hidden is toggled elsewhere
        const observer = new MutationObserver((mutations) => {
            for (const mutation of mutations) {
                if (mutation.type !== 'attributes' || mutation.attributeName !== 'aria-hidden') continue;
                this.syncAriaHiddenToInert(mutation.target);
            }
        });

        [...this.a11yPanels, this.sidebar, this.mainContent].forEach((element) => {
            if (!element) return;
            observer.observe(element, { attributes: true, attributeFilter: ['aria-hidden'] });
            this.syncAriaHiddenToInert(element);
        });

        this.ariaHiddenObserver = observer;
    }

    syncAriaHiddenToInert(element) {
        if (!element) return;
        const isHidden = element.getAttribute('aria-hidden') === 'true';
        if (isHidden) {
            element.inert = true;
        } else if (element.inert) {
            element.inert = false;
        }
    }

    setPanelA11yState(panel, isOpen) {
        if (!panel) return;
        if (isOpen) {
            panel.removeAttribute('aria-hidden');
            if (panel.inert) {
                panel.inert = false;
            }
        } else {
            panel.setAttribute('aria-hidden', 'true');
            panel.inert = true;
        }
    }
    
    setupTaskPanelScrollBehavior() {
        // Handle scroll propagation when sidebar has no scrollable content
        if (this.taskSidePanel) {
            const panelContent = this.taskSidePanel.querySelector('.task-side-panel-content');
            if (panelContent) {
                panelContent.addEventListener('wheel', (e) => {
                    const hasScroll = panelContent.scrollHeight > panelContent.clientHeight;
                    
                    if (!hasScroll) {
                        // No scroll available, let it propagate to main page
                        return;
                    }
                    
                    const isAtTop = panelContent.scrollTop === 0;
                    const isAtBottom = panelContent.scrollTop + panelContent.clientHeight >= panelContent.scrollHeight - 1;
                    
                    // Allow propagation only if scrolling beyond boundaries
                    if ((isAtTop && e.deltaY < 0) || (isAtBottom && e.deltaY > 0)) {
                        return; // Let it propagate
                    }
                    
                    // Otherwise, prevent propagation (normal scroll within panel)
                    e.stopPropagation();
                }, { passive: true });
            }
        }
        
        // Same for music panel
        if (this.musicSidePanel) {
            const panelContent = this.musicSidePanel.querySelector('.task-side-panel-content');
            if (panelContent) {
                panelContent.addEventListener('wheel', (e) => {
                    const hasScroll = panelContent.scrollHeight > panelContent.clientHeight;
                    
                    if (!hasScroll) {
                        return;
                    }
                    
                    const isAtTop = panelContent.scrollTop === 0;
                    const isAtBottom = panelContent.scrollTop + panelContent.clientHeight >= panelContent.scrollHeight - 1;
                    
                    if ((isAtTop && e.deltaY < 0) || (isAtBottom && e.deltaY > 0)) {
                        return;
                    }
                    
                    e.stopPropagation();
                }, { passive: true });
            }
        }
        
        // Same for settings panel
        if (this.settingsSidePanel) {
            const panelContent = this.settingsSidePanel.querySelector('.task-side-panel-content');
            if (panelContent) {
                panelContent.addEventListener('wheel', (e) => {
                    const hasScroll = panelContent.scrollHeight > panelContent.clientHeight;
                    
                    if (!hasScroll) {
                        return;
                    }
                    
                    const isAtTop = panelContent.scrollTop === 0;
                    const isAtBottom = panelContent.scrollTop + panelContent.clientHeight >= panelContent.scrollHeight - 1;
                    
                    if ((isAtTop && e.deltaY < 0) || (isAtBottom && e.deltaY > 0)) {
                        return;
                    }
                    
                    e.stopPropagation();
                }, { passive: true });
            }
        }
    }
    
    bindEvents() {
        // Logo is just visual - no functionality needed
        
        // No click to expand functionality - sidebar always stays collapsed
        
        // Mobile menu toggle - Disabled, handled by bottom sheet system
        // The bottom sheet system (line ~22747) handles mobile menu for < 1200px
        /*
        if (this.mobileMenuToggle) {
            this.mobileMenuToggle.addEventListener('click', () => {
                this.toggleMobile();
            });
        }
        */
        
        // Navigation items
        this.navItems.forEach(item => {
            item.addEventListener('click', () => {
                const section = item.dataset.section;
                
                // Track navigation clicks with specific panel names
                if (window.pomodoroTimer) {
                    let panelName = section;
                    if (section === 'tasks') panelName = 'Tasks Panel';
                    else if (section === 'settings') panelName = 'Timer Panel';
                    else if (section === 'cassettes') panelName = 'Cassettes Panel';
                    else if (section === 'leaderboard') panelName = 'Leaderboard Panel';
                    else if (section === 'report') panelName = 'Report Panel';
                    else if (section === 'resources') panelName = 'Resources Panel';
                    else if (section === 'coach') panelName = 'Coach Panel';
                    
                    window.pomodoroTimer.trackEvent('Sidebar Panel Opened', {
                        panel_name: panelName,
                        section: section,
                        button_type: 'sidebar_navigation',
                        source: 'sidebar'
                    });
                }
                
                // For tasks, settings, music, and theme, active state is handled in their respective open/close methods
                if (section !== 'tasks' && section !== 'settings' && section !== 'music' && section !== 'theme') {
                    this.setActiveNavItem(section);
                }
                
                this.handleNavigation(section);
                
                // Close mobile sidebar after navigation
                if (this.isMobile) {
                    this.hideMobile();
                }
            });
        });
        
        // Close Resources Panel button
        const closeResourcesPanel = document.getElementById('closeResourcesPanel');
        if (closeResourcesPanel) {
            closeResourcesPanel.addEventListener('click', () => {
                this.closeResourcesPanel();
            });
        }

        const closeCoachPanelBtn = document.getElementById('closeCoachPanel');
        if (closeCoachPanelBtn) {
            closeCoachPanelBtn.addEventListener('click', () => {
                this.closeCoachPanel();
            });
        }
        
            // Overlay click to close sidebar AND all panels (MOBILE ONLY)
        if (this.sidebarOverlay) {
            this.sidebarOverlay.addEventListener('click', () => {
                // Only close sidebar on mobile - desktop sidebar is always visible
                if (this.isMobile) {
                    this.hideMobile();
                }
                this.closeTaskPanel();
                this.closeSettingsPanel();
                this.closeImmersiveThemePanel();
                this.closeLeaderboardPanel();
                this.closeReportPanel();
                this.closeResourcesPanel();
                this.closeCoachPanel();
            });
        }
        
        
        // Settings panel overlay click to close settings panel
        if (this.settingsPanelOverlay) {
            this.settingsPanelOverlay.addEventListener('click', () => {
                this.closeSettingsPanel();
            });
        }
        
        // Theme panel overlay click to close theme panel
        if (this.themePanelOverlay) {
            this.themePanelOverlay.addEventListener('click', () => {
                this.closeThemePanel();
            });
        }
        
        // Task panel overlay click to close task panel
        if (this.taskPanelOverlay) {
            this.taskPanelOverlay.addEventListener('click', () => {
                this.closeTaskPanel();
            });
        }
        
        // Close panel buttons (arrow left buttons)
        const closeTaskPanelBtn = document.getElementById('closeTaskPanel');
        if (closeTaskPanelBtn) {
            closeTaskPanelBtn.addEventListener('click', () => {
                this.closeTaskPanel();
            });
        }
        
        const closeSettingsPanelBtn = document.getElementById('closeSettingsPanel');
        if (closeSettingsPanelBtn) {
            closeSettingsPanelBtn.addEventListener('click', () => {
                this.closeSettingsPanel();
            });
        }
        
        const closeThemePanelBtn = document.getElementById('closeThemePanel');
        if (closeThemePanelBtn) {
            closeThemePanelBtn.addEventListener('click', () => {
                this.closeThemePanel();
            });
        }
        
        
        const closeImmersiveThemePanelBtn = document.getElementById('closeImmersiveThemePanel');
        if (closeImmersiveThemePanelBtn) {
            closeImmersiveThemePanelBtn.addEventListener('click', () => {
                this.closeImmersiveThemePanel();
            });
        }
        
        // Leaderboard panel overlay click to close leaderboard panel
        if (this.leaderboardPanelOverlay) {
            this.leaderboardPanelOverlay.addEventListener('click', () => {
                this.closeLeaderboardPanel();
            });
        }
        
        // Leaderboard panel close button
        const closeLeaderboardPanelBtn = document.getElementById('closeLeaderboardPanel');
        if (closeLeaderboardPanelBtn) {
            closeLeaderboardPanelBtn.addEventListener('click', () => {
                this.closeLeaderboardPanel();
            });
        }
        
        // Report panel overlay click to close report panel
        if (this.reportPanelOverlay) {
            this.reportPanelOverlay.addEventListener('click', () => {
                this.closeReportPanel();
            });
        }
        
        // Report panel close button
        const closeReportPanelBtn = document.getElementById('closeReportPanel');
        if (closeReportPanelBtn) {
            closeReportPanelBtn.addEventListener('click', () => {
                this.closeReportPanel();
            });
        }
        
        // Resources panel overlay click to close resources panel
        if (this.resourcesPanelOverlay) {
            this.resourcesPanelOverlay.addEventListener('click', () => {
                this.closeResourcesPanel();
            });
        }

        if (this.coachPanelOverlay) {
            this.coachPanelOverlay.addEventListener('click', () => {
                this.closeCoachPanel();
            });
        }
        
        // Overlay is present but doesn't close panel on click
        // Panel only closes when clicking the Tasks button
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.handleResize();
        });
    }
    
    setupResponsive() {
        if (this.isMobile) {
            // Mobile: sidebar hidden by default, hamburger menu
            this.sidebar.classList.add('hidden');
            this.sidebar.classList.remove('collapsed', 'expanded');
            this.mainContent.style.marginLeft = '0';
        } else if (this.isTablet) {
            // Tablet: sidebar collapsed but visible
            this.sidebar.classList.remove('hidden', 'open');
            this.sidebar.classList.add('collapsed');
            this.sidebar.classList.remove('expanded');
            this.mainContent.style.marginLeft = 'var(--sidebar-collapsed-width)';
        } else {
            // Desktop: sidebar collapsed
            this.sidebar.classList.remove('hidden', 'open');
            this.sidebar.classList.add('collapsed');
            this.sidebar.classList.remove('expanded');
            this.mainContent.style.marginLeft = 'var(--sidebar-collapsed-width)';
        }
    }
    
    handleResize() {
        const wasMobile = this.isMobile;
        const wasTablet = this.isTablet;
        this.isMobile = window.innerWidth <= 768;
        this.isTablet = window.innerWidth > 768 && window.innerWidth <= 1200;
        
        if (wasMobile !== this.isMobile || wasTablet !== this.isTablet) {
            this.setupResponsive();
            
            // Reset mobile state
            if (!this.isMobile) {
                this.sidebar.classList.remove('open');
                if (this.sidebarOverlay) {
                    this.sidebarOverlay.classList.remove('active');
                }
                document.body.style.overflow = '';
            }
            
            // Close side panels on resize to avoid layout issues
            if (this.isTaskPanelOpen) {
                this.closeTaskPanel();
            }
            if (this.isSettingsPanelOpen) {
                this.closeSettingsPanel();
            }
            if (this.isCoachPanelOpen) {
                this.closeCoachPanel();
            }
        }
    }
    
    toggleCollapse() {
        console.log('toggleCollapse called, isMobile:', this.isMobile);
        
        if (this.isMobile) {
            this.toggleMobile();
            return;
        }
        
        // On desktop, do nothing - sidebar always stays collapsed
        console.log('Desktop mode - sidebar stays collapsed');
    }
    
    toggleMobile() {
        if (this.sidebar.classList.contains('open')) {
            this.hideMobile();
        } else {
            this.showMobile();
        }
    }
    
    showMobile() {
        this.sidebar.classList.add('open');
        this.sidebar.classList.remove('hidden');
        if (this.sidebarOverlay) {
            this.sidebarOverlay.classList.add('active');
        }
        // Prevent body scroll when sidebar is open on mobile
        document.body.style.overflow = 'hidden';
    }
    
    hideMobile() {
        // NEVER hide sidebar on desktop (>= 1200px)
        if (window.innerWidth >= 1200) {
            console.log('üö´ hideMobile blocked - we are on desktop');
            return;
        }
        
        this.sidebar.classList.remove('open');
        this.sidebar.classList.add('hidden');
        if (this.sidebarOverlay) {
            this.sidebarOverlay.classList.remove('active');
        }
        // Restore body scroll
        document.body.style.overflow = '';
    }
    
    setActiveNavItem(section) {
        this.navItems.forEach(item => {
            item.classList.remove('active');
            if (item.dataset.section === section) {
                item.classList.add('active');
            }
        });
    }
    
    handleNavigation(section) {
        // Track sidebar navigation clicks in Google Analytics
        if (typeof gtag !== 'undefined') {
            gtag('event', 'sidebar_navigation', {
                'event_category': 'navigation',
                'event_label': section,
                'value': 1
            });
            console.log(`üìä Sidebar navigation tracked: ${section}`);
        }
        
        switch (section) {
            case 'tasks':
                // Toggle task side panel
                this.toggleTaskPanel();
                break;
            case 'settings':
                // Toggle settings side panel
                this.toggleSettingsPanel();
                break;
            case 'immersive-theme':
                // Toggle immersive theme side panel
                this.toggleImmersiveThemePanel();
                break;
            case 'leaderboard':
                // Toggle leaderboard side panel
                this.toggleLeaderboardPanel();
                break;
            case 'report':
                // Toggle report side panel
                this.toggleReportPanel();
                break;
            case 'resources':
                // Toggle resources side panel
                this.toggleResourcesPanel();
                break;
            case 'coach':
                // Toggle coach side panel
                this.toggleCoachPanel();
                break;
            case 'timer':
                // Scroll to timer section
                const timerSection = document.querySelector('.timer-section');
                if (timerSection) {
                    timerSection.scrollIntoView({ behavior: 'smooth' });
                }
                break;
            case 'statistics':
                // Open statistics modal or navigate to stats
                console.log('Navigate to statistics');
                break;
            case 'help':
                // Open help
                const helpToggle = document.getElementById('helpToggle');
                if (helpToggle) {
                    helpToggle.click();
                }
                break;
        }
    }
    
    toggleTaskPanel() {
        if (this.isTaskPanelOpen) {
            this.closeTaskPanel();
        } else {
            this.openTaskPanel();
        }
    }
    
    openTaskPanel() {
        if (this.taskSidePanel) {
            // Close other panels if open
            if (this.isSettingsPanelOpen) {
                this.closeSettingsPanel();
            }
            if (this.isImmersiveThemePanelOpen) {
                this.closeImmersiveThemePanel();
            }
            if (this.isLeaderboardPanelOpen) {
                this.closeLeaderboardPanel();
            }
            if (this.isReportPanelOpen) {
                this.closeReportPanel();
            }
            if (this.isResourcesPanelOpen) {
                this.closeResourcesPanel();
            }
            if (this.isCoachPanelOpen) {
                this.closeCoachPanel();
            }
            
            // Close mobile sidebar if open
            if (this.isMobile && this.sidebar.classList.contains('open')) {
                this.hideMobile();
            }
            
            this.taskSidePanel.classList.add('open');
            this.isTaskPanelOpen = true;
            this.setPanelA11yState(this.taskSidePanel, true);
            
            // Show overlay
            if (this.taskPanelOverlay) {
                this.taskPanelOverlay.classList.add('active');
            }
            
            // Set Tasks nav item as active
            this.setActiveNavItem('tasks');
            
            // Push main content to the right (only on desktop >= 1200px)
            if (this.mainContent && window.innerWidth >= 1200) {
                this.mainContent.classList.add('task-panel-open');
            }
            
            // Prevent body scroll on mobile when panel is open
            if (this.isMobile) {
                document.body.style.overflow = 'hidden';
            }
            
            // Trigger rendering of tasks
            console.log('üü¢ openTaskPanel - checking pomodoroTimer:', window.pomodoroTimer);
            if (window.pomodoroTimer) {
                console.log('üü¢ Calling renderTasksInSidePanel');
                window.pomodoroTimer.renderTasksInSidePanel();
            } else {
                console.error('‚ùå window.pomodoroTimer not found!');
            }
        }
    }
    
    closeTaskPanel() {
        // Re-enable body scroll on mobile
        if (this.isMobile) {
            document.body.style.overflow = '';
        }
        
        if (this.taskSidePanel) {
            this.taskSidePanel.classList.remove('open');
            this.isTaskPanelOpen = false;
            this.setPanelA11yState(this.taskSidePanel, false);
            
            // Hide overlay
            if (this.taskPanelOverlay) {
                this.taskPanelOverlay.classList.remove('active');
            }
            
            // Remove active state from Tasks nav item
            const tasksNavItem = document.querySelector('.nav-item[data-section="tasks"]');
            if (tasksNavItem) {
                tasksNavItem.classList.remove('active');
            }
            
            // Reset main content position
            if (this.mainContent) {
                this.mainContent.classList.remove('task-panel-open');
            }
        }
    }
    
    
    toggleSettingsPanel() {
        if (this.isSettingsPanelOpen) {
            this.closeSettingsPanel();
        } else {
            this.openSettingsPanel();
        }
    }
    
    openSettingsPanel() {
        if (this.settingsSidePanel) {
            // Close other panels if open
            if (this.isTaskPanelOpen) {
                this.closeTaskPanel();
            }
            if (this.isImmersiveThemePanelOpen) {
                this.closeImmersiveThemePanel();
            }
            if (this.isLeaderboardPanelOpen) {
                this.closeLeaderboardPanel();
            }
            if (this.isReportPanelOpen) {
                this.closeReportPanel();
            }
            if (this.isResourcesPanelOpen) {
                this.closeResourcesPanel();
            }
            if (this.isCoachPanelOpen) {
                this.closeCoachPanel();
            }
            
            // Close mobile sidebar if open
            if (this.isMobile && this.sidebar.classList.contains('open')) {
                this.hideMobile();
            }
            
            this.settingsSidePanel.classList.add('open');
            this.isSettingsPanelOpen = true;
            this.setPanelA11yState(this.settingsSidePanel, true);
            
            // Show overlay
            if (this.settingsPanelOverlay) {
                this.settingsPanelOverlay.classList.add('active');
            }
            
            // Set Settings nav item as active
            this.setActiveNavItem('settings');
            
            // Push main content to the right (only on desktop >= 1200px)
            if (this.mainContent && window.innerWidth >= 1200) {
                this.mainContent.classList.add('task-panel-open');
            }
            
            // Prevent body scroll on mobile when panel is open
            if (this.isMobile) {
                document.body.style.overflow = 'hidden';
            }
            
            // Initialize settings panel controls
            if (window.pomodoroTimer) {
                window.pomodoroTimer.initializeSettingsSidePanel();
            }
        }
    }
    
    closeSettingsPanel() {
        // Re-enable body scroll on mobile
        if (this.isMobile) {
            document.body.style.overflow = '';
        }
        
        if (this.settingsSidePanel) {
            this.settingsSidePanel.classList.remove('open');
            this.isSettingsPanelOpen = false;
            this.setPanelA11yState(this.settingsSidePanel, false);
            
            // Hide overlay
            if (this.settingsPanelOverlay) {
                this.settingsPanelOverlay.classList.remove('active');
            }
            
            // Remove active state from Settings nav item
            const settingsNavItem = document.querySelector('.nav-item[data-section="settings"]');
            if (settingsNavItem) {
                settingsNavItem.classList.remove('active');
            }
            
            // Reset main content position
            if (this.mainContent) {
                this.mainContent.classList.remove('task-panel-open');
            }
        }
    }
    

    toggleImmersiveThemePanel() {
        if (this.isImmersiveThemePanelOpen) {
            this.closeImmersiveThemePanel();
        } else {
            // üéØ Track Sidebar Panel Opened event to Mixpanel
            if (window.mixpanelTracker) {
                window.mixpanelTracker.trackSidebarPanelOpened('immersive-theme');
                console.log('üìä Immersive theme panel opened event tracked to Mixpanel');
            }
            this.openImmersiveThemePanel();
        }
    }
    

    openImmersiveThemePanel() {
        if (this.immersiveThemeSidePanel) {
            // Close other panels if open
            if (this.isTaskPanelOpen) {
                this.closeTaskPanel();
            }
            if (this.isSettingsPanelOpen) {
                this.closeSettingsPanel();
            }
            if (this.isImmersiveThemePanelOpen) {
                this.closeImmersiveThemePanel();
            }
            if (this.isLeaderboardPanelOpen) {
                this.closeLeaderboardPanel();
            }
            if (this.isReportPanelOpen) {
                this.closeReportPanel();
            }
            if (this.isResourcesPanelOpen) {
                this.closeResourcesPanel();
            }
            if (this.isCoachPanelOpen) {
                this.closeCoachPanel();
            }
            
            this.immersiveThemeSidePanel.classList.add('open');
            this.isImmersiveThemePanelOpen = true;
            this.setPanelA11yState(this.immersiveThemeSidePanel, true);
            
            // Show overlay
            if (this.immersiveThemePanelOverlay) {
                this.immersiveThemePanelOverlay.classList.add('active');
            }
            
            // Set Theme nav item as active
            this.setActiveNavItem('immersive-theme');
            
            // Push main content to the right
            if (this.mainContent) {
                this.mainContent.classList.add('task-panel-open');
            }
            
            // Initialize immersive theme panel controls
            if (window.pomodoroTimer) {
                window.pomodoroTimer.initializeImmersiveThemePanel();
                
                // Load public vibes - use smart caching to avoid unnecessary API calls
                // Only force refresh if cache is older than 2 minutes
                if (window.pomodoroTimer.isLoadingPublicCassettes) {
                    console.log('üîÑ Public vibes already loading, skipping...');
                    const publicCassettesSection = document.getElementById('publicCassettesSection');
                    const hasItems = document.querySelectorAll('.public-cassette').length > 0;
                    if (publicCassettesSection && hasItems) {
                        publicCassettesSection.style.display = 'block';
                    }
                } else {
                    // Always force refresh when opening panel to ensure fresh data
                    // This fixes the issue where new cassettes don't appear for regular users
                    console.log('üì¶ Force refreshing public cassettes on panel open');
                    
                    window.pomodoroTimer.loadPublicCassettes(true).catch(err => {
                        console.error('Error loading public vibes:', err);
                    });
                }
            }
        }
    }

    initializeLeaderboardPanel() {
        // Close button
        const closeBtn = document.getElementById('closeLeaderboardPanel');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                this.closeLeaderboardPanel();
            });
        }

        // Overlay click to close
        if (this.leaderboardPanelOverlay) {
            this.leaderboardPanelOverlay.addEventListener('click', () => {
                this.closeLeaderboardPanel();
            });
        }
    }

    toggleLeaderboardPanel() {
        if (this.isLeaderboardPanelOpen) {
            this.closeLeaderboardPanel();
        } else {
            this.openLeaderboardPanel();
        }
    }

    openLeaderboardPanel() {
        // Close other panels first
        if (this.isTaskPanelOpen) this.closeTaskPanel();
        if (this.isSettingsPanelOpen) this.closeSettingsPanel();
        if (this.isImmersiveThemePanelOpen) this.closeImmersiveThemePanel();
        if (this.isReportPanelOpen) this.closeReportPanel();
        if (this.isResourcesPanelOpen) this.closeResourcesPanel();
        if (this.isCoachPanelOpen) this.closeCoachPanel();

        // üéØ Track Leaderboard Panel Opened event to Mixpanel
        if (window.mixpanelTracker) {
            window.mixpanelTracker.trackSidebarPanelOpened('leaderboard');
            console.log('üìä Leaderboard panel opened event tracked to Mixpanel');
        }

        if (this.leaderboardSidePanel) {
            this.leaderboardSidePanel.classList.add('open');
            this.isLeaderboardPanelOpen = true;
            this.setPanelA11yState(this.leaderboardSidePanel, true);

            // Show overlay
            if (this.leaderboardPanelOverlay) {
                this.leaderboardPanelOverlay.classList.add('active');
            }

            // Set active state on nav item
            const leaderboardNavItem = document.querySelector('.nav-item[data-section="leaderboard"]');
            if (leaderboardNavItem) {
                leaderboardNavItem.classList.add('active');
            }

            // Adjust main content position
            if (this.mainContent) {
                this.mainContent.classList.add('task-panel-open');
            }

            // Load leaderboard
            if (window.pomodoroTimer) {
                window.pomodoroTimer.loadLeaderboardForPanel();
                window.pomodoroTimer.startLeaderboardAutoRefresh();
            }
        }
    }

    closeLeaderboardPanel() {
        if (this.leaderboardSidePanel) {
            this.leaderboardSidePanel.classList.remove('open');
            this.isLeaderboardPanelOpen = false;
            this.setPanelA11yState(this.leaderboardSidePanel, false);

            // Hide overlay
            if (this.leaderboardPanelOverlay) {
                this.leaderboardPanelOverlay.classList.remove('active');
            }

            // Remove active state from Leaderboard nav item
            const leaderboardNavItem = document.querySelector('.nav-item[data-section="leaderboard"]');
            if (leaderboardNavItem) {
                leaderboardNavItem.classList.remove('active');
            }

            // Reset main content position
            if (this.mainContent) {
                this.mainContent.classList.remove('task-panel-open');
            }
        }

        if (window.pomodoroTimer) {
            window.pomodoroTimer.stopLeaderboardAutoRefreshIfIdle();
        }
    }

    toggleReportPanel() {
        if (this.isReportPanelOpen) {
            this.closeReportPanel();
        } else {
            this.openReportPanel();
        }
    }

    openReportPanel() {
        // Close other panels first
        if (this.isTaskPanelOpen) this.closeTaskPanel();
        if (this.isSettingsPanelOpen) this.closeSettingsPanel();
        if (this.isImmersiveThemePanelOpen) this.closeImmersiveThemePanel();
        if (this.isLeaderboardPanelOpen) this.closeLeaderboardPanel();
        if (this.isResourcesPanelOpen) this.closeResourcesPanel();
        if (this.isCoachPanelOpen) this.closeCoachPanel();

        // üéØ Track Report Panel Opened event to Mixpanel
        if (window.mixpanelTracker) {
            window.mixpanelTracker.trackSidebarPanelOpened('report');
            console.log('üìä Report panel opened event tracked to Mixpanel');
        }

        if (this.reportSidePanel) {
            this.reportSidePanel.classList.add('open');
            this.isReportPanelOpen = true;
            this.setPanelA11yState(this.reportSidePanel, true);

            // Show overlay
            if (this.reportPanelOverlay) {
                this.reportPanelOverlay.classList.add('active');
            }

            // Set active state on nav item
            const reportNavItem = document.querySelector('.nav-item[data-section="report"]');
            if (reportNavItem) {
                reportNavItem.classList.add('active');
            }

            // Adjust main content position
            if (this.mainContent) {
                this.mainContent.classList.add('task-panel-open');
            }

            // Load report
            if (window.pomodoroTimer) {
                window.pomodoroTimer.loadReportForPanel();
            }
        }
    }

    closeReportPanel() {
        if (this.reportSidePanel) {
            this.reportSidePanel.classList.remove('open');
            this.isReportPanelOpen = false;
            this.setPanelA11yState(this.reportSidePanel, false);

            // Hide overlay
            if (this.reportPanelOverlay) {
                this.reportPanelOverlay.classList.remove('active');
            }

            // Remove active state from Report nav item
            const reportNavItem = document.querySelector('.nav-item[data-section="report"]');
            if (reportNavItem) {
                reportNavItem.classList.remove('active');
            }

            // Reset main content position
            if (this.mainContent) {
                this.mainContent.classList.remove('task-panel-open');
            }
        }
    }

    closeImmersiveThemePanel() {
        if (this.immersiveThemeSidePanel) {
            this.immersiveThemeSidePanel.classList.remove('open');
            this.isImmersiveThemePanelOpen = false;
            this.setPanelA11yState(this.immersiveThemeSidePanel, false);
            
            // Hide overlay
            if (this.immersiveThemePanelOverlay) {
                this.immersiveThemePanelOverlay.classList.remove('active');
            }
            
            // Remove active state from Theme nav item
            const themeNavItem = document.querySelector('.nav-item[data-section="immersive-theme"]');
            if (themeNavItem) {
                themeNavItem.classList.remove('active');
            }
            
            // Reset main content position
            if (this.mainContent) {
                this.mainContent.classList.remove('task-panel-open');
            }
        }
    }

    toggleResourcesPanel() {
        if (this.isResourcesPanelOpen) {
            this.closeResourcesPanel();
        } else {
            this.openResourcesPanel();
        }
    }

    openResourcesPanel() {
        // Close other panels first
        if (this.isTaskPanelOpen) this.closeTaskPanel();
        if (this.isSettingsPanelOpen) this.closeSettingsPanel();
        if (this.isImmersiveThemePanelOpen) this.closeImmersiveThemePanel();
        if (this.isLeaderboardPanelOpen) this.closeLeaderboardPanel();
        if (this.isReportPanelOpen) this.closeReportPanel();
        if (this.isCoachPanelOpen) this.closeCoachPanel();

        // Track Resources Panel Opened event
        if (window.mixpanelTracker) {
            window.mixpanelTracker.trackSidebarPanelOpened('resources');
            console.log('üìä Resources panel opened event tracked to Mixpanel');
        }

        if (this.resourcesSidePanel) {
            this.resourcesSidePanel.classList.add('open');
            this.isResourcesPanelOpen = true;
            this.setPanelA11yState(this.resourcesSidePanel, true);

            // Show overlay
            if (this.resourcesPanelOverlay) {
                this.resourcesPanelOverlay.classList.add('active');
            }

            // Set active state on nav item
            const resourcesNavItem = document.querySelector('.nav-item[data-section="resources"]');
            if (resourcesNavItem) {
                resourcesNavItem.classList.add('active');
            }

            // Adjust main content position
            if (this.mainContent) {
                this.mainContent.classList.add('task-panel-open');
            }
        }
    }

    closeResourcesPanel() {
        if (this.resourcesSidePanel) {
            this.resourcesSidePanel.classList.remove('open');
            this.isResourcesPanelOpen = false;
            this.setPanelA11yState(this.resourcesSidePanel, false);

            // Hide overlay
            if (this.resourcesPanelOverlay) {
                this.resourcesPanelOverlay.classList.remove('active');
            }

            // Remove active state from Resources nav item
            const resourcesNavItem = document.querySelector('.nav-item[data-section="resources"]');
            if (resourcesNavItem) {
                resourcesNavItem.classList.remove('active');
            }

            // Reset main content position
            if (this.mainContent) {
                this.mainContent.classList.remove('task-panel-open');
            }
        }
    }

    toggleCoachPanel() {
        if (this.isCoachPanelOpen) {
            this.closeCoachPanel();
        } else {
            this.openCoachPanel();
        }
    }

    openCoachPanel() {
        if (this.isTaskPanelOpen) this.closeTaskPanel();
        if (this.isSettingsPanelOpen) this.closeSettingsPanel();
        if (this.isImmersiveThemePanelOpen) this.closeImmersiveThemePanel();
        if (this.isLeaderboardPanelOpen) this.closeLeaderboardPanel();
        if (this.isReportPanelOpen) this.closeReportPanel();
        if (this.isResourcesPanelOpen) this.closeResourcesPanel();

        if (this.coachSidePanel) {
            this.coachSidePanel.classList.add('open');
            this.isCoachPanelOpen = true;
            this.setPanelA11yState(this.coachSidePanel, true);

            if (this.coachPanelOverlay) {
                this.coachPanelOverlay.classList.add('active');
            }

            this.setActiveNavItem('coach');

            if (this.mainContent) {
                this.mainContent.classList.add('task-panel-open');
            }
        }

        if (window.pomodoroTimer) {
            const analytics = window.studyTutorAnalytics || {};
            window.pomodoroTimer.trackEvent('Study Tutor Opened', {
                panel_type: 'coach',
                conversation_id: analytics.conversationId || window.studyTutorConversationId || null,
                has_active_conversation: !!analytics.lastAssistantReplyAt || !!analytics.lastUserMessageAt
            });
        }
    }

    closeCoachPanel() {
        if (this.coachSidePanel) {
            this.coachSidePanel.classList.remove('open');
            this.isCoachPanelOpen = false;
            this.setPanelA11yState(this.coachSidePanel, false);

            if (this.coachPanelOverlay) {
                this.coachPanelOverlay.classList.remove('active');
            }

            const coachNavItem = document.querySelector('.nav-item[data-section="coach"]');
            if (coachNavItem) {
                coachNavItem.classList.remove('active');
            }

            if (this.mainContent) {
                this.mainContent.classList.remove('task-panel-open');
            }
        }

        if (window.pomodoroTimer) {
            const analytics = window.studyTutorAnalytics || {};
            const lastAssistantReplyAt = analytics.lastAssistantReplyAt;
            const closedWithoutFollowup = !!lastAssistantReplyAt && !analytics.hasFollowedUpAfterLastAnswer;
            window.pomodoroTimer.trackEvent('Study Tutor Closed', {
                panel_type: 'coach',
                conversation_id: analytics.conversationId || window.studyTutorConversationId || null,
                closed_without_followup: closedWithoutFollowup,
                time_since_last_answer_ms: lastAssistantReplyAt ? Date.now() - lastAssistantReplyAt : null,
                last_answer_quality_score: analytics.lastAnswerQualityScore ?? null,
                last_answer_latency_ms: analytics.lastAnswerLatencyMs ?? null
            });
        }
    }
}

function initStudyCoachChat() {
    const messagesEl = document.getElementById('coachChatMessages');
    const inputEl = document.getElementById('coachChatInput');
    const sendBtn = document.getElementById('coachChatSend');
    const newChatBtn = document.getElementById('coachNewChatBtn');
    const inputRow = document.getElementById('coachChatInputRow');
    const gateEl = document.getElementById('coachChatGate');
    const upgradeBtn = document.getElementById('coachUpgradeBtn');
    const signupBtn = document.getElementById('coachSignupBtn');

    if (!messagesEl || !inputEl || !sendBtn) {
        return;
    }

    const state = {
        isSending: false,
        messages: []
    };

    const MAX_TRACKED_MESSAGE_LENGTH = 1000;
    const MIN_HELPFUL_REPLY_LENGTH = 50;

    function createConversationId() {
        return `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
    }

    let conversationId = createConversationId();
    let lastAssistantReplyAt = null;
    let lastUserMessageAt = null;
    let hasFollowedUpAfterLastAnswer = false;
    let lastAnswerQualityScore = null;
    let lastAnswerLatencyMs = null;

    window.studyTutorConversationId = conversationId;
    window.studyTutorAnalytics = {
        conversationId,
        lastAssistantReplyAt,
        lastUserMessageAt,
        hasFollowedUpAfterLastAnswer,
        lastAnswerQualityScore,
        lastAnswerLatencyMs
    };

    function getUserType() {
        const timer = window.pomodoroTimer;
        if (!timer?.isAuthenticated) return 'guest';
        return timer.isPremiumUser?.() ? 'pro' : 'free';
    }

    function normalizeMessage(rawMessage) {
        const trimmed = typeof rawMessage === 'string' ? rawMessage.trim() : '';
        const truncated = trimmed.length > MAX_TRACKED_MESSAGE_LENGTH;
        return {
            text: truncated ? trimmed.slice(0, MAX_TRACKED_MESSAGE_LENGTH) : trimmed,
            truncated
        };
    }

    function computeAutoQualityScore(reply) {
        if (typeof reply !== 'string') return 0;
        const normalized = reply.toLowerCase();
        if (
            normalized.includes('sorry') ||
            normalized.includes('went wrong') ||
            normalized.includes('did not get a response')
        ) {
            return 10;
        }
        if (reply.length < 20) return 20;
        if (reply.length < MIN_HELPFUL_REPLY_LENGTH) return 40;
        if (reply.length > 800) return 70;
        return 85;
    }

    function syncAnalyticsState() {
        if (!window.studyTutorAnalytics) return;
        window.studyTutorAnalytics.conversationId = conversationId;
        window.studyTutorAnalytics.lastAssistantReplyAt = lastAssistantReplyAt;
        window.studyTutorAnalytics.lastUserMessageAt = lastUserMessageAt;
        window.studyTutorAnalytics.hasFollowedUpAfterLastAnswer = hasFollowedUpAfterLastAnswer;
        window.studyTutorAnalytics.lastAnswerQualityScore = lastAnswerQualityScore;
        window.studyTutorAnalytics.lastAnswerLatencyMs = lastAnswerLatencyMs;
    }

    function trackCoachEvent(eventName, properties = {}) {
        if (!window.pomodoroTimer) return;
        window.pomodoroTimer.trackEvent(eventName, {
            conversation_id: conversationId,
            user_type: getUserType(),
            ...properties
        });
    }

    function scrollToBottom() {
        messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function addMessage(role, content, options = {}) {
        const messageEl = document.createElement('div');
        messageEl.classList.add('coach-chat-message', role);
        if (options.loading) {
            messageEl.classList.add('loading');
        }
        messageEl.textContent = content;
        messagesEl.appendChild(messageEl);
        scrollToBottom();
        return messageEl;
    }

    function resetChat() {
        state.messages = [];
        messagesEl.innerHTML = '';
        inputEl.value = '';
        syncSendButtonState();
        resizeInput();
        conversationId = createConversationId();
        lastAssistantReplyAt = null;
        lastUserMessageAt = null;
        hasFollowedUpAfterLastAnswer = false;
        lastAnswerQualityScore = null;
        lastAnswerLatencyMs = null;
        window.studyTutorConversationId = conversationId;
        syncAnalyticsState();
    }

    function updateCoachAccess() {
        const timer = window.pomodoroTimer;
        const isAuthenticated = !!timer?.isAuthenticated;
        const isPremium = !!timer?.isPremiumUser?.();

        if (isPremium) {
            if (gateEl) gateEl.style.display = 'none';
            if (messagesEl) messagesEl.style.display = '';
            if (inputRow) inputRow.style.display = '';
            if (newChatBtn) newChatBtn.style.display = '';
            return;
        }

        if (messagesEl) messagesEl.style.display = 'none';
        if (inputRow) inputRow.style.display = 'none';
        if (newChatBtn) newChatBtn.style.display = 'none';
        if (gateEl) gateEl.style.display = 'flex';

        if (upgradeBtn) upgradeBtn.style.display = isAuthenticated ? 'inline-flex' : 'none';
        if (signupBtn) signupBtn.style.display = isAuthenticated ? 'none' : 'inline-flex';
    }

    async function sendMessage() {
        const content = inputEl.value.trim();
        if (!content || state.isSending) return;

        state.isSending = true;
        sendBtn.disabled = true;

        inputEl.value = '';
        addMessage('user', content);
        state.messages.push({ role: 'user', content });

        const now = Date.now();
        if (lastAssistantReplyAt && !hasFollowedUpAfterLastAnswer) {
            hasFollowedUpAfterLastAnswer = true;
            trackCoachEvent('Study Tutor Continued', {
                time_since_last_answer_ms: now - lastAssistantReplyAt
            });
        }
        lastUserMessageAt = now;
        syncAnalyticsState();

        const normalizedUserMessage = normalizeMessage(content);
        trackCoachEvent('Study Tutor Question Sent', {
            message: normalizedUserMessage.text,
            message_length: content.length,
            message_truncated: normalizedUserMessage.truncated,
            followup_after_answer: !!lastAssistantReplyAt,
            time_since_last_answer_ms: lastAssistantReplyAt ? now - lastAssistantReplyAt : null,
            message_index: state.messages.length,
            messages_in_conversation: state.messages.length
        });

        const loadingEl = addMessage('assistant', 'Thinking...', { loading: true });

        const requestStart = performance.now();
        try {
            const response = await fetch('/api/study-coach', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ messages: state.messages })
            });

            const rawText = await response.text();
            let data = null;
            try {
                data = rawText ? JSON.parse(rawText) : null;
            } catch (_) {
                data = null;
            }

            if (!response.ok) {
                const errorMessage = data?.error || rawText || 'Request failed';
                throw new Error(errorMessage);
            }

            const reply = data?.reply || rawText || 'I did not get a response. Try again.';
            loadingEl.classList.remove('loading');
            loadingEl.textContent = reply;
            state.messages.push({ role: 'assistant', content: reply });

            const normalizedReply = normalizeMessage(reply);
            lastAnswerQualityScore = computeAutoQualityScore(reply);
            lastAnswerLatencyMs = Math.round(performance.now() - requestStart);
            lastAssistantReplyAt = Date.now();
            hasFollowedUpAfterLastAnswer = false;
            syncAnalyticsState();
            trackCoachEvent('Study Tutor Answer Received', {
                message: normalizedReply.text,
                message_length: reply.length,
                message_truncated: normalizedReply.truncated,
                response_latency_ms: lastAnswerLatencyMs,
                auto_quality_score: lastAnswerQualityScore,
                message_index: state.messages.length,
                messages_in_conversation: state.messages.length
            });
        } catch (error) {
            loadingEl.classList.remove('loading');
            loadingEl.textContent = 'Sorry, something went wrong. Try again in a moment.';
            console.error('Study coach error:', error);
            lastAnswerLatencyMs = Math.round(performance.now() - requestStart);
            syncAnalyticsState();
            const errorMessage = typeof error?.message === 'string' ? error.message : 'Unknown error';
            const normalizedError = normalizeMessage(errorMessage);
            trackCoachEvent('Study Tutor Answer Error', {
                error_message: normalizedError.text,
                error_message_truncated: normalizedError.truncated,
                response_latency_ms: lastAnswerLatencyMs
            });
        } finally {
            state.isSending = false;
            sendBtn.disabled = false;
            inputEl.focus();
        }
    }

    sendBtn.addEventListener('click', sendMessage);
    inputEl.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
            event.preventDefault();
            sendMessage();
        }
    });

    function syncSendButtonState() {
        const hasText = inputEl.value.trim().length > 0;
        sendBtn.classList.toggle('has-text', hasText);
    }

    function resizeInput() {
        inputEl.style.height = 'auto';
        const maxHeight = 220;
        const nextHeight = Math.min(inputEl.scrollHeight, maxHeight);
        inputEl.style.height = `${nextHeight}px`;
        inputEl.style.overflowY = inputEl.scrollHeight > maxHeight ? 'auto' : 'hidden';
    }

    inputEl.addEventListener('input', () => {
        syncSendButtonState();
        resizeInput();
    });
    syncSendButtonState();
    resizeInput();

    if (newChatBtn) {
        newChatBtn.addEventListener('click', resetChat);
    }

    if (upgradeBtn) {
        upgradeBtn.addEventListener('click', () => {
            if (window.pomodoroTimer) {
                window.pomodoroTimer.trackEvent('Subscribe Clicked', {
                    button_type: 'subscribe',
                    source: 'coach_panel',
                    location: 'coach_gate',
                    user_type: 'free'
                });
                window.pomodoroTimer.showPricingPlansModal();
            }
        });
    }

    if (signupBtn) {
        signupBtn.addEventListener('click', () => {
            if (window.pomodoroTimer?.handleSignup) {
                window.pomodoroTimer.handleSignup();
            }
        });
    }

    window.updateCoachAccess = updateCoachAccess;
    updateCoachAccess();
}

// Initialize sidebar when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.sidebarManager = new SidebarManager();
    initStudyCoachChat();
    
    // Track resource link clicks for Mixpanel analytics
    const resourceLinks = document.querySelectorAll('.resource-item');
    resourceLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            const productTitle = this.querySelector('.resource-title')?.textContent || 'Unknown';
            const productSubtitle = this.querySelector('.resource-subtitle')?.textContent || '';
            const productUrl = this.getAttribute('href') || '';
            
            // Find the category by looking backwards through previous siblings
            let actualCategory = 'Unknown';
            let currentElement = this.previousElementSibling;
            while (currentElement) {
                if (currentElement.classList && currentElement.classList.contains('resource-category')) {
                    const categoryTitle = currentElement.querySelector('.resource-category-title');
                    if (categoryTitle) {
                        actualCategory = categoryTitle.textContent.trim();
                    }
                    break;
                }
                currentElement = currentElement.previousElementSibling;
            }
            
            // Track the click event
            if (window.pomodoroTimer && typeof window.pomodoroTimer.trackEvent === 'function') {
                window.pomodoroTimer.trackEvent('Resource Link Clicked', {
                    product_name: productTitle,
                    product_subtitle: productSubtitle,
                    product_url: productUrl,
                    category: actualCategory,
                    source: 'resources_sidepanel'
                });
            } else if (typeof window.mixpanel !== 'undefined' && window.mixpanel.track) {
                // Fallback to direct Mixpanel tracking
                window.mixpanel.track('Resource Link Clicked', {
                    product_name: productTitle,
                    product_subtitle: productSubtitle,
                    product_url: productUrl,
                    category: actualCategory,
                    source: 'resources_sidepanel',
                    timestamp: new Date().toISOString()
                });
            }
        });
    });

    // Handle share buttons for resources
    const shareButtons = document.querySelectorAll('.resource-share-btn');
    shareButtons.forEach(btn => {
        btn.addEventListener('click', async function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const shareUrl = this.getAttribute('data-share-url');
            const shareTitle = this.getAttribute('data-share-title');
            
            // Copy to clipboard
            navigator.clipboard.writeText(shareUrl).then(() => {
                // Show toast notification
                showResourceShareToast('Link copied to clipboard');
                
                // Track share event
                if (window.pomodoroTimer && typeof window.pomodoroTimer.trackEvent === 'function') {
                    window.pomodoroTimer.trackEvent('Resource Shared', {
                        resource_title: shareTitle,
                        resource_url: shareUrl,
                        share_method: 'clipboard',
                        source: 'resources_sidepanel'
                    });
                }
            }).catch(err => {
                console.error('Failed to copy to clipboard:', err);
                showResourceShareToast('Failed to copy link', true);
            });
        });
    });
    
    // Function to show toast notification for resource sharing
    function showResourceShareToast(message, isError = false) {
        // Remove existing toast if any
        const existingToast = document.querySelector('.resource-share-toast');
        if (existingToast) {
            existingToast.remove();
        }
        
        // Create toast element
        const toast = document.createElement('div');
        toast.className = 'resource-share-toast';
        if (isError) {
            toast.classList.add('error');
        }
        toast.textContent = message;
        
        // Add to DOM
        document.body.appendChild(toast);
        
        // Trigger animation
        setTimeout(() => {
            toast.classList.add('show');
        }, 10);
        
        // Remove after 2 seconds
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 2000);
    }
});// Force redeploy for admin key

// ==========================================
// Release Notes Banner & Navigation
// ==========================================

(function() {
    // Fetch latest version from release-notes.json
    async function getLatestVersion() {
        try {
            const response = await fetch('/release-notes.json');
            if (!response.ok) return null;
            const data = await response.json();
            return data.latestVersion || null;
        } catch (error) {
            console.error('Error fetching release notes version:', error);
            return null;
        }
    }

    // Check if user is Premium
    function isPremiumUser() {
        // Try to access global timer instance
        if (window.pomodoroTimer && typeof window.pomodoroTimer.isPremiumUser === 'function') {
            return window.pomodoroTimer.isPremiumUser();
        }
        return false;
    }

    // Check if there's a new version
    async function hasNewVersion() {
        const latestVersion = await getLatestVersion();
        if (!latestVersion) return false;

        const seenVersion = localStorage.getItem('lastSeenReleaseVersion');
        
        // NEW LOGIC: Don't show to new users (no seenVersion means first time)
        if (!seenVersion) return false;
        
        // Compare versions (simple string comparison works for format like "1.1", "1.2", etc.)
        return latestVersion !== seenVersion;
    }

    // Mark current version as seen
    async function markVersionAsSeen() {
        const latestVersion = await getLatestVersion();
        if (latestVersion) {
            localStorage.setItem('lastSeenReleaseVersion', latestVersion);
        }
    }

    // Show toast on page load if there's a new version AND user is Premium
    async function initToast() {
        const toast = document.getElementById('releaseNotesToast');
        if (!toast) return;

        // Check if user is Premium first
        const userIsPremium = isPremiumUser();
        
        // Only show to Premium users
        if (!userIsPremium) return;

        const showToast = await hasNewVersion();
        const latestVersion = await getLatestVersion();
        
        if (showToast) {
            toast.style.display = 'block';
            // Trigger animation after a small delay
            setTimeout(() => {
                toast.classList.add('show');
            }, 100);
            
            // Track toast shown event
            if (window.pomodoroTimer && typeof window.pomodoroTimer.trackEvent === 'function') {
                window.pomodoroTimer.trackEvent('Release Notes Toast Shown', {
                    user_type: 'pro',
                    version: latestVersion,
                    source: 'toast'
                });
            }
        }

        // Close toast handler
        const closeBtn = document.getElementById('closeReleaseNotesToast');
        if (closeBtn) {
            closeBtn.addEventListener('click', async function() {
                toast.classList.remove('show');
                // Wait for animation to complete before hiding
                setTimeout(() => {
                    toast.style.display = 'none';
                }, 300);
                
                // Track dismiss event
                if (window.pomodoroTimer && typeof window.pomodoroTimer.trackEvent === 'function') {
                    window.pomodoroTimer.trackEvent('Release Notes Toast Dismissed', {
                        user_type: 'pro',
                        version: latestVersion,
                        source: 'toast'
                    });
                }
                
                // Mark current version as seen when user closes toast
                await markVersionAsSeen();
            });
        }

        // Also mark as seen when user clicks "Learn more"
        const learnMoreBtn = document.getElementById('releaseNotesLearnMore');
        if (learnMoreBtn) {
            learnMoreBtn.addEventListener('click', async function() {
                // Track learn more click
                if (window.pomodoroTimer && typeof window.pomodoroTimer.trackEvent === 'function') {
                    window.pomodoroTimer.trackEvent('Release Notes Learn More Clicked', {
                        user_type: 'pro',
                        version: latestVersion,
                        source: 'toast'
                    });
                }
                
                await markVersionAsSeen();
                // Hide toast when navigating
                toast.classList.remove('show');
                setTimeout(() => {
                    toast.style.display = 'none';
                }, 300);
            });
        }
    }

    // Release Notes navigation from Help Panel
    function initReleaseNotesNavigation() {
        const releaseNotesItem = document.getElementById('releaseNotesItem');
        if (releaseNotesItem) {
            releaseNotesItem.addEventListener('click', async function() {
                const latestVersion = await getLatestVersion();
                
                // Track access from Help Panel
                if (window.pomodoroTimer && typeof window.pomodoroTimer.trackEvent === 'function') {
                    const userType = window.pomodoroTimer.isPremiumUser() ? 'pro' : 
                                    (window.pomodoroTimer.isAuthenticated ? 'free_user' : 'guest');
                    
                    window.pomodoroTimer.trackEvent('Release Notes Accessed from Help Panel', {
                        user_type: userType,
                        version: latestVersion,
                        source: 'help_panel'
                    });
                }
                
                // Mark version as seen when accessing from Help Panel
                await markVersionAsSeen();
                window.location.href = '/release-notes/';
            });
        }
    }

    // Initialize when DOM is ready and after a delay to ensure pomodoroTimer is loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            // Wait for pomodoroTimer to be available
            setTimeout(() => {
                initToast();
            }, 1000);
            initReleaseNotesNavigation();
        });
    } else {
        // Wait for pomodoroTimer to be available
        setTimeout(() => {
            initToast();
        }, 1000);
        initReleaseNotesNavigation();
    }
})();

// ========================================
// BOTTOM SHEET SYSTEM (Tablets & Mobile)
// Uses original side panels as bottom sheets
// ALWAYS registers listeners, checks resolution at runtime
// ========================================

document.addEventListener('DOMContentLoaded', function() {
    'use strict';
    
    console.log('üîß Mobile/Tablet bottom sheet system initializing...');
    console.log('üì± Window width:', window.innerWidth);
    
    // Check if we're on mobile/tablet - ALWAYS check at runtime, not just once
    function isMobileOrTablet() {
        return window.innerWidth < 1200;
    }
    
    // Navigation menu elements
    const overlay = document.getElementById('bottomSheetOverlay');
    const navigationMenu = document.getElementById('navigationMenu');
    const accountMenu = document.getElementById('accountMenu');
    const mobileMenuToggle = document.querySelector('.mobile-menu-toggle');
    
    // Original side panels (these have all the functionality)
    const sidePanels = {
        timer: {
            panel: document.getElementById('settingsSidePanel'),
            overlay: document.getElementById('settingsPanelOverlay')
        },
        settings: {
            panel: document.getElementById('settingsSidePanel'),
            overlay: document.getElementById('settingsPanelOverlay')
        },
        tasks: {
            panel: document.getElementById('taskSidePanel'),
            overlay: document.getElementById('taskPanelOverlay')
        },
        cassettes: {
            panel: document.getElementById('immersiveThemeSidePanel'),
            overlay: document.getElementById('immersiveThemePanelOverlay')
        },
        report: {
            panel: document.getElementById('reportSidePanel'),
            overlay: document.getElementById('reportPanelOverlay')
        },
        leaderboard: {
            panel: document.getElementById('leaderboardSidePanel'),
            overlay: document.getElementById('leaderboardPanelOverlay')
        },
        coach: {
            panel: document.getElementById('coachSidePanel'),
            overlay: document.getElementById('coachPanelOverlay')
        }
    };
    
    // Settings modal for Account
    const settingsModal = document.getElementById('settingsModal');
    
    console.log('üìã Elements found:', {
        overlay: !!overlay,
        navigationMenu: !!navigationMenu,
        accountMenu: !!accountMenu,
        mobileMenuToggle: !!mobileMenuToggle,
        sidePanels: Object.keys(sidePanels).reduce((acc, key) => {
            acc[key] = !!sidePanels[key].panel;
            return acc;
        }, {}),
        settingsModal: !!settingsModal
    });
    
    let currentOpenPanel = null;
    
    // Helper: Show overlay
    function showOverlay() {
        if (overlay) {
            overlay.style.display = 'block';
            requestAnimationFrame(() => {
                overlay.classList.add('active');
            });
        }
        document.body.style.overflow = 'hidden';
    }
    
    // Helper: Hide overlay
    function hideOverlay() {
        if (overlay) {
            overlay.classList.remove('active');
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        }
        document.body.style.overflow = '';
    }
    
    // Open navigation menu
    function openNavigationMenu() {
        if (!isMobileOrTablet()) return; // Check at runtime
        console.log('üìÇ Opening navigation menu');
        showOverlay();
        if (navigationMenu) {
            navigationMenu.style.display = 'flex';
            requestAnimationFrame(() => {
                navigationMenu.classList.add('active');
            });
        }
    }
    
    // Close navigation menu
    function closeNavigationMenu() {
        console.log('üìÅ Closing navigation menu');
        if (navigationMenu) {
            navigationMenu.classList.remove('active');
            setTimeout(() => {
                navigationMenu.style.display = 'none';
            }, 400);
        }
        hideOverlay();
    }

    function openAccountMenu() {
        if (!isMobileOrTablet()) return;
        console.log('üìÇ Opening account menu');
        showOverlay();
        if (accountMenu) {
            accountMenu.style.display = 'flex';
            requestAnimationFrame(() => {
                accountMenu.classList.add('active');
            });
        }
    }

    function closeAccountMenu() {
        console.log('üìÅ Closing account menu');
        if (accountMenu) {
            accountMenu.classList.remove('active');
            setTimeout(() => {
                accountMenu.style.display = 'none';
            }, 400);
        }
        hideOverlay();
    }
    
    // Open a side panel as bottom sheet
    function openPanel(panelKey) {
        if (!isMobileOrTablet()) return; // Check at runtime
        console.log('üìÇ Opening panel:', panelKey);
        
        // Close navigation menu first
        if (navigationMenu) {
            navigationMenu.classList.remove('active');
            setTimeout(() => {
                navigationMenu.style.display = 'none';
            }, 300);
        }
        hideOverlay();
        
        if (panelKey === 'account') {
            openAccountMenu();
            currentOpenPanel = 'account';
            return;
        }
        
        // Delegate to SidebarManager methods to keep functionality consistent
        if (window.sidebarManager) {
            switch (panelKey) {
                case 'tasks':
                    window.sidebarManager.openTaskPanel();
                    break;
                case 'settings':
                case 'timer':
                    window.sidebarManager.openSettingsPanel();
                    break;
                case 'cassettes':
                    window.sidebarManager.openImmersiveThemePanel();
                    break;
                case 'report':
                    window.sidebarManager.openReportPanel();
                    break;
                case 'leaderboard':
                    window.sidebarManager.openLeaderboardPanel();
                    break;
                case 'resources':
                    window.sidebarManager.openResourcesPanel();
                    break;
                case 'coach':
                    window.sidebarManager.openCoachPanel();
                    break;
                default:
                    console.error('Panel not found:', panelKey);
                    return;
            }
            currentOpenPanel = panelKey;
            return;
        }
        
        const panelData = sidePanels[panelKey];
        if (!panelData || !panelData.panel) {
            console.error('Panel not found:', panelKey);
            return;
        }
        
        // Show overlay
        if (panelData.overlay) {
            panelData.overlay.style.display = 'block';
            panelData.overlay.classList.add('active');
        }
        
        // Show panel as bottom sheet
        panelData.panel.classList.add('open');
        currentOpenPanel = panelKey;
    }
    
    // Close current panel
    function closeCurrentPanel() {
        if (!currentOpenPanel) return;
        
        console.log('üìÅ Closing panel:', currentOpenPanel);
        
        if (currentOpenPanel === 'account') {
            closeAccountMenu();
        } else if (window.sidebarManager) {
            switch (currentOpenPanel) {
                case 'tasks':
                    window.sidebarManager.closeTaskPanel();
                    break;
                case 'settings':
                case 'timer':
                    window.sidebarManager.closeSettingsPanel();
                    break;
                case 'cassettes':
                    window.sidebarManager.closeImmersiveThemePanel();
                    break;
                case 'report':
                    window.sidebarManager.closeReportPanel();
                    break;
                case 'leaderboard':
                    window.sidebarManager.closeLeaderboardPanel();
                    break;
                case 'resources':
                    window.sidebarManager.closeResourcesPanel();
                    break;
                default:
                    break;
            }
        } else {
            const panelData = sidePanels[currentOpenPanel];
            if (panelData) {
                panelData.panel.classList.remove('open');
                if (panelData.overlay) {
                    panelData.overlay.classList.remove('active');
                    setTimeout(() => {
                        panelData.overlay.style.display = 'none';
                    }, 300);
                }
            }
        }
        
        currentOpenPanel = null;
        hideOverlay();
    }
    
    // Close everything - works on any resolution
    function closeAll() {
        closeCurrentPanel();
        closeNavigationMenu();
        closeAccountMenu();
        
        // Force close ALL panels and overlays regardless of state
        const allPanels = [
            document.querySelector('.task-side-panel'),
            document.querySelector('.timer-side-panel'),
            document.querySelector('.immersive-theme-side-panel'),
            document.querySelector('.focus-report-panel')
        ];
        
        allPanels.forEach(panel => {
            if (panel) panel.classList.remove('open');
        });
        
        const allOverlays = [
            document.querySelector('.task-panel-overlay'),
            document.querySelector('.settings-panel-overlay'),
            document.querySelector('.immersive-theme-panel-overlay'),
            document.querySelector('.report-panel-overlay'),
            document.querySelector('.leaderboard-panel-overlay')
        ];
        
        allOverlays.forEach(ov => {
            if (ov) {
                ov.classList.remove('active');
                ov.style.display = 'none';
            }
        });
        
        // Close settings modal
        const modal = document.querySelector('.settings-modal');
        const modalOverlay = document.querySelector('.settings-modal-overlay');
        if (modal) {
            modal.classList.remove('active');
            modal.style.display = 'none';
        }
        if (modalOverlay) {
            modalOverlay.classList.remove('active');
        }
        
        // Remove main-content classes
        const mainContent = document.querySelector('.main-content');
        if (mainContent) {
            mainContent.classList.remove('task-panel-open', 'settings-panel-open', 'immersive-theme-panel-open');
        }
        
        // Reset body overflow
        document.body.style.overflow = '';
    }
    
    // Expose functions immediately for external access - ALWAYS
    window.sidebarManager = window.sidebarManager || {};
    window.sidebarManager.openPanel = openPanel;
    window.sidebarManager.closeCurrentPanel = closeCurrentPanel;
    window.sidebarManager.closeAll = closeAll;
    window.sidebarManager.isMobile = isMobileOrTablet;
    
    // ==================
    // Event Listeners - ALWAYS registered, check resolution at runtime
    // ==================
    
    // Mobile menu toggle - ALWAYS listen, check resolution in handler
    if (mobileMenuToggle) {
        mobileMenuToggle.addEventListener('click', (e) => {
            if (!isMobileOrTablet()) return; // Skip if desktop
            e.stopPropagation();
            console.log('üçî Hamburger menu clicked');
            
            if (navigationMenu && navigationMenu.classList.contains('active')) {
                closeNavigationMenu();
            } else {
                if (currentOpenPanel) {
                    closeCurrentPanel();
                }
                openNavigationMenu();
            }
        });
    }
    
    // Navigation menu items - ALWAYS listen
    const navItems = document.querySelectorAll('.bottom-sheet-nav-item');
    navItems.forEach(item => {
        item.addEventListener('click', () => {
            if (!isMobileOrTablet()) return; // Skip if desktop
            const target = item.getAttribute('data-target');
            if (target) {
                const panelKey = target.replace('Sheet', '');
                if (window.pomodoroTimer) {
                    let panelName = panelKey;
                    if (panelKey === 'tasks') panelName = 'Tasks Panel';
                    else if (panelKey === 'settings') panelName = 'Timer Panel';
                    else if (panelKey === 'cassettes') panelName = 'Cassettes Panel';
                    else if (panelKey === 'leaderboard') panelName = 'Leaderboard Panel';
                    else if (panelKey === 'report') panelName = 'Report Panel';
                    else if (panelKey === 'resources') panelName = 'Resources Panel';
                    else if (panelKey === 'coach') panelName = 'Coach Panel';

                    window.pomodoroTimer.trackEvent('Sidebar Panel Opened', {
                        panel_name: panelName,
                        section: panelKey,
                        button_type: 'bottom_sheet_navigation',
                        source: 'bottom_sheet'
                    });
                }
                openPanel(panelKey);
            }
        });
    });

    // Account menu actions
    const accountLoginBtn = document.getElementById('accountMenuLogin');
    const accountSignupBtn = document.getElementById('accountMenuSignup');
    const accountUnlockBtn = document.getElementById('accountMenuUnlock');
    const accountManageBtn = document.getElementById('accountMenuManageSubscription');
    const accountSettingsBtn = document.getElementById('accountMenuSettings');
    const accountLogoutBtn = document.getElementById('accountMenuLogout');

    if (accountLoginBtn) {
        accountLoginBtn.addEventListener('click', () => {
            closeAccountMenu();
            if (window.pomodoroTimer?.handleLogin) {
                window.pomodoroTimer.handleLogin();
            }
        });
    }

    if (accountSignupBtn) {
        accountSignupBtn.addEventListener('click', () => {
            closeAccountMenu();
            if (window.pomodoroTimer?.handleSignup) {
                window.pomodoroTimer.handleSignup();
            }
        });
    }

    if (accountUnlockBtn) {
        accountUnlockBtn.addEventListener('click', () => {
            closeAccountMenu();
            if (window.pomodoroTimer?.showPricingPlansModal) {
                window.pomodoroTimer.showPricingPlansModal();
            } else {
                window.location.href = '/pricing';
            }
        });
    }

    if (accountManageBtn) {
        accountManageBtn.addEventListener('click', () => {
            closeAccountMenu();
            if (window.pomodoroTimer?.isPremiumUser?.()) {
                window.pomodoroTimer.handleManageSubscription();
            } else if (window.pomodoroTimer?.showPricingPlansModal) {
                window.pomodoroTimer.showPricingPlansModal();
            } else {
                window.location.href = '/pricing';
            }
        });
    }

    if (accountSettingsBtn) {
        accountSettingsBtn.addEventListener('click', () => {
            closeAccountMenu();
            if (window.pomodoroTimer?.showSettingsModal) {
                window.pomodoroTimer.showSettingsModal();
            }
        });
    }

    if (accountLogoutBtn) {
        accountLogoutBtn.addEventListener('click', () => {
            closeAccountMenu();
            if (window.pomodoroTimer?.isAuthenticated) {
                window.pomodoroTimer.showLogoutModal();
            }
        });
    }
    
    // Overlay click - close all
    if (overlay) {
        overlay.addEventListener('click', () => {
            if (!isMobileOrTablet()) return;
            closeAll();
        });
    }
    
    // Navigation menu click - prevent close
    if (navigationMenu) {
        navigationMenu.addEventListener('click', (e) => {
            e.stopPropagation();
        });
    }

    if (accountMenu) {
        accountMenu.addEventListener('click', (e) => {
            e.stopPropagation();
        });
    }
    
    // Panel overlay clicks - close panel
    Object.values(sidePanels).forEach(panelData => {
        if (panelData.overlay) {
            panelData.overlay.addEventListener('click', (e) => {
                if (!isMobileOrTablet()) return;
                // Only close if clicking directly on the overlay, not on the panel
                if (e.target === panelData.overlay) {
                    closeCurrentPanel();
                }
            });
        }
    });
    
    // Handle swipe down to close on navigation menu
    if (navigationMenu) {
        let touchStartY = 0;
        let touchEndY = 0;
        
        navigationMenu.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        navigationMenu.addEventListener('touchmove', (e) => {
            if (!isMobileOrTablet()) return;
            touchEndY = e.touches[0].clientY;
            const diff = touchEndY - touchStartY;
            
            if (diff > 0 && navigationMenu.scrollTop === 0) {
                const translateY = Math.min(diff, 200);
                navigationMenu.style.transform = `translateY(${translateY}px)`;
            }
        }, { passive: true });
        
        navigationMenu.addEventListener('touchend', () => {
            if (!isMobileOrTablet()) return;
            const diff = touchEndY - touchStartY;
            navigationMenu.style.transform = '';
            
            if (diff > 100) {
                closeNavigationMenu();
            }
            
            touchStartY = 0;
            touchEndY = 0;
        });
    }
    
    // Handle swipe down to close on all side panels
    Object.values(sidePanels).forEach(panelData => {
        if (!panelData.panel) return;
        
        let panelTouchStartY = 0;
        let panelTouchEndY = 0;
        
        panelData.panel.addEventListener('touchstart', (e) => {
            panelTouchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        panelData.panel.addEventListener('touchmove', (e) => {
            if (!isMobileOrTablet()) return;
            panelTouchEndY = e.touches[0].clientY;
            const diff = panelTouchEndY - panelTouchStartY;
            
            // Only allow swipe down if at top of scroll
            const scrollableContent = panelData.panel.querySelector('.panel-content, .timer-side-panel-content');
            const isAtTop = !scrollableContent || scrollableContent.scrollTop === 0;
            
            if (diff > 0 && isAtTop) {
                const translateY = Math.min(diff, 200);
                panelData.panel.style.transform = `translateY(${translateY}px)`;
            }
        }, { passive: true });
        
        panelData.panel.addEventListener('touchend', () => {
            if (!isMobileOrTablet()) return;
            const diff = panelTouchEndY - panelTouchStartY;
            panelData.panel.style.transform = '';
            
            if (diff > 100) {
                closeCurrentPanel();
            }
            
            panelTouchStartY = 0;
            panelTouchEndY = 0;
        });
    });
    
    // Handle window resize - close ALL panels when crossing 1200px threshold
    let resizeTimeout;
    let wasMobile = isMobileOrTablet();
    
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            const isMobile = isMobileOrTablet();
            
            // Close all panels when crossing the 1200px threshold in EITHER direction
            if (wasMobile !== isMobile) {
                console.log(`üì± Resolution changed: ${wasMobile ? 'mobile' : 'desktop'} ‚Üí ${isMobile ? 'mobile' : 'desktop'}`);
                closeAll(); // This now handles everything
                currentOpenPanel = null;
            }
            
            wasMobile = isMobile;
        }, 100); // Reduced debounce for faster response
    });
    
    console.log('‚úÖ Mobile/Tablet bottom sheet system initialized (listeners ALWAYS active)');
});

